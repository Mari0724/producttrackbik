
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model auteRest
 * 
 */
export type auteRest = $Result.DefaultSelection<Prisma.$auteRestPayload>
/**
 * Model notificaciones
 * 
 */
export type notificaciones = $Result.DefaultSelection<Prisma.$notificacionesPayload>
/**
 * Model productos
 * 
 */
export type productos = $Result.DefaultSelection<Prisma.$productosPayload>
/**
 * Model histoVenta
 * 
 */
export type histoVenta = $Result.DefaultSelection<Prisma.$histoVentaPayload>
/**
 * Model recorStock
 * 
 */
export type recorStock = $Result.DefaultSelection<Prisma.$recorStockPayload>
/**
 * Model comentarios
 * 
 */
export type comentarios = $Result.DefaultSelection<Prisma.$comentariosPayload>
/**
 * Model soporte
 * 
 */
export type soporte = $Result.DefaultSelection<Prisma.$soportePayload>
/**
 * Model ajustInven
 * 
 */
export type ajustInven = $Result.DefaultSelection<Prisma.$ajustInvenPayload>
/**
 * Model alertVen
 * 
 */
export type alertVen = $Result.DefaultSelection<Prisma.$alertVenPayload>
/**
 * Model analisisImagenes
 * 
 */
export type analisisImagenes = $Result.DefaultSelection<Prisma.$analisisImagenesPayload>
/**
 * Model colaboraciones
 * 
 */
export type colaboraciones = $Result.DefaultSelection<Prisma.$colaboracionesPayload>
/**
 * Model histInv
 * 
 */
export type histInv = $Result.DefaultSelection<Prisma.$histInvPayload>
/**
 * Model api_logs
 * 
 */
export type api_logs = $Result.DefaultSelection<Prisma.$api_logsPayload>
/**
 * Model MonAudRend
 * 
 */
export type MonAudRend = $Result.DefaultSelection<Prisma.$MonAudRendPayload>
/**
 * Model auditoria
 * 
 */
export type auditoria = $Result.DefaultSelection<Prisma.$auditoriaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoUsuario: {
  INDIVIDUAL: 'INDIVIDUAL',
  EMPRESARIAL: 'EMPRESARIAL'
};

export type TipoUsuario = (typeof TipoUsuario)[keyof typeof TipoUsuario]


export const rol: {
  USUARIO: 'USUARIO',
  EQUIPO: 'EQUIPO',
  ADMIN: 'ADMIN',
  DESARROLLADOR: 'DESARROLLADOR'
};

export type rol = (typeof rol)[keyof typeof rol]


export const rolEquipo: {
  LECTOR: 'LECTOR',
  COMENTARISTA: 'COMENTARISTA',
  EDITOR: 'EDITOR',
  ADMIN: 'ADMIN'
};

export type rolEquipo = (typeof rolEquipo)[keyof typeof rolEquipo]


export const TipoNotificacion: {
  general: 'general',
  solicitud: 'solicitud',
  recomendacion: 'recomendacion'
};

export type TipoNotificacion = (typeof TipoNotificacion)[keyof typeof TipoNotificacion]


export const EstadoRecordatorio: {
  pendiente: 'pendiente',
  atendido: 'atendido'
};

export type EstadoRecordatorio = (typeof EstadoRecordatorio)[keyof typeof EstadoRecordatorio]


export const EstadoComentario: {
  pendiente: 'pendiente',
  revisado: 'revisado'
};

export type EstadoComentario = (typeof EstadoComentario)[keyof typeof EstadoComentario]


export const EstadoSoporte: {
  pendiente: 'pendiente',
  en_proceso: 'en_proceso',
  resuelto: 'resuelto'
};

export type EstadoSoporte = (typeof EstadoSoporte)[keyof typeof EstadoSoporte]


export const AccionHistorial: {
  agregado: 'agregado',
  modificado: 'modificado',
  eliminado: 'eliminado'
};

export type AccionHistorial = (typeof AccionHistorial)[keyof typeof AccionHistorial]


export const MetodoAPI: {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE'
};

export type MetodoAPI = (typeof MetodoAPI)[keyof typeof MetodoAPI]


export const TipoEvento: {
  evento: 'evento',
  error: 'error',
  metrica: 'metrica'
};

export type TipoEvento = (typeof TipoEvento)[keyof typeof TipoEvento]

}

export type TipoUsuario = $Enums.TipoUsuario

export const TipoUsuario: typeof $Enums.TipoUsuario

export type rol = $Enums.rol

export const rol: typeof $Enums.rol

export type rolEquipo = $Enums.rolEquipo

export const rolEquipo: typeof $Enums.rolEquipo

export type TipoNotificacion = $Enums.TipoNotificacion

export const TipoNotificacion: typeof $Enums.TipoNotificacion

export type EstadoRecordatorio = $Enums.EstadoRecordatorio

export const EstadoRecordatorio: typeof $Enums.EstadoRecordatorio

export type EstadoComentario = $Enums.EstadoComentario

export const EstadoComentario: typeof $Enums.EstadoComentario

export type EstadoSoporte = $Enums.EstadoSoporte

export const EstadoSoporte: typeof $Enums.EstadoSoporte

export type AccionHistorial = $Enums.AccionHistorial

export const AccionHistorial: typeof $Enums.AccionHistorial

export type MetodoAPI = $Enums.MetodoAPI

export const MetodoAPI: typeof $Enums.MetodoAPI

export type TipoEvento = $Enums.TipoEvento

export const TipoEvento: typeof $Enums.TipoEvento

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auteRest`: Exposes CRUD operations for the **auteRest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuteRests
    * const auteRests = await prisma.auteRest.findMany()
    * ```
    */
  get auteRest(): Prisma.auteRestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificaciones`: Exposes CRUD operations for the **notificaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificaciones
    * const notificaciones = await prisma.notificaciones.findMany()
    * ```
    */
  get notificaciones(): Prisma.notificacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productos`: Exposes CRUD operations for the **productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.productos.findMany()
    * ```
    */
  get productos(): Prisma.productosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histoVenta`: Exposes CRUD operations for the **histoVenta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoVentas
    * const histoVentas = await prisma.histoVenta.findMany()
    * ```
    */
  get histoVenta(): Prisma.histoVentaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recorStock`: Exposes CRUD operations for the **recorStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecorStocks
    * const recorStocks = await prisma.recorStock.findMany()
    * ```
    */
  get recorStock(): Prisma.recorStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comentarios`: Exposes CRUD operations for the **comentarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentarios.findMany()
    * ```
    */
  get comentarios(): Prisma.comentariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soporte`: Exposes CRUD operations for the **soporte** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Soportes
    * const soportes = await prisma.soporte.findMany()
    * ```
    */
  get soporte(): Prisma.soporteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ajustInven`: Exposes CRUD operations for the **ajustInven** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AjustInvens
    * const ajustInvens = await prisma.ajustInven.findMany()
    * ```
    */
  get ajustInven(): Prisma.ajustInvenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertVen`: Exposes CRUD operations for the **alertVen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertVens
    * const alertVens = await prisma.alertVen.findMany()
    * ```
    */
  get alertVen(): Prisma.alertVenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analisisImagenes`: Exposes CRUD operations for the **analisisImagenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalisisImagenes
    * const analisisImagenes = await prisma.analisisImagenes.findMany()
    * ```
    */
  get analisisImagenes(): Prisma.analisisImagenesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.colaboraciones`: Exposes CRUD operations for the **colaboraciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colaboraciones
    * const colaboraciones = await prisma.colaboraciones.findMany()
    * ```
    */
  get colaboraciones(): Prisma.colaboracionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histInv`: Exposes CRUD operations for the **histInv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistInvs
    * const histInvs = await prisma.histInv.findMany()
    * ```
    */
  get histInv(): Prisma.histInvDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.api_logs`: Exposes CRUD operations for the **api_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_logs
    * const api_logs = await prisma.api_logs.findMany()
    * ```
    */
  get api_logs(): Prisma.api_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.monAudRend`: Exposes CRUD operations for the **MonAudRend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonAudRends
    * const monAudRends = await prisma.monAudRend.findMany()
    * ```
    */
  get monAudRend(): Prisma.MonAudRendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditoria`: Exposes CRUD operations for the **auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.auditoriaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    auteRest: 'auteRest',
    notificaciones: 'notificaciones',
    productos: 'productos',
    histoVenta: 'histoVenta',
    recorStock: 'recorStock',
    comentarios: 'comentarios',
    soporte: 'soporte',
    ajustInven: 'ajustInven',
    alertVen: 'alertVen',
    analisisImagenes: 'analisisImagenes',
    colaboraciones: 'colaboraciones',
    histInv: 'histInv',
    api_logs: 'api_logs',
    MonAudRend: 'MonAudRend',
    auditoria: 'auditoria'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "auteRest" | "notificaciones" | "productos" | "histoVenta" | "recorStock" | "comentarios" | "soporte" | "ajustInven" | "alertVen" | "analisisImagenes" | "colaboraciones" | "histInv" | "api_logs" | "monAudRend" | "auditoria"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      auteRest: {
        payload: Prisma.$auteRestPayload<ExtArgs>
        fields: Prisma.auteRestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auteRestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auteRestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          findFirst: {
            args: Prisma.auteRestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auteRestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          findMany: {
            args: Prisma.auteRestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>[]
          }
          create: {
            args: Prisma.auteRestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          createMany: {
            args: Prisma.auteRestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auteRestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>[]
          }
          delete: {
            args: Prisma.auteRestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          update: {
            args: Prisma.auteRestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          deleteMany: {
            args: Prisma.auteRestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auteRestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auteRestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>[]
          }
          upsert: {
            args: Prisma.auteRestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auteRestPayload>
          }
          aggregate: {
            args: Prisma.AuteRestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuteRest>
          }
          groupBy: {
            args: Prisma.auteRestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuteRestGroupByOutputType>[]
          }
          count: {
            args: Prisma.auteRestCountArgs<ExtArgs>
            result: $Utils.Optional<AuteRestCountAggregateOutputType> | number
          }
        }
      }
      notificaciones: {
        payload: Prisma.$notificacionesPayload<ExtArgs>
        fields: Prisma.notificacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          findFirst: {
            args: Prisma.notificacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          findMany: {
            args: Prisma.notificacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          create: {
            args: Prisma.notificacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          createMany: {
            args: Prisma.notificacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          delete: {
            args: Prisma.notificacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          update: {
            args: Prisma.notificacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          deleteMany: {
            args: Prisma.notificacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          upsert: {
            args: Prisma.notificacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          aggregate: {
            args: Prisma.NotificacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificaciones>
          }
          groupBy: {
            args: Prisma.notificacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificacionesCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionesCountAggregateOutputType> | number
          }
        }
      }
      productos: {
        payload: Prisma.$productosPayload<ExtArgs>
        fields: Prisma.productosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          findFirst: {
            args: Prisma.productosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          findMany: {
            args: Prisma.productosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          create: {
            args: Prisma.productosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          createMany: {
            args: Prisma.productosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          delete: {
            args: Prisma.productosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          update: {
            args: Prisma.productosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          deleteMany: {
            args: Prisma.productosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          upsert: {
            args: Prisma.productosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          aggregate: {
            args: Prisma.ProductosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductos>
          }
          groupBy: {
            args: Prisma.productosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductosGroupByOutputType>[]
          }
          count: {
            args: Prisma.productosCountArgs<ExtArgs>
            result: $Utils.Optional<ProductosCountAggregateOutputType> | number
          }
        }
      }
      histoVenta: {
        payload: Prisma.$histoVentaPayload<ExtArgs>
        fields: Prisma.histoVentaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.histoVentaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.histoVentaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          findFirst: {
            args: Prisma.histoVentaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.histoVentaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          findMany: {
            args: Prisma.histoVentaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>[]
          }
          create: {
            args: Prisma.histoVentaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          createMany: {
            args: Prisma.histoVentaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.histoVentaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>[]
          }
          delete: {
            args: Prisma.histoVentaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          update: {
            args: Prisma.histoVentaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          deleteMany: {
            args: Prisma.histoVentaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.histoVentaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.histoVentaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>[]
          }
          upsert: {
            args: Prisma.histoVentaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histoVentaPayload>
          }
          aggregate: {
            args: Prisma.HistoVentaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoVenta>
          }
          groupBy: {
            args: Prisma.histoVentaGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoVentaGroupByOutputType>[]
          }
          count: {
            args: Prisma.histoVentaCountArgs<ExtArgs>
            result: $Utils.Optional<HistoVentaCountAggregateOutputType> | number
          }
        }
      }
      recorStock: {
        payload: Prisma.$recorStockPayload<ExtArgs>
        fields: Prisma.recorStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recorStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recorStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          findFirst: {
            args: Prisma.recorStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recorStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          findMany: {
            args: Prisma.recorStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          create: {
            args: Prisma.recorStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          createMany: {
            args: Prisma.recorStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recorStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          delete: {
            args: Prisma.recorStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          update: {
            args: Prisma.recorStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          deleteMany: {
            args: Prisma.recorStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recorStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recorStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          upsert: {
            args: Prisma.recorStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          aggregate: {
            args: Prisma.RecorStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecorStock>
          }
          groupBy: {
            args: Prisma.recorStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecorStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.recorStockCountArgs<ExtArgs>
            result: $Utils.Optional<RecorStockCountAggregateOutputType> | number
          }
        }
      }
      comentarios: {
        payload: Prisma.$comentariosPayload<ExtArgs>
        fields: Prisma.comentariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comentariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comentariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          findFirst: {
            args: Prisma.comentariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comentariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          findMany: {
            args: Prisma.comentariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          create: {
            args: Prisma.comentariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          createMany: {
            args: Prisma.comentariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comentariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          delete: {
            args: Prisma.comentariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          update: {
            args: Prisma.comentariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          deleteMany: {
            args: Prisma.comentariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comentariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comentariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          upsert: {
            args: Prisma.comentariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          aggregate: {
            args: Prisma.ComentariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentarios>
          }
          groupBy: {
            args: Prisma.comentariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.comentariosCountArgs<ExtArgs>
            result: $Utils.Optional<ComentariosCountAggregateOutputType> | number
          }
        }
      }
      soporte: {
        payload: Prisma.$soportePayload<ExtArgs>
        fields: Prisma.soporteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.soporteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.soporteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          findFirst: {
            args: Prisma.soporteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.soporteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          findMany: {
            args: Prisma.soporteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>[]
          }
          create: {
            args: Prisma.soporteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          createMany: {
            args: Prisma.soporteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.soporteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>[]
          }
          delete: {
            args: Prisma.soporteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          update: {
            args: Prisma.soporteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          deleteMany: {
            args: Prisma.soporteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.soporteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.soporteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>[]
          }
          upsert: {
            args: Prisma.soporteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$soportePayload>
          }
          aggregate: {
            args: Prisma.SoporteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoporte>
          }
          groupBy: {
            args: Prisma.soporteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoporteGroupByOutputType>[]
          }
          count: {
            args: Prisma.soporteCountArgs<ExtArgs>
            result: $Utils.Optional<SoporteCountAggregateOutputType> | number
          }
        }
      }
      ajustInven: {
        payload: Prisma.$ajustInvenPayload<ExtArgs>
        fields: Prisma.ajustInvenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ajustInvenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ajustInvenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          findFirst: {
            args: Prisma.ajustInvenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ajustInvenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          findMany: {
            args: Prisma.ajustInvenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>[]
          }
          create: {
            args: Prisma.ajustInvenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          createMany: {
            args: Prisma.ajustInvenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ajustInvenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>[]
          }
          delete: {
            args: Prisma.ajustInvenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          update: {
            args: Prisma.ajustInvenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          deleteMany: {
            args: Prisma.ajustInvenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ajustInvenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ajustInvenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>[]
          }
          upsert: {
            args: Prisma.ajustInvenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ajustInvenPayload>
          }
          aggregate: {
            args: Prisma.AjustInvenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAjustInven>
          }
          groupBy: {
            args: Prisma.ajustInvenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AjustInvenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ajustInvenCountArgs<ExtArgs>
            result: $Utils.Optional<AjustInvenCountAggregateOutputType> | number
          }
        }
      }
      alertVen: {
        payload: Prisma.$alertVenPayload<ExtArgs>
        fields: Prisma.alertVenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alertVenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alertVenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          findFirst: {
            args: Prisma.alertVenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alertVenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          findMany: {
            args: Prisma.alertVenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>[]
          }
          create: {
            args: Prisma.alertVenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          createMany: {
            args: Prisma.alertVenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.alertVenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>[]
          }
          delete: {
            args: Prisma.alertVenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          update: {
            args: Prisma.alertVenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          deleteMany: {
            args: Prisma.alertVenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alertVenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.alertVenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>[]
          }
          upsert: {
            args: Prisma.alertVenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertVenPayload>
          }
          aggregate: {
            args: Prisma.AlertVenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertVen>
          }
          groupBy: {
            args: Prisma.alertVenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertVenGroupByOutputType>[]
          }
          count: {
            args: Prisma.alertVenCountArgs<ExtArgs>
            result: $Utils.Optional<AlertVenCountAggregateOutputType> | number
          }
        }
      }
      analisisImagenes: {
        payload: Prisma.$analisisImagenesPayload<ExtArgs>
        fields: Prisma.analisisImagenesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.analisisImagenesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.analisisImagenesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          findFirst: {
            args: Prisma.analisisImagenesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.analisisImagenesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          findMany: {
            args: Prisma.analisisImagenesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>[]
          }
          create: {
            args: Prisma.analisisImagenesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          createMany: {
            args: Prisma.analisisImagenesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.analisisImagenesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>[]
          }
          delete: {
            args: Prisma.analisisImagenesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          update: {
            args: Prisma.analisisImagenesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          deleteMany: {
            args: Prisma.analisisImagenesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.analisisImagenesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.analisisImagenesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>[]
          }
          upsert: {
            args: Prisma.analisisImagenesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$analisisImagenesPayload>
          }
          aggregate: {
            args: Prisma.AnalisisImagenesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalisisImagenes>
          }
          groupBy: {
            args: Prisma.analisisImagenesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalisisImagenesGroupByOutputType>[]
          }
          count: {
            args: Prisma.analisisImagenesCountArgs<ExtArgs>
            result: $Utils.Optional<AnalisisImagenesCountAggregateOutputType> | number
          }
        }
      }
      colaboraciones: {
        payload: Prisma.$colaboracionesPayload<ExtArgs>
        fields: Prisma.colaboracionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.colaboracionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.colaboracionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          findFirst: {
            args: Prisma.colaboracionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.colaboracionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          findMany: {
            args: Prisma.colaboracionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>[]
          }
          create: {
            args: Prisma.colaboracionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          createMany: {
            args: Prisma.colaboracionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.colaboracionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>[]
          }
          delete: {
            args: Prisma.colaboracionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          update: {
            args: Prisma.colaboracionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          deleteMany: {
            args: Prisma.colaboracionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.colaboracionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.colaboracionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>[]
          }
          upsert: {
            args: Prisma.colaboracionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$colaboracionesPayload>
          }
          aggregate: {
            args: Prisma.ColaboracionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColaboraciones>
          }
          groupBy: {
            args: Prisma.colaboracionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColaboracionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.colaboracionesCountArgs<ExtArgs>
            result: $Utils.Optional<ColaboracionesCountAggregateOutputType> | number
          }
        }
      }
      histInv: {
        payload: Prisma.$histInvPayload<ExtArgs>
        fields: Prisma.histInvFieldRefs
        operations: {
          findUnique: {
            args: Prisma.histInvFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.histInvFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          findFirst: {
            args: Prisma.histInvFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.histInvFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          findMany: {
            args: Prisma.histInvFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          create: {
            args: Prisma.histInvCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          createMany: {
            args: Prisma.histInvCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.histInvCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          delete: {
            args: Prisma.histInvDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          update: {
            args: Prisma.histInvUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          deleteMany: {
            args: Prisma.histInvDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.histInvUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.histInvUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          upsert: {
            args: Prisma.histInvUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          aggregate: {
            args: Prisma.HistInvAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistInv>
          }
          groupBy: {
            args: Prisma.histInvGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistInvGroupByOutputType>[]
          }
          count: {
            args: Prisma.histInvCountArgs<ExtArgs>
            result: $Utils.Optional<HistInvCountAggregateOutputType> | number
          }
        }
      }
      api_logs: {
        payload: Prisma.$api_logsPayload<ExtArgs>
        fields: Prisma.api_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          findFirst: {
            args: Prisma.api_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          findMany: {
            args: Prisma.api_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>[]
          }
          create: {
            args: Prisma.api_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          createMany: {
            args: Prisma.api_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.api_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>[]
          }
          delete: {
            args: Prisma.api_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          update: {
            args: Prisma.api_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          deleteMany: {
            args: Prisma.api_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.api_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.api_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>[]
          }
          upsert: {
            args: Prisma.api_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_logsPayload>
          }
          aggregate: {
            args: Prisma.Api_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApi_logs>
          }
          groupBy: {
            args: Prisma.api_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Api_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Api_logsCountAggregateOutputType> | number
          }
        }
      }
      MonAudRend: {
        payload: Prisma.$MonAudRendPayload<ExtArgs>
        fields: Prisma.MonAudRendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonAudRendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonAudRendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          findFirst: {
            args: Prisma.MonAudRendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonAudRendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          findMany: {
            args: Prisma.MonAudRendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>[]
          }
          create: {
            args: Prisma.MonAudRendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          createMany: {
            args: Prisma.MonAudRendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonAudRendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>[]
          }
          delete: {
            args: Prisma.MonAudRendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          update: {
            args: Prisma.MonAudRendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          deleteMany: {
            args: Prisma.MonAudRendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonAudRendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MonAudRendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>[]
          }
          upsert: {
            args: Prisma.MonAudRendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonAudRendPayload>
          }
          aggregate: {
            args: Prisma.MonAudRendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonAudRend>
          }
          groupBy: {
            args: Prisma.MonAudRendGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonAudRendGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonAudRendCountArgs<ExtArgs>
            result: $Utils.Optional<MonAudRendCountAggregateOutputType> | number
          }
        }
      }
      auditoria: {
        payload: Prisma.$auditoriaPayload<ExtArgs>
        fields: Prisma.auditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findFirst: {
            args: Prisma.auditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findMany: {
            args: Prisma.auditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          create: {
            args: Prisma.auditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          createMany: {
            args: Prisma.auditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          delete: {
            args: Prisma.auditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          update: {
            args: Prisma.auditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          deleteMany: {
            args: Prisma.auditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          upsert: {
            args: Prisma.auditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          aggregate: {
            args: Prisma.AuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditoria>
          }
          groupBy: {
            args: Prisma.auditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    auteRest?: auteRestOmit
    notificaciones?: notificacionesOmit
    productos?: productosOmit
    histoVenta?: histoVentaOmit
    recorStock?: recorStockOmit
    comentarios?: comentariosOmit
    soporte?: soporteOmit
    ajustInven?: ajustInvenOmit
    alertVen?: alertVenOmit
    analisisImagenes?: analisisImagenesOmit
    colaboraciones?: colaboracionesOmit
    histInv?: histInvOmit
    api_logs?: api_logsOmit
    monAudRend?: MonAudRendOmit
    auditoria?: auditoriaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    MonAudRend: number
    ajustInven: number
    analisisImagenes: number
    api_logs: number
    auditoria: number
    comentarios: number
    histInv: number
    notificaciones: number
    productos: number
    soporte: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MonAudRend?: boolean | UsersCountOutputTypeCountMonAudRendArgs
    ajustInven?: boolean | UsersCountOutputTypeCountAjustInvenArgs
    analisisImagenes?: boolean | UsersCountOutputTypeCountAnalisisImagenesArgs
    api_logs?: boolean | UsersCountOutputTypeCountApi_logsArgs
    auditoria?: boolean | UsersCountOutputTypeCountAuditoriaArgs
    comentarios?: boolean | UsersCountOutputTypeCountComentariosArgs
    histInv?: boolean | UsersCountOutputTypeCountHistInvArgs
    notificaciones?: boolean | UsersCountOutputTypeCountNotificacionesArgs
    productos?: boolean | UsersCountOutputTypeCountProductosArgs
    soporte?: boolean | UsersCountOutputTypeCountSoporteArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMonAudRendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonAudRendWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAjustInvenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ajustInvenWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnalisisImagenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analisisImagenesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountApi_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentariosWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountHistInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificacionesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productosWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSoporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soporteWhereInput
  }


  /**
   * Count Type ProductosCountOutputType
   */

  export type ProductosCountOutputType = {
    ajustInven: number
    alertVen: number
    colaboraciones: number
    histInv: number
    histoVenta: number
    recorStock: number
  }

  export type ProductosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ajustInven?: boolean | ProductosCountOutputTypeCountAjustInvenArgs
    alertVen?: boolean | ProductosCountOutputTypeCountAlertVenArgs
    colaboraciones?: boolean | ProductosCountOutputTypeCountColaboracionesArgs
    histInv?: boolean | ProductosCountOutputTypeCountHistInvArgs
    histoVenta?: boolean | ProductosCountOutputTypeCountHistoVentaArgs
    recorStock?: boolean | ProductosCountOutputTypeCountRecorStockArgs
  }

  // Custom InputTypes
  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductosCountOutputType
     */
    select?: ProductosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountAjustInvenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ajustInvenWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountAlertVenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertVenWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountColaboracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: colaboracionesWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountHistInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountHistoVentaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histoVentaWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountRecorStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recorStockWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    idUsuario: number | null
  }

  export type UsersSumAggregateOutputType = {
    idUsuario: number | null
  }

  export type UsersMinAggregateOutputType = {
    idUsuario: number | null
    username: string | null
    correo: string | null
    password: string | null
    nombreCompleto: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfil: string | null
    nombreEmpresa: string | null
    nit: string | null
    estado: string | null
    rol: string | null
    rolEquipo: $Enums.rolEquipo | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    tipoUsuario: $Enums.TipoUsuario | null
  }

  export type UsersMaxAggregateOutputType = {
    idUsuario: number | null
    username: string | null
    correo: string | null
    password: string | null
    nombreCompleto: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfil: string | null
    nombreEmpresa: string | null
    nit: string | null
    estado: string | null
    rol: string | null
    rolEquipo: $Enums.rolEquipo | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    tipoUsuario: $Enums.TipoUsuario | null
  }

  export type UsersCountAggregateOutputType = {
    idUsuario: number
    username: number
    correo: number
    password: number
    nombreCompleto: number
    telefono: number
    direccion: number
    fotoPerfil: number
    nombreEmpresa: number
    nit: number
    estado: number
    rol: number
    rolEquipo: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    tipoUsuario: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    idUsuario?: true
  }

  export type UsersSumAggregateInputType = {
    idUsuario?: true
  }

  export type UsersMinAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    rolEquipo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    tipoUsuario?: true
  }

  export type UsersMaxAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    rolEquipo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    tipoUsuario?: true
  }

  export type UsersCountAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    rolEquipo?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    tipoUsuario?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    idUsuario: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa: string | null
    nit: string | null
    estado: string
    rol: string
    rolEquipo: $Enums.rolEquipo | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    tipoUsuario: $Enums.TipoUsuario
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    rolEquipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tipoUsuario?: boolean
    MonAudRend?: boolean | users$MonAudRendArgs<ExtArgs>
    ajustInven?: boolean | users$ajustInvenArgs<ExtArgs>
    analisisImagenes?: boolean | users$analisisImagenesArgs<ExtArgs>
    api_logs?: boolean | users$api_logsArgs<ExtArgs>
    auditoria?: boolean | users$auditoriaArgs<ExtArgs>
    auteRest?: boolean | users$auteRestArgs<ExtArgs>
    comentarios?: boolean | users$comentariosArgs<ExtArgs>
    histInv?: boolean | users$histInvArgs<ExtArgs>
    notificaciones?: boolean | users$notificacionesArgs<ExtArgs>
    productos?: boolean | users$productosArgs<ExtArgs>
    soporte?: boolean | users$soporteArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    rolEquipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tipoUsuario?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    rolEquipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tipoUsuario?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    rolEquipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tipoUsuario?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idUsuario" | "username" | "correo" | "password" | "nombreCompleto" | "telefono" | "direccion" | "fotoPerfil" | "nombreEmpresa" | "nit" | "estado" | "rol" | "rolEquipo" | "createdAt" | "updatedAt" | "deletedAt" | "tipoUsuario", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MonAudRend?: boolean | users$MonAudRendArgs<ExtArgs>
    ajustInven?: boolean | users$ajustInvenArgs<ExtArgs>
    analisisImagenes?: boolean | users$analisisImagenesArgs<ExtArgs>
    api_logs?: boolean | users$api_logsArgs<ExtArgs>
    auditoria?: boolean | users$auditoriaArgs<ExtArgs>
    auteRest?: boolean | users$auteRestArgs<ExtArgs>
    comentarios?: boolean | users$comentariosArgs<ExtArgs>
    histInv?: boolean | users$histInvArgs<ExtArgs>
    notificaciones?: boolean | users$notificacionesArgs<ExtArgs>
    productos?: boolean | users$productosArgs<ExtArgs>
    soporte?: boolean | users$soporteArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      MonAudRend: Prisma.$MonAudRendPayload<ExtArgs>[]
      ajustInven: Prisma.$ajustInvenPayload<ExtArgs>[]
      analisisImagenes: Prisma.$analisisImagenesPayload<ExtArgs>[]
      api_logs: Prisma.$api_logsPayload<ExtArgs>[]
      auditoria: Prisma.$auditoriaPayload<ExtArgs>[]
      auteRest: Prisma.$auteRestPayload<ExtArgs> | null
      comentarios: Prisma.$comentariosPayload<ExtArgs>[]
      histInv: Prisma.$histInvPayload<ExtArgs>[]
      notificaciones: Prisma.$notificacionesPayload<ExtArgs>[]
      productos: Prisma.$productosPayload<ExtArgs>[]
      soporte: Prisma.$soportePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idUsuario: number
      username: string
      correo: string
      password: string
      nombreCompleto: string
      telefono: string
      direccion: string
      fotoPerfil: string
      nombreEmpresa: string | null
      nit: string | null
      estado: string
      rol: string
      rolEquipo: $Enums.rolEquipo | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      tipoUsuario: $Enums.TipoUsuario
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.findMany({ select: { idUsuario: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.createManyAndReturn({
     *   select: { idUsuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.updateManyAndReturn({
     *   select: { idUsuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MonAudRend<T extends users$MonAudRendArgs<ExtArgs> = {}>(args?: Subset<T, users$MonAudRendArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ajustInven<T extends users$ajustInvenArgs<ExtArgs> = {}>(args?: Subset<T, users$ajustInvenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analisisImagenes<T extends users$analisisImagenesArgs<ExtArgs> = {}>(args?: Subset<T, users$analisisImagenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    api_logs<T extends users$api_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$api_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditoria<T extends users$auditoriaArgs<ExtArgs> = {}>(args?: Subset<T, users$auditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auteRest<T extends users$auteRestArgs<ExtArgs> = {}>(args?: Subset<T, users$auteRestArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comentarios<T extends users$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, users$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histInv<T extends users$histInvArgs<ExtArgs> = {}>(args?: Subset<T, users$histInvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificaciones<T extends users$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, users$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productos<T extends users$productosArgs<ExtArgs> = {}>(args?: Subset<T, users$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soporte<T extends users$soporteArgs<ExtArgs> = {}>(args?: Subset<T, users$soporteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly idUsuario: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly correo: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly nombreCompleto: FieldRef<"users", 'String'>
    readonly telefono: FieldRef<"users", 'String'>
    readonly direccion: FieldRef<"users", 'String'>
    readonly fotoPerfil: FieldRef<"users", 'String'>
    readonly nombreEmpresa: FieldRef<"users", 'String'>
    readonly nit: FieldRef<"users", 'String'>
    readonly estado: FieldRef<"users", 'String'>
    readonly rol: FieldRef<"users", 'String'>
    readonly rolEquipo: FieldRef<"users", 'rolEquipo'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly deletedAt: FieldRef<"users", 'DateTime'>
    readonly tipoUsuario: FieldRef<"users", 'TipoUsuario'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.MonAudRend
   */
  export type users$MonAudRendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    where?: MonAudRendWhereInput
    orderBy?: MonAudRendOrderByWithRelationInput | MonAudRendOrderByWithRelationInput[]
    cursor?: MonAudRendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonAudRendScalarFieldEnum | MonAudRendScalarFieldEnum[]
  }

  /**
   * users.ajustInven
   */
  export type users$ajustInvenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    where?: ajustInvenWhereInput
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    cursor?: ajustInvenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AjustInvenScalarFieldEnum | AjustInvenScalarFieldEnum[]
  }

  /**
   * users.analisisImagenes
   */
  export type users$analisisImagenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    where?: analisisImagenesWhereInput
    orderBy?: analisisImagenesOrderByWithRelationInput | analisisImagenesOrderByWithRelationInput[]
    cursor?: analisisImagenesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalisisImagenesScalarFieldEnum | AnalisisImagenesScalarFieldEnum[]
  }

  /**
   * users.api_logs
   */
  export type users$api_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    where?: api_logsWhereInput
    orderBy?: api_logsOrderByWithRelationInput | api_logsOrderByWithRelationInput[]
    cursor?: api_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Api_logsScalarFieldEnum | Api_logsScalarFieldEnum[]
  }

  /**
   * users.auditoria
   */
  export type users$auditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    cursor?: auditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * users.auteRest
   */
  export type users$auteRestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    where?: auteRestWhereInput
  }

  /**
   * users.comentarios
   */
  export type users$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    where?: comentariosWhereInput
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    cursor?: comentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * users.histInv
   */
  export type users$histInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    cursor?: histInvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * users.notificaciones
   */
  export type users$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    where?: notificacionesWhereInput
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    cursor?: notificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * users.productos
   */
  export type users$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    where?: productosWhereInput
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    cursor?: productosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * users.soporte
   */
  export type users$soporteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    where?: soporteWhereInput
    orderBy?: soporteOrderByWithRelationInput | soporteOrderByWithRelationInput[]
    cursor?: soporteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoporteScalarFieldEnum | SoporteScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model auteRest
   */

  export type AggregateAuteRest = {
    _count: AuteRestCountAggregateOutputType | null
    _avg: AuteRestAvgAggregateOutputType | null
    _sum: AuteRestSumAggregateOutputType | null
    _min: AuteRestMinAggregateOutputType | null
    _max: AuteRestMaxAggregateOutputType | null
  }

  export type AuteRestAvgAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
  }

  export type AuteRestSumAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
  }

  export type AuteRestMinAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
    googleId: string | null
    token: string | null
    fechaSolicitud: Date | null
    fechaExpiracion: Date | null
    usado: boolean | null
    confirmado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuteRestMaxAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
    googleId: string | null
    token: string | null
    fechaSolicitud: Date | null
    fechaExpiracion: Date | null
    usado: boolean | null
    confirmado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuteRestCountAggregateOutputType = {
    idSeguridad: number
    idUsuario: number
    googleId: number
    token: number
    fechaSolicitud: number
    fechaExpiracion: number
    usado: number
    confirmado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuteRestAvgAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
  }

  export type AuteRestSumAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
  }

  export type AuteRestMinAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    googleId?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
    confirmado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuteRestMaxAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    googleId?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
    confirmado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuteRestCountAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    googleId?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
    confirmado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuteRestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auteRest to aggregate.
     */
    where?: auteRestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auteRests to fetch.
     */
    orderBy?: auteRestOrderByWithRelationInput | auteRestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auteRestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auteRests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auteRests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auteRests
    **/
    _count?: true | AuteRestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuteRestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuteRestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuteRestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuteRestMaxAggregateInputType
  }

  export type GetAuteRestAggregateType<T extends AuteRestAggregateArgs> = {
        [P in keyof T & keyof AggregateAuteRest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuteRest[P]>
      : GetScalarType<T[P], AggregateAuteRest[P]>
  }




  export type auteRestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auteRestWhereInput
    orderBy?: auteRestOrderByWithAggregationInput | auteRestOrderByWithAggregationInput[]
    by: AuteRestScalarFieldEnum[] | AuteRestScalarFieldEnum
    having?: auteRestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuteRestCountAggregateInputType | true
    _avg?: AuteRestAvgAggregateInputType
    _sum?: AuteRestSumAggregateInputType
    _min?: AuteRestMinAggregateInputType
    _max?: AuteRestMaxAggregateInputType
  }

  export type AuteRestGroupByOutputType = {
    idSeguridad: number
    idUsuario: number
    googleId: string
    token: string
    fechaSolicitud: Date
    fechaExpiracion: Date
    usado: boolean
    confirmado: boolean
    createdAt: Date
    updatedAt: Date
    _count: AuteRestCountAggregateOutputType | null
    _avg: AuteRestAvgAggregateOutputType | null
    _sum: AuteRestSumAggregateOutputType | null
    _min: AuteRestMinAggregateOutputType | null
    _max: AuteRestMaxAggregateOutputType | null
  }

  type GetAuteRestGroupByPayload<T extends auteRestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuteRestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuteRestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuteRestGroupByOutputType[P]>
            : GetScalarType<T[P], AuteRestGroupByOutputType[P]>
        }
      >
    >


  export type auteRestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    googleId?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    confirmado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auteRest"]>

  export type auteRestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    googleId?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    confirmado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auteRest"]>

  export type auteRestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    googleId?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    confirmado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auteRest"]>

  export type auteRestSelectScalar = {
    idSeguridad?: boolean
    idUsuario?: boolean
    googleId?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    confirmado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type auteRestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSeguridad" | "idUsuario" | "googleId" | "token" | "fechaSolicitud" | "fechaExpiracion" | "usado" | "confirmado" | "createdAt" | "updatedAt", ExtArgs["result"]["auteRest"]>
  export type auteRestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auteRestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auteRestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $auteRestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auteRest"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idSeguridad: number
      idUsuario: number
      googleId: string
      token: string
      fechaSolicitud: Date
      fechaExpiracion: Date
      usado: boolean
      confirmado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auteRest"]>
    composites: {}
  }

  type auteRestGetPayload<S extends boolean | null | undefined | auteRestDefaultArgs> = $Result.GetResult<Prisma.$auteRestPayload, S>

  type auteRestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auteRestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuteRestCountAggregateInputType | true
    }

  export interface auteRestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auteRest'], meta: { name: 'auteRest' } }
    /**
     * Find zero or one AuteRest that matches the filter.
     * @param {auteRestFindUniqueArgs} args - Arguments to find a AuteRest
     * @example
     * // Get one AuteRest
     * const auteRest = await prisma.auteRest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auteRestFindUniqueArgs>(args: SelectSubset<T, auteRestFindUniqueArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuteRest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auteRestFindUniqueOrThrowArgs} args - Arguments to find a AuteRest
     * @example
     * // Get one AuteRest
     * const auteRest = await prisma.auteRest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auteRestFindUniqueOrThrowArgs>(args: SelectSubset<T, auteRestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuteRest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestFindFirstArgs} args - Arguments to find a AuteRest
     * @example
     * // Get one AuteRest
     * const auteRest = await prisma.auteRest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auteRestFindFirstArgs>(args?: SelectSubset<T, auteRestFindFirstArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuteRest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestFindFirstOrThrowArgs} args - Arguments to find a AuteRest
     * @example
     * // Get one AuteRest
     * const auteRest = await prisma.auteRest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auteRestFindFirstOrThrowArgs>(args?: SelectSubset<T, auteRestFindFirstOrThrowArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuteRests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuteRests
     * const auteRests = await prisma.auteRest.findMany()
     * 
     * // Get first 10 AuteRests
     * const auteRests = await prisma.auteRest.findMany({ take: 10 })
     * 
     * // Only select the `idSeguridad`
     * const auteRestWithIdSeguridadOnly = await prisma.auteRest.findMany({ select: { idSeguridad: true } })
     * 
     */
    findMany<T extends auteRestFindManyArgs>(args?: SelectSubset<T, auteRestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuteRest.
     * @param {auteRestCreateArgs} args - Arguments to create a AuteRest.
     * @example
     * // Create one AuteRest
     * const AuteRest = await prisma.auteRest.create({
     *   data: {
     *     // ... data to create a AuteRest
     *   }
     * })
     * 
     */
    create<T extends auteRestCreateArgs>(args: SelectSubset<T, auteRestCreateArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuteRests.
     * @param {auteRestCreateManyArgs} args - Arguments to create many AuteRests.
     * @example
     * // Create many AuteRests
     * const auteRest = await prisma.auteRest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auteRestCreateManyArgs>(args?: SelectSubset<T, auteRestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuteRests and returns the data saved in the database.
     * @param {auteRestCreateManyAndReturnArgs} args - Arguments to create many AuteRests.
     * @example
     * // Create many AuteRests
     * const auteRest = await prisma.auteRest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuteRests and only return the `idSeguridad`
     * const auteRestWithIdSeguridadOnly = await prisma.auteRest.createManyAndReturn({
     *   select: { idSeguridad: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auteRestCreateManyAndReturnArgs>(args?: SelectSubset<T, auteRestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuteRest.
     * @param {auteRestDeleteArgs} args - Arguments to delete one AuteRest.
     * @example
     * // Delete one AuteRest
     * const AuteRest = await prisma.auteRest.delete({
     *   where: {
     *     // ... filter to delete one AuteRest
     *   }
     * })
     * 
     */
    delete<T extends auteRestDeleteArgs>(args: SelectSubset<T, auteRestDeleteArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuteRest.
     * @param {auteRestUpdateArgs} args - Arguments to update one AuteRest.
     * @example
     * // Update one AuteRest
     * const auteRest = await prisma.auteRest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auteRestUpdateArgs>(args: SelectSubset<T, auteRestUpdateArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuteRests.
     * @param {auteRestDeleteManyArgs} args - Arguments to filter AuteRests to delete.
     * @example
     * // Delete a few AuteRests
     * const { count } = await prisma.auteRest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auteRestDeleteManyArgs>(args?: SelectSubset<T, auteRestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuteRests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuteRests
     * const auteRest = await prisma.auteRest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auteRestUpdateManyArgs>(args: SelectSubset<T, auteRestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuteRests and returns the data updated in the database.
     * @param {auteRestUpdateManyAndReturnArgs} args - Arguments to update many AuteRests.
     * @example
     * // Update many AuteRests
     * const auteRest = await prisma.auteRest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuteRests and only return the `idSeguridad`
     * const auteRestWithIdSeguridadOnly = await prisma.auteRest.updateManyAndReturn({
     *   select: { idSeguridad: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auteRestUpdateManyAndReturnArgs>(args: SelectSubset<T, auteRestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuteRest.
     * @param {auteRestUpsertArgs} args - Arguments to update or create a AuteRest.
     * @example
     * // Update or create a AuteRest
     * const auteRest = await prisma.auteRest.upsert({
     *   create: {
     *     // ... data to create a AuteRest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuteRest we want to update
     *   }
     * })
     */
    upsert<T extends auteRestUpsertArgs>(args: SelectSubset<T, auteRestUpsertArgs<ExtArgs>>): Prisma__auteRestClient<$Result.GetResult<Prisma.$auteRestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuteRests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestCountArgs} args - Arguments to filter AuteRests to count.
     * @example
     * // Count the number of AuteRests
     * const count = await prisma.auteRest.count({
     *   where: {
     *     // ... the filter for the AuteRests we want to count
     *   }
     * })
    **/
    count<T extends auteRestCountArgs>(
      args?: Subset<T, auteRestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuteRestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuteRest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuteRestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuteRestAggregateArgs>(args: Subset<T, AuteRestAggregateArgs>): Prisma.PrismaPromise<GetAuteRestAggregateType<T>>

    /**
     * Group by AuteRest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auteRestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auteRestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auteRestGroupByArgs['orderBy'] }
        : { orderBy?: auteRestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auteRestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuteRestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auteRest model
   */
  readonly fields: auteRestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auteRest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auteRestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auteRest model
   */
  interface auteRestFieldRefs {
    readonly idSeguridad: FieldRef<"auteRest", 'Int'>
    readonly idUsuario: FieldRef<"auteRest", 'Int'>
    readonly googleId: FieldRef<"auteRest", 'String'>
    readonly token: FieldRef<"auteRest", 'String'>
    readonly fechaSolicitud: FieldRef<"auteRest", 'DateTime'>
    readonly fechaExpiracion: FieldRef<"auteRest", 'DateTime'>
    readonly usado: FieldRef<"auteRest", 'Boolean'>
    readonly confirmado: FieldRef<"auteRest", 'Boolean'>
    readonly createdAt: FieldRef<"auteRest", 'DateTime'>
    readonly updatedAt: FieldRef<"auteRest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auteRest findUnique
   */
  export type auteRestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter, which auteRest to fetch.
     */
    where: auteRestWhereUniqueInput
  }

  /**
   * auteRest findUniqueOrThrow
   */
  export type auteRestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter, which auteRest to fetch.
     */
    where: auteRestWhereUniqueInput
  }

  /**
   * auteRest findFirst
   */
  export type auteRestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter, which auteRest to fetch.
     */
    where?: auteRestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auteRests to fetch.
     */
    orderBy?: auteRestOrderByWithRelationInput | auteRestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auteRests.
     */
    cursor?: auteRestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auteRests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auteRests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auteRests.
     */
    distinct?: AuteRestScalarFieldEnum | AuteRestScalarFieldEnum[]
  }

  /**
   * auteRest findFirstOrThrow
   */
  export type auteRestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter, which auteRest to fetch.
     */
    where?: auteRestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auteRests to fetch.
     */
    orderBy?: auteRestOrderByWithRelationInput | auteRestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auteRests.
     */
    cursor?: auteRestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auteRests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auteRests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auteRests.
     */
    distinct?: AuteRestScalarFieldEnum | AuteRestScalarFieldEnum[]
  }

  /**
   * auteRest findMany
   */
  export type auteRestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter, which auteRests to fetch.
     */
    where?: auteRestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auteRests to fetch.
     */
    orderBy?: auteRestOrderByWithRelationInput | auteRestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auteRests.
     */
    cursor?: auteRestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auteRests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auteRests.
     */
    skip?: number
    distinct?: AuteRestScalarFieldEnum | AuteRestScalarFieldEnum[]
  }

  /**
   * auteRest create
   */
  export type auteRestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * The data needed to create a auteRest.
     */
    data: XOR<auteRestCreateInput, auteRestUncheckedCreateInput>
  }

  /**
   * auteRest createMany
   */
  export type auteRestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auteRests.
     */
    data: auteRestCreateManyInput | auteRestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auteRest createManyAndReturn
   */
  export type auteRestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * The data used to create many auteRests.
     */
    data: auteRestCreateManyInput | auteRestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auteRest update
   */
  export type auteRestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * The data needed to update a auteRest.
     */
    data: XOR<auteRestUpdateInput, auteRestUncheckedUpdateInput>
    /**
     * Choose, which auteRest to update.
     */
    where: auteRestWhereUniqueInput
  }

  /**
   * auteRest updateMany
   */
  export type auteRestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auteRests.
     */
    data: XOR<auteRestUpdateManyMutationInput, auteRestUncheckedUpdateManyInput>
    /**
     * Filter which auteRests to update
     */
    where?: auteRestWhereInput
    /**
     * Limit how many auteRests to update.
     */
    limit?: number
  }

  /**
   * auteRest updateManyAndReturn
   */
  export type auteRestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * The data used to update auteRests.
     */
    data: XOR<auteRestUpdateManyMutationInput, auteRestUncheckedUpdateManyInput>
    /**
     * Filter which auteRests to update
     */
    where?: auteRestWhereInput
    /**
     * Limit how many auteRests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auteRest upsert
   */
  export type auteRestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * The filter to search for the auteRest to update in case it exists.
     */
    where: auteRestWhereUniqueInput
    /**
     * In case the auteRest found by the `where` argument doesn't exist, create a new auteRest with this data.
     */
    create: XOR<auteRestCreateInput, auteRestUncheckedCreateInput>
    /**
     * In case the auteRest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auteRestUpdateInput, auteRestUncheckedUpdateInput>
  }

  /**
   * auteRest delete
   */
  export type auteRestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
    /**
     * Filter which auteRest to delete.
     */
    where: auteRestWhereUniqueInput
  }

  /**
   * auteRest deleteMany
   */
  export type auteRestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auteRests to delete
     */
    where?: auteRestWhereInput
    /**
     * Limit how many auteRests to delete.
     */
    limit?: number
  }

  /**
   * auteRest without action
   */
  export type auteRestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auteRest
     */
    select?: auteRestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auteRest
     */
    omit?: auteRestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auteRestInclude<ExtArgs> | null
  }


  /**
   * Model notificaciones
   */

  export type AggregateNotificaciones = {
    _count: NotificacionesCountAggregateOutputType | null
    _avg: NotificacionesAvgAggregateOutputType | null
    _sum: NotificacionesSumAggregateOutputType | null
    _min: NotificacionesMinAggregateOutputType | null
    _max: NotificacionesMaxAggregateOutputType | null
  }

  export type NotificacionesAvgAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
  }

  export type NotificacionesSumAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
  }

  export type NotificacionesMinAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    fechaEnvio: Date | null
    leida: boolean | null
  }

  export type NotificacionesMaxAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    fechaEnvio: Date | null
    leida: boolean | null
  }

  export type NotificacionesCountAggregateOutputType = {
    idNotificacion: number
    idUsuario: number
    tipo: number
    titulo: number
    mensaje: number
    fechaEnvio: number
    leida: number
    _all: number
  }


  export type NotificacionesAvgAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
  }

  export type NotificacionesSumAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
  }

  export type NotificacionesMinAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
  }

  export type NotificacionesMaxAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
  }

  export type NotificacionesCountAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
    _all?: true
  }

  export type NotificacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificaciones to aggregate.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notificaciones
    **/
    _count?: true | NotificacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionesMaxAggregateInputType
  }

  export type GetNotificacionesAggregateType<T extends NotificacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificaciones[P]>
      : GetScalarType<T[P], AggregateNotificaciones[P]>
  }




  export type notificacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificacionesWhereInput
    orderBy?: notificacionesOrderByWithAggregationInput | notificacionesOrderByWithAggregationInput[]
    by: NotificacionesScalarFieldEnum[] | NotificacionesScalarFieldEnum
    having?: notificacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionesCountAggregateInputType | true
    _avg?: NotificacionesAvgAggregateInputType
    _sum?: NotificacionesSumAggregateInputType
    _min?: NotificacionesMinAggregateInputType
    _max?: NotificacionesMaxAggregateInputType
  }

  export type NotificacionesGroupByOutputType = {
    idNotificacion: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date
    leida: boolean
    _count: NotificacionesCountAggregateOutputType | null
    _avg: NotificacionesAvgAggregateOutputType | null
    _sum: NotificacionesSumAggregateOutputType | null
    _min: NotificacionesMinAggregateOutputType | null
    _max: NotificacionesMaxAggregateOutputType | null
  }

  type GetNotificacionesGroupByPayload<T extends notificacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionesGroupByOutputType[P]>
        }
      >
    >


  export type notificacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectScalar = {
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
  }

  export type notificacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idNotificacion" | "idUsuario" | "tipo" | "titulo" | "mensaje" | "fechaEnvio" | "leida", ExtArgs["result"]["notificaciones"]>
  export type notificacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notificaciones"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idNotificacion: number
      idUsuario: number
      tipo: $Enums.TipoNotificacion
      titulo: string
      mensaje: string
      fechaEnvio: Date
      leida: boolean
    }, ExtArgs["result"]["notificaciones"]>
    composites: {}
  }

  type notificacionesGetPayload<S extends boolean | null | undefined | notificacionesDefaultArgs> = $Result.GetResult<Prisma.$notificacionesPayload, S>

  type notificacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionesCountAggregateInputType | true
    }

  export interface notificacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notificaciones'], meta: { name: 'notificaciones' } }
    /**
     * Find zero or one Notificaciones that matches the filter.
     * @param {notificacionesFindUniqueArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificacionesFindUniqueArgs>(args: SelectSubset<T, notificacionesFindUniqueArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificacionesFindUniqueOrThrowArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, notificacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindFirstArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificacionesFindFirstArgs>(args?: SelectSubset<T, notificacionesFindFirstArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindFirstOrThrowArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, notificacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificaciones
     * const notificaciones = await prisma.notificaciones.findMany()
     * 
     * // Get first 10 Notificaciones
     * const notificaciones = await prisma.notificaciones.findMany({ take: 10 })
     * 
     * // Only select the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.findMany({ select: { idNotificacion: true } })
     * 
     */
    findMany<T extends notificacionesFindManyArgs>(args?: SelectSubset<T, notificacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificaciones.
     * @param {notificacionesCreateArgs} args - Arguments to create a Notificaciones.
     * @example
     * // Create one Notificaciones
     * const Notificaciones = await prisma.notificaciones.create({
     *   data: {
     *     // ... data to create a Notificaciones
     *   }
     * })
     * 
     */
    create<T extends notificacionesCreateArgs>(args: SelectSubset<T, notificacionesCreateArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificaciones.
     * @param {notificacionesCreateManyArgs} args - Arguments to create many Notificaciones.
     * @example
     * // Create many Notificaciones
     * const notificaciones = await prisma.notificaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificacionesCreateManyArgs>(args?: SelectSubset<T, notificacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificaciones and returns the data saved in the database.
     * @param {notificacionesCreateManyAndReturnArgs} args - Arguments to create many Notificaciones.
     * @example
     * // Create many Notificaciones
     * const notificaciones = await prisma.notificaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificaciones and only return the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.createManyAndReturn({
     *   select: { idNotificacion: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, notificacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificaciones.
     * @param {notificacionesDeleteArgs} args - Arguments to delete one Notificaciones.
     * @example
     * // Delete one Notificaciones
     * const Notificaciones = await prisma.notificaciones.delete({
     *   where: {
     *     // ... filter to delete one Notificaciones
     *   }
     * })
     * 
     */
    delete<T extends notificacionesDeleteArgs>(args: SelectSubset<T, notificacionesDeleteArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificaciones.
     * @param {notificacionesUpdateArgs} args - Arguments to update one Notificaciones.
     * @example
     * // Update one Notificaciones
     * const notificaciones = await prisma.notificaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificacionesUpdateArgs>(args: SelectSubset<T, notificacionesUpdateArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificaciones.
     * @param {notificacionesDeleteManyArgs} args - Arguments to filter Notificaciones to delete.
     * @example
     * // Delete a few Notificaciones
     * const { count } = await prisma.notificaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificacionesDeleteManyArgs>(args?: SelectSubset<T, notificacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificaciones
     * const notificaciones = await prisma.notificaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificacionesUpdateManyArgs>(args: SelectSubset<T, notificacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificaciones and returns the data updated in the database.
     * @param {notificacionesUpdateManyAndReturnArgs} args - Arguments to update many Notificaciones.
     * @example
     * // Update many Notificaciones
     * const notificaciones = await prisma.notificaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificaciones and only return the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.updateManyAndReturn({
     *   select: { idNotificacion: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, notificacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificaciones.
     * @param {notificacionesUpsertArgs} args - Arguments to update or create a Notificaciones.
     * @example
     * // Update or create a Notificaciones
     * const notificaciones = await prisma.notificaciones.upsert({
     *   create: {
     *     // ... data to create a Notificaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificaciones we want to update
     *   }
     * })
     */
    upsert<T extends notificacionesUpsertArgs>(args: SelectSubset<T, notificacionesUpsertArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesCountArgs} args - Arguments to filter Notificaciones to count.
     * @example
     * // Count the number of Notificaciones
     * const count = await prisma.notificaciones.count({
     *   where: {
     *     // ... the filter for the Notificaciones we want to count
     *   }
     * })
    **/
    count<T extends notificacionesCountArgs>(
      args?: Subset<T, notificacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionesAggregateArgs>(args: Subset<T, NotificacionesAggregateArgs>): Prisma.PrismaPromise<GetNotificacionesAggregateType<T>>

    /**
     * Group by Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificacionesGroupByArgs['orderBy'] }
        : { orderBy?: notificacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notificaciones model
   */
  readonly fields: notificacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notificaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notificaciones model
   */
  interface notificacionesFieldRefs {
    readonly idNotificacion: FieldRef<"notificaciones", 'Int'>
    readonly idUsuario: FieldRef<"notificaciones", 'Int'>
    readonly tipo: FieldRef<"notificaciones", 'TipoNotificacion'>
    readonly titulo: FieldRef<"notificaciones", 'String'>
    readonly mensaje: FieldRef<"notificaciones", 'String'>
    readonly fechaEnvio: FieldRef<"notificaciones", 'DateTime'>
    readonly leida: FieldRef<"notificaciones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notificaciones findUnique
   */
  export type notificacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones findUniqueOrThrow
   */
  export type notificacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones findFirst
   */
  export type notificacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificaciones.
     */
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones findFirstOrThrow
   */
  export type notificacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificaciones.
     */
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones findMany
   */
  export type notificacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones create
   */
  export type notificacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a notificaciones.
     */
    data: XOR<notificacionesCreateInput, notificacionesUncheckedCreateInput>
  }

  /**
   * notificaciones createMany
   */
  export type notificacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notificaciones.
     */
    data: notificacionesCreateManyInput | notificacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notificaciones createManyAndReturn
   */
  export type notificacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * The data used to create many notificaciones.
     */
    data: notificacionesCreateManyInput | notificacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificaciones update
   */
  export type notificacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a notificaciones.
     */
    data: XOR<notificacionesUpdateInput, notificacionesUncheckedUpdateInput>
    /**
     * Choose, which notificaciones to update.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones updateMany
   */
  export type notificacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notificaciones.
     */
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyInput>
    /**
     * Filter which notificaciones to update
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to update.
     */
    limit?: number
  }

  /**
   * notificaciones updateManyAndReturn
   */
  export type notificacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * The data used to update notificaciones.
     */
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyInput>
    /**
     * Filter which notificaciones to update
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificaciones upsert
   */
  export type notificacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the notificaciones to update in case it exists.
     */
    where: notificacionesWhereUniqueInput
    /**
     * In case the notificaciones found by the `where` argument doesn't exist, create a new notificaciones with this data.
     */
    create: XOR<notificacionesCreateInput, notificacionesUncheckedCreateInput>
    /**
     * In case the notificaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificacionesUpdateInput, notificacionesUncheckedUpdateInput>
  }

  /**
   * notificaciones delete
   */
  export type notificacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter which notificaciones to delete.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones deleteMany
   */
  export type notificacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificaciones to delete
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to delete.
     */
    limit?: number
  }

  /**
   * notificaciones without action
   */
  export type notificacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
  }


  /**
   * Model productos
   */

  export type AggregateProductos = {
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  export type ProductosAvgAggregateOutputType = {
    id: number | null
    categoriaId: number | null
    cantidad: number | null
    precio: Decimal | null
    usuarioId: number | null
  }

  export type ProductosSumAggregateOutputType = {
    id: number | null
    categoriaId: number | null
    cantidad: number | null
    precio: Decimal | null
    usuarioId: number | null
  }

  export type ProductosMinAggregateOutputType = {
    id: number | null
    codigoBarras: string | null
    codigoQR: string | null
    nombre: string | null
    descripcion: string | null
    categoriaId: number | null
    cantidad: number | null
    precio: Decimal | null
    fechaAdquisicion: Date | null
    fechaVencimiento: Date | null
    usuarioId: number | null
    estado: string | null
    imagen: string | null
    createdAt: Date | null
    updatedAt: Date | null
    eliminadoEn: Date | null
  }

  export type ProductosMaxAggregateOutputType = {
    id: number | null
    codigoBarras: string | null
    codigoQR: string | null
    nombre: string | null
    descripcion: string | null
    categoriaId: number | null
    cantidad: number | null
    precio: Decimal | null
    fechaAdquisicion: Date | null
    fechaVencimiento: Date | null
    usuarioId: number | null
    estado: string | null
    imagen: string | null
    createdAt: Date | null
    updatedAt: Date | null
    eliminadoEn: Date | null
  }

  export type ProductosCountAggregateOutputType = {
    id: number
    codigoBarras: number
    codigoQR: number
    nombre: number
    descripcion: number
    categoriaId: number
    cantidad: number
    precio: number
    fechaAdquisicion: number
    fechaVencimiento: number
    usuarioId: number
    estado: number
    imagen: number
    createdAt: number
    updatedAt: number
    eliminadoEn: number
    _all: number
  }


  export type ProductosAvgAggregateInputType = {
    id?: true
    categoriaId?: true
    cantidad?: true
    precio?: true
    usuarioId?: true
  }

  export type ProductosSumAggregateInputType = {
    id?: true
    categoriaId?: true
    cantidad?: true
    precio?: true
    usuarioId?: true
  }

  export type ProductosMinAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    categoriaId?: true
    cantidad?: true
    precio?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
  }

  export type ProductosMaxAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    categoriaId?: true
    cantidad?: true
    precio?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
  }

  export type ProductosCountAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    categoriaId?: true
    cantidad?: true
    precio?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
    _all?: true
  }

  export type ProductosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos to aggregate.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productos
    **/
    _count?: true | ProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductosMaxAggregateInputType
  }

  export type GetProductosAggregateType<T extends ProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos[P]>
      : GetScalarType<T[P], AggregateProductos[P]>
  }




  export type productosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productosWhereInput
    orderBy?: productosOrderByWithAggregationInput | productosOrderByWithAggregationInput[]
    by: ProductosScalarFieldEnum[] | ProductosScalarFieldEnum
    having?: productosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductosCountAggregateInputType | true
    _avg?: ProductosAvgAggregateInputType
    _sum?: ProductosSumAggregateInputType
    _min?: ProductosMinAggregateInputType
    _max?: ProductosMaxAggregateInputType
  }

  export type ProductosGroupByOutputType = {
    id: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal
    fechaAdquisicion: Date
    fechaVencimiento: Date
    usuarioId: number
    estado: string
    imagen: string
    createdAt: Date
    updatedAt: Date
    eliminadoEn: Date | null
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  type GetProductosGroupByPayload<T extends productosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductosGroupByOutputType[P]>
            : GetScalarType<T[P], ProductosGroupByOutputType[P]>
        }
      >
    >


  export type productosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoriaId?: boolean
    cantidad?: boolean
    precio?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    ajustInven?: boolean | productos$ajustInvenArgs<ExtArgs>
    alertVen?: boolean | productos$alertVenArgs<ExtArgs>
    colaboraciones?: boolean | productos$colaboracionesArgs<ExtArgs>
    histInv?: boolean | productos$histInvArgs<ExtArgs>
    histoVenta?: boolean | productos$histoVentaArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
    recorStock?: boolean | productos$recorStockArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoriaId?: boolean
    cantidad?: boolean
    precio?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoriaId?: boolean
    cantidad?: boolean
    precio?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectScalar = {
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    categoriaId?: boolean
    cantidad?: boolean
    precio?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
  }

  export type productosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigoBarras" | "codigoQR" | "nombre" | "descripcion" | "categoriaId" | "cantidad" | "precio" | "fechaAdquisicion" | "fechaVencimiento" | "usuarioId" | "estado" | "imagen" | "createdAt" | "updatedAt" | "eliminadoEn", ExtArgs["result"]["productos"]>
  export type productosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ajustInven?: boolean | productos$ajustInvenArgs<ExtArgs>
    alertVen?: boolean | productos$alertVenArgs<ExtArgs>
    colaboraciones?: boolean | productos$colaboracionesArgs<ExtArgs>
    histInv?: boolean | productos$histInvArgs<ExtArgs>
    histoVenta?: boolean | productos$histoVentaArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
    recorStock?: boolean | productos$recorStockArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type productosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $productosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productos"
    objects: {
      ajustInven: Prisma.$ajustInvenPayload<ExtArgs>[]
      alertVen: Prisma.$alertVenPayload<ExtArgs>[]
      colaboraciones: Prisma.$colaboracionesPayload<ExtArgs>[]
      histInv: Prisma.$histInvPayload<ExtArgs>[]
      histoVenta: Prisma.$histoVentaPayload<ExtArgs>[]
      usuario: Prisma.$usersPayload<ExtArgs>
      recorStock: Prisma.$recorStockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoBarras: string
      codigoQR: string
      nombre: string
      descripcion: string
      categoriaId: number
      cantidad: number
      precio: Prisma.Decimal
      fechaAdquisicion: Date
      fechaVencimiento: Date
      usuarioId: number
      estado: string
      imagen: string
      createdAt: Date
      updatedAt: Date
      eliminadoEn: Date | null
    }, ExtArgs["result"]["productos"]>
    composites: {}
  }

  type productosGetPayload<S extends boolean | null | undefined | productosDefaultArgs> = $Result.GetResult<Prisma.$productosPayload, S>

  type productosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductosCountAggregateInputType | true
    }

  export interface productosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productos'], meta: { name: 'productos' } }
    /**
     * Find zero or one Productos that matches the filter.
     * @param {productosFindUniqueArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productosFindUniqueArgs>(args: SelectSubset<T, productosFindUniqueArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Productos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productosFindUniqueOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productosFindUniqueOrThrowArgs>(args: SelectSubset<T, productosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindFirstArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productosFindFirstArgs>(args?: SelectSubset<T, productosFindFirstArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindFirstOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productosFindFirstOrThrowArgs>(args?: SelectSubset<T, productosFindFirstOrThrowArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.productos.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.productos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productosWithIdOnly = await prisma.productos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productosFindManyArgs>(args?: SelectSubset<T, productosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Productos.
     * @param {productosCreateArgs} args - Arguments to create a Productos.
     * @example
     * // Create one Productos
     * const Productos = await prisma.productos.create({
     *   data: {
     *     // ... data to create a Productos
     *   }
     * })
     * 
     */
    create<T extends productosCreateArgs>(args: SelectSubset<T, productosCreateArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productos.
     * @param {productosCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const productos = await prisma.productos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productosCreateManyArgs>(args?: SelectSubset<T, productosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos and returns the data saved in the database.
     * @param {productosCreateManyAndReturnArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const productos = await prisma.productos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos and only return the `id`
     * const productosWithIdOnly = await prisma.productos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productosCreateManyAndReturnArgs>(args?: SelectSubset<T, productosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Productos.
     * @param {productosDeleteArgs} args - Arguments to delete one Productos.
     * @example
     * // Delete one Productos
     * const Productos = await prisma.productos.delete({
     *   where: {
     *     // ... filter to delete one Productos
     *   }
     * })
     * 
     */
    delete<T extends productosDeleteArgs>(args: SelectSubset<T, productosDeleteArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Productos.
     * @param {productosUpdateArgs} args - Arguments to update one Productos.
     * @example
     * // Update one Productos
     * const productos = await prisma.productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productosUpdateArgs>(args: SelectSubset<T, productosUpdateArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productos.
     * @param {productosDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productosDeleteManyArgs>(args?: SelectSubset<T, productosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productosUpdateManyArgs>(args: SelectSubset<T, productosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos and returns the data updated in the database.
     * @param {productosUpdateManyAndReturnArgs} args - Arguments to update many Productos.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productos and only return the `id`
     * const productosWithIdOnly = await prisma.productos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productosUpdateManyAndReturnArgs>(args: SelectSubset<T, productosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Productos.
     * @param {productosUpsertArgs} args - Arguments to update or create a Productos.
     * @example
     * // Update or create a Productos
     * const productos = await prisma.productos.upsert({
     *   create: {
     *     // ... data to create a Productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos we want to update
     *   }
     * })
     */
    upsert<T extends productosUpsertArgs>(args: SelectSubset<T, productosUpsertArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.productos.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends productosCountArgs>(
      args?: Subset<T, productosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductosAggregateArgs>(args: Subset<T, ProductosAggregateArgs>): Prisma.PrismaPromise<GetProductosAggregateType<T>>

    /**
     * Group by Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productosGroupByArgs['orderBy'] }
        : { orderBy?: productosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productos model
   */
  readonly fields: productosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ajustInven<T extends productos$ajustInvenArgs<ExtArgs> = {}>(args?: Subset<T, productos$ajustInvenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alertVen<T extends productos$alertVenArgs<ExtArgs> = {}>(args?: Subset<T, productos$alertVenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colaboraciones<T extends productos$colaboracionesArgs<ExtArgs> = {}>(args?: Subset<T, productos$colaboracionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histInv<T extends productos$histInvArgs<ExtArgs> = {}>(args?: Subset<T, productos$histInvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histoVenta<T extends productos$histoVentaArgs<ExtArgs> = {}>(args?: Subset<T, productos$histoVentaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recorStock<T extends productos$recorStockArgs<ExtArgs> = {}>(args?: Subset<T, productos$recorStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productos model
   */
  interface productosFieldRefs {
    readonly id: FieldRef<"productos", 'Int'>
    readonly codigoBarras: FieldRef<"productos", 'String'>
    readonly codigoQR: FieldRef<"productos", 'String'>
    readonly nombre: FieldRef<"productos", 'String'>
    readonly descripcion: FieldRef<"productos", 'String'>
    readonly categoriaId: FieldRef<"productos", 'Int'>
    readonly cantidad: FieldRef<"productos", 'Int'>
    readonly precio: FieldRef<"productos", 'Decimal'>
    readonly fechaAdquisicion: FieldRef<"productos", 'DateTime'>
    readonly fechaVencimiento: FieldRef<"productos", 'DateTime'>
    readonly usuarioId: FieldRef<"productos", 'Int'>
    readonly estado: FieldRef<"productos", 'String'>
    readonly imagen: FieldRef<"productos", 'String'>
    readonly createdAt: FieldRef<"productos", 'DateTime'>
    readonly updatedAt: FieldRef<"productos", 'DateTime'>
    readonly eliminadoEn: FieldRef<"productos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * productos findUnique
   */
  export type productosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos findUniqueOrThrow
   */
  export type productosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos findFirst
   */
  export type productosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos findFirstOrThrow
   */
  export type productosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos findMany
   */
  export type productosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos create
   */
  export type productosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The data needed to create a productos.
     */
    data: XOR<productosCreateInput, productosUncheckedCreateInput>
  }

  /**
   * productos createMany
   */
  export type productosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productos.
     */
    data: productosCreateManyInput | productosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productos createManyAndReturn
   */
  export type productosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * The data used to create many productos.
     */
    data: productosCreateManyInput | productosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos update
   */
  export type productosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The data needed to update a productos.
     */
    data: XOR<productosUpdateInput, productosUncheckedUpdateInput>
    /**
     * Choose, which productos to update.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos updateMany
   */
  export type productosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productos.
     */
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyInput>
    /**
     * Filter which productos to update
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to update.
     */
    limit?: number
  }

  /**
   * productos updateManyAndReturn
   */
  export type productosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * The data used to update productos.
     */
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyInput>
    /**
     * Filter which productos to update
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos upsert
   */
  export type productosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The filter to search for the productos to update in case it exists.
     */
    where: productosWhereUniqueInput
    /**
     * In case the productos found by the `where` argument doesn't exist, create a new productos with this data.
     */
    create: XOR<productosCreateInput, productosUncheckedCreateInput>
    /**
     * In case the productos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productosUpdateInput, productosUncheckedUpdateInput>
  }

  /**
   * productos delete
   */
  export type productosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter which productos to delete.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos deleteMany
   */
  export type productosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos to delete
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to delete.
     */
    limit?: number
  }

  /**
   * productos.ajustInven
   */
  export type productos$ajustInvenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    where?: ajustInvenWhereInput
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    cursor?: ajustInvenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AjustInvenScalarFieldEnum | AjustInvenScalarFieldEnum[]
  }

  /**
   * productos.alertVen
   */
  export type productos$alertVenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    where?: alertVenWhereInput
    orderBy?: alertVenOrderByWithRelationInput | alertVenOrderByWithRelationInput[]
    cursor?: alertVenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertVenScalarFieldEnum | AlertVenScalarFieldEnum[]
  }

  /**
   * productos.colaboraciones
   */
  export type productos$colaboracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    where?: colaboracionesWhereInput
    orderBy?: colaboracionesOrderByWithRelationInput | colaboracionesOrderByWithRelationInput[]
    cursor?: colaboracionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColaboracionesScalarFieldEnum | ColaboracionesScalarFieldEnum[]
  }

  /**
   * productos.histInv
   */
  export type productos$histInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    cursor?: histInvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * productos.histoVenta
   */
  export type productos$histoVentaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    where?: histoVentaWhereInput
    orderBy?: histoVentaOrderByWithRelationInput | histoVentaOrderByWithRelationInput[]
    cursor?: histoVentaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoVentaScalarFieldEnum | HistoVentaScalarFieldEnum[]
  }

  /**
   * productos.recorStock
   */
  export type productos$recorStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    where?: recorStockWhereInput
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    cursor?: recorStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * productos without action
   */
  export type productosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
  }


  /**
   * Model histoVenta
   */

  export type AggregateHistoVenta = {
    _count: HistoVentaCountAggregateOutputType | null
    _avg: HistoVentaAvgAggregateOutputType | null
    _sum: HistoVentaSumAggregateOutputType | null
    _min: HistoVentaMinAggregateOutputType | null
    _max: HistoVentaMaxAggregateOutputType | null
  }

  export type HistoVentaAvgAggregateOutputType = {
    idVenta: number | null
    idProducto: number | null
    cantidadVendida: number | null
  }

  export type HistoVentaSumAggregateOutputType = {
    idVenta: number | null
    idProducto: number | null
    cantidadVendida: number | null
  }

  export type HistoVentaMinAggregateOutputType = {
    idVenta: number | null
    idProducto: number | null
    cantidadVendida: number | null
    fechaVenta: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoVentaMaxAggregateOutputType = {
    idVenta: number | null
    idProducto: number | null
    cantidadVendida: number | null
    fechaVenta: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoVentaCountAggregateOutputType = {
    idVenta: number
    idProducto: number
    cantidadVendida: number
    fechaVenta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HistoVentaAvgAggregateInputType = {
    idVenta?: true
    idProducto?: true
    cantidadVendida?: true
  }

  export type HistoVentaSumAggregateInputType = {
    idVenta?: true
    idProducto?: true
    cantidadVendida?: true
  }

  export type HistoVentaMinAggregateInputType = {
    idVenta?: true
    idProducto?: true
    cantidadVendida?: true
    fechaVenta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoVentaMaxAggregateInputType = {
    idVenta?: true
    idProducto?: true
    cantidadVendida?: true
    fechaVenta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoVentaCountAggregateInputType = {
    idVenta?: true
    idProducto?: true
    cantidadVendida?: true
    fechaVenta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HistoVentaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histoVenta to aggregate.
     */
    where?: histoVentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histoVentas to fetch.
     */
    orderBy?: histoVentaOrderByWithRelationInput | histoVentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: histoVentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histoVentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histoVentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned histoVentas
    **/
    _count?: true | HistoVentaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoVentaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoVentaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoVentaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoVentaMaxAggregateInputType
  }

  export type GetHistoVentaAggregateType<T extends HistoVentaAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoVenta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoVenta[P]>
      : GetScalarType<T[P], AggregateHistoVenta[P]>
  }




  export type histoVentaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histoVentaWhereInput
    orderBy?: histoVentaOrderByWithAggregationInput | histoVentaOrderByWithAggregationInput[]
    by: HistoVentaScalarFieldEnum[] | HistoVentaScalarFieldEnum
    having?: histoVentaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoVentaCountAggregateInputType | true
    _avg?: HistoVentaAvgAggregateInputType
    _sum?: HistoVentaSumAggregateInputType
    _min?: HistoVentaMinAggregateInputType
    _max?: HistoVentaMaxAggregateInputType
  }

  export type HistoVentaGroupByOutputType = {
    idVenta: number
    idProducto: number
    cantidadVendida: number
    fechaVenta: Date
    createdAt: Date
    updatedAt: Date
    _count: HistoVentaCountAggregateOutputType | null
    _avg: HistoVentaAvgAggregateOutputType | null
    _sum: HistoVentaSumAggregateOutputType | null
    _min: HistoVentaMinAggregateOutputType | null
    _max: HistoVentaMaxAggregateOutputType | null
  }

  type GetHistoVentaGroupByPayload<T extends histoVentaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoVentaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoVentaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoVentaGroupByOutputType[P]>
            : GetScalarType<T[P], HistoVentaGroupByOutputType[P]>
        }
      >
    >


  export type histoVentaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idVenta?: boolean
    idProducto?: boolean
    cantidadVendida?: boolean
    fechaVenta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histoVenta"]>

  export type histoVentaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idVenta?: boolean
    idProducto?: boolean
    cantidadVendida?: boolean
    fechaVenta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histoVenta"]>

  export type histoVentaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idVenta?: boolean
    idProducto?: boolean
    cantidadVendida?: boolean
    fechaVenta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histoVenta"]>

  export type histoVentaSelectScalar = {
    idVenta?: boolean
    idProducto?: boolean
    cantidadVendida?: boolean
    fechaVenta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type histoVentaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idVenta" | "idProducto" | "cantidadVendida" | "fechaVenta" | "createdAt" | "updatedAt", ExtArgs["result"]["histoVenta"]>
  export type histoVentaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type histoVentaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type histoVentaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $histoVentaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "histoVenta"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idVenta: number
      idProducto: number
      cantidadVendida: number
      fechaVenta: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["histoVenta"]>
    composites: {}
  }

  type histoVentaGetPayload<S extends boolean | null | undefined | histoVentaDefaultArgs> = $Result.GetResult<Prisma.$histoVentaPayload, S>

  type histoVentaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<histoVentaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoVentaCountAggregateInputType | true
    }

  export interface histoVentaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['histoVenta'], meta: { name: 'histoVenta' } }
    /**
     * Find zero or one HistoVenta that matches the filter.
     * @param {histoVentaFindUniqueArgs} args - Arguments to find a HistoVenta
     * @example
     * // Get one HistoVenta
     * const histoVenta = await prisma.histoVenta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends histoVentaFindUniqueArgs>(args: SelectSubset<T, histoVentaFindUniqueArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistoVenta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {histoVentaFindUniqueOrThrowArgs} args - Arguments to find a HistoVenta
     * @example
     * // Get one HistoVenta
     * const histoVenta = await prisma.histoVenta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends histoVentaFindUniqueOrThrowArgs>(args: SelectSubset<T, histoVentaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoVenta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaFindFirstArgs} args - Arguments to find a HistoVenta
     * @example
     * // Get one HistoVenta
     * const histoVenta = await prisma.histoVenta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends histoVentaFindFirstArgs>(args?: SelectSubset<T, histoVentaFindFirstArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoVenta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaFindFirstOrThrowArgs} args - Arguments to find a HistoVenta
     * @example
     * // Get one HistoVenta
     * const histoVenta = await prisma.histoVenta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends histoVentaFindFirstOrThrowArgs>(args?: SelectSubset<T, histoVentaFindFirstOrThrowArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistoVentas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoVentas
     * const histoVentas = await prisma.histoVenta.findMany()
     * 
     * // Get first 10 HistoVentas
     * const histoVentas = await prisma.histoVenta.findMany({ take: 10 })
     * 
     * // Only select the `idVenta`
     * const histoVentaWithIdVentaOnly = await prisma.histoVenta.findMany({ select: { idVenta: true } })
     * 
     */
    findMany<T extends histoVentaFindManyArgs>(args?: SelectSubset<T, histoVentaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistoVenta.
     * @param {histoVentaCreateArgs} args - Arguments to create a HistoVenta.
     * @example
     * // Create one HistoVenta
     * const HistoVenta = await prisma.histoVenta.create({
     *   data: {
     *     // ... data to create a HistoVenta
     *   }
     * })
     * 
     */
    create<T extends histoVentaCreateArgs>(args: SelectSubset<T, histoVentaCreateArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistoVentas.
     * @param {histoVentaCreateManyArgs} args - Arguments to create many HistoVentas.
     * @example
     * // Create many HistoVentas
     * const histoVenta = await prisma.histoVenta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends histoVentaCreateManyArgs>(args?: SelectSubset<T, histoVentaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistoVentas and returns the data saved in the database.
     * @param {histoVentaCreateManyAndReturnArgs} args - Arguments to create many HistoVentas.
     * @example
     * // Create many HistoVentas
     * const histoVenta = await prisma.histoVenta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistoVentas and only return the `idVenta`
     * const histoVentaWithIdVentaOnly = await prisma.histoVenta.createManyAndReturn({
     *   select: { idVenta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends histoVentaCreateManyAndReturnArgs>(args?: SelectSubset<T, histoVentaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistoVenta.
     * @param {histoVentaDeleteArgs} args - Arguments to delete one HistoVenta.
     * @example
     * // Delete one HistoVenta
     * const HistoVenta = await prisma.histoVenta.delete({
     *   where: {
     *     // ... filter to delete one HistoVenta
     *   }
     * })
     * 
     */
    delete<T extends histoVentaDeleteArgs>(args: SelectSubset<T, histoVentaDeleteArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistoVenta.
     * @param {histoVentaUpdateArgs} args - Arguments to update one HistoVenta.
     * @example
     * // Update one HistoVenta
     * const histoVenta = await prisma.histoVenta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends histoVentaUpdateArgs>(args: SelectSubset<T, histoVentaUpdateArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistoVentas.
     * @param {histoVentaDeleteManyArgs} args - Arguments to filter HistoVentas to delete.
     * @example
     * // Delete a few HistoVentas
     * const { count } = await prisma.histoVenta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends histoVentaDeleteManyArgs>(args?: SelectSubset<T, histoVentaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoVentas
     * const histoVenta = await prisma.histoVenta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends histoVentaUpdateManyArgs>(args: SelectSubset<T, histoVentaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoVentas and returns the data updated in the database.
     * @param {histoVentaUpdateManyAndReturnArgs} args - Arguments to update many HistoVentas.
     * @example
     * // Update many HistoVentas
     * const histoVenta = await prisma.histoVenta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistoVentas and only return the `idVenta`
     * const histoVentaWithIdVentaOnly = await prisma.histoVenta.updateManyAndReturn({
     *   select: { idVenta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends histoVentaUpdateManyAndReturnArgs>(args: SelectSubset<T, histoVentaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistoVenta.
     * @param {histoVentaUpsertArgs} args - Arguments to update or create a HistoVenta.
     * @example
     * // Update or create a HistoVenta
     * const histoVenta = await prisma.histoVenta.upsert({
     *   create: {
     *     // ... data to create a HistoVenta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoVenta we want to update
     *   }
     * })
     */
    upsert<T extends histoVentaUpsertArgs>(args: SelectSubset<T, histoVentaUpsertArgs<ExtArgs>>): Prisma__histoVentaClient<$Result.GetResult<Prisma.$histoVentaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistoVentas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaCountArgs} args - Arguments to filter HistoVentas to count.
     * @example
     * // Count the number of HistoVentas
     * const count = await prisma.histoVenta.count({
     *   where: {
     *     // ... the filter for the HistoVentas we want to count
     *   }
     * })
    **/
    count<T extends histoVentaCountArgs>(
      args?: Subset<T, histoVentaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoVentaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoVenta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoVentaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoVentaAggregateArgs>(args: Subset<T, HistoVentaAggregateArgs>): Prisma.PrismaPromise<GetHistoVentaAggregateType<T>>

    /**
     * Group by HistoVenta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histoVentaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends histoVentaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: histoVentaGroupByArgs['orderBy'] }
        : { orderBy?: histoVentaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, histoVentaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoVentaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the histoVenta model
   */
  readonly fields: histoVentaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for histoVenta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__histoVentaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the histoVenta model
   */
  interface histoVentaFieldRefs {
    readonly idVenta: FieldRef<"histoVenta", 'Int'>
    readonly idProducto: FieldRef<"histoVenta", 'Int'>
    readonly cantidadVendida: FieldRef<"histoVenta", 'Int'>
    readonly fechaVenta: FieldRef<"histoVenta", 'DateTime'>
    readonly createdAt: FieldRef<"histoVenta", 'DateTime'>
    readonly updatedAt: FieldRef<"histoVenta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * histoVenta findUnique
   */
  export type histoVentaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter, which histoVenta to fetch.
     */
    where: histoVentaWhereUniqueInput
  }

  /**
   * histoVenta findUniqueOrThrow
   */
  export type histoVentaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter, which histoVenta to fetch.
     */
    where: histoVentaWhereUniqueInput
  }

  /**
   * histoVenta findFirst
   */
  export type histoVentaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter, which histoVenta to fetch.
     */
    where?: histoVentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histoVentas to fetch.
     */
    orderBy?: histoVentaOrderByWithRelationInput | histoVentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histoVentas.
     */
    cursor?: histoVentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histoVentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histoVentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histoVentas.
     */
    distinct?: HistoVentaScalarFieldEnum | HistoVentaScalarFieldEnum[]
  }

  /**
   * histoVenta findFirstOrThrow
   */
  export type histoVentaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter, which histoVenta to fetch.
     */
    where?: histoVentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histoVentas to fetch.
     */
    orderBy?: histoVentaOrderByWithRelationInput | histoVentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histoVentas.
     */
    cursor?: histoVentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histoVentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histoVentas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histoVentas.
     */
    distinct?: HistoVentaScalarFieldEnum | HistoVentaScalarFieldEnum[]
  }

  /**
   * histoVenta findMany
   */
  export type histoVentaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter, which histoVentas to fetch.
     */
    where?: histoVentaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histoVentas to fetch.
     */
    orderBy?: histoVentaOrderByWithRelationInput | histoVentaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing histoVentas.
     */
    cursor?: histoVentaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histoVentas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histoVentas.
     */
    skip?: number
    distinct?: HistoVentaScalarFieldEnum | HistoVentaScalarFieldEnum[]
  }

  /**
   * histoVenta create
   */
  export type histoVentaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * The data needed to create a histoVenta.
     */
    data: XOR<histoVentaCreateInput, histoVentaUncheckedCreateInput>
  }

  /**
   * histoVenta createMany
   */
  export type histoVentaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many histoVentas.
     */
    data: histoVentaCreateManyInput | histoVentaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * histoVenta createManyAndReturn
   */
  export type histoVentaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * The data used to create many histoVentas.
     */
    data: histoVentaCreateManyInput | histoVentaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * histoVenta update
   */
  export type histoVentaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * The data needed to update a histoVenta.
     */
    data: XOR<histoVentaUpdateInput, histoVentaUncheckedUpdateInput>
    /**
     * Choose, which histoVenta to update.
     */
    where: histoVentaWhereUniqueInput
  }

  /**
   * histoVenta updateMany
   */
  export type histoVentaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update histoVentas.
     */
    data: XOR<histoVentaUpdateManyMutationInput, histoVentaUncheckedUpdateManyInput>
    /**
     * Filter which histoVentas to update
     */
    where?: histoVentaWhereInput
    /**
     * Limit how many histoVentas to update.
     */
    limit?: number
  }

  /**
   * histoVenta updateManyAndReturn
   */
  export type histoVentaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * The data used to update histoVentas.
     */
    data: XOR<histoVentaUpdateManyMutationInput, histoVentaUncheckedUpdateManyInput>
    /**
     * Filter which histoVentas to update
     */
    where?: histoVentaWhereInput
    /**
     * Limit how many histoVentas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * histoVenta upsert
   */
  export type histoVentaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * The filter to search for the histoVenta to update in case it exists.
     */
    where: histoVentaWhereUniqueInput
    /**
     * In case the histoVenta found by the `where` argument doesn't exist, create a new histoVenta with this data.
     */
    create: XOR<histoVentaCreateInput, histoVentaUncheckedCreateInput>
    /**
     * In case the histoVenta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<histoVentaUpdateInput, histoVentaUncheckedUpdateInput>
  }

  /**
   * histoVenta delete
   */
  export type histoVentaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
    /**
     * Filter which histoVenta to delete.
     */
    where: histoVentaWhereUniqueInput
  }

  /**
   * histoVenta deleteMany
   */
  export type histoVentaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histoVentas to delete
     */
    where?: histoVentaWhereInput
    /**
     * Limit how many histoVentas to delete.
     */
    limit?: number
  }

  /**
   * histoVenta without action
   */
  export type histoVentaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histoVenta
     */
    select?: histoVentaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histoVenta
     */
    omit?: histoVentaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histoVentaInclude<ExtArgs> | null
  }


  /**
   * Model recorStock
   */

  export type AggregateRecorStock = {
    _count: RecorStockCountAggregateOutputType | null
    _avg: RecorStockAvgAggregateOutputType | null
    _sum: RecorStockSumAggregateOutputType | null
    _min: RecorStockMinAggregateOutputType | null
    _max: RecorStockMaxAggregateOutputType | null
  }

  export type RecorStockAvgAggregateOutputType = {
    idRecordatorio: number | null
    idProducto: number | null
    cantidadMinima: number | null
  }

  export type RecorStockSumAggregateOutputType = {
    idRecordatorio: number | null
    idProducto: number | null
    cantidadMinima: number | null
  }

  export type RecorStockMinAggregateOutputType = {
    idRecordatorio: number | null
    idProducto: number | null
    cantidadMinima: number | null
    fechaRecordatorio: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecorStockMaxAggregateOutputType = {
    idRecordatorio: number | null
    idProducto: number | null
    cantidadMinima: number | null
    fechaRecordatorio: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecorStockCountAggregateOutputType = {
    idRecordatorio: number
    idProducto: number
    cantidadMinima: number
    fechaRecordatorio: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecorStockAvgAggregateInputType = {
    idRecordatorio?: true
    idProducto?: true
    cantidadMinima?: true
  }

  export type RecorStockSumAggregateInputType = {
    idRecordatorio?: true
    idProducto?: true
    cantidadMinima?: true
  }

  export type RecorStockMinAggregateInputType = {
    idRecordatorio?: true
    idProducto?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecorStockMaxAggregateInputType = {
    idRecordatorio?: true
    idProducto?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecorStockCountAggregateInputType = {
    idRecordatorio?: true
    idProducto?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecorStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recorStock to aggregate.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recorStocks
    **/
    _count?: true | RecorStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecorStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecorStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecorStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecorStockMaxAggregateInputType
  }

  export type GetRecorStockAggregateType<T extends RecorStockAggregateArgs> = {
        [P in keyof T & keyof AggregateRecorStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecorStock[P]>
      : GetScalarType<T[P], AggregateRecorStock[P]>
  }




  export type recorStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recorStockWhereInput
    orderBy?: recorStockOrderByWithAggregationInput | recorStockOrderByWithAggregationInput[]
    by: RecorStockScalarFieldEnum[] | RecorStockScalarFieldEnum
    having?: recorStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecorStockCountAggregateInputType | true
    _avg?: RecorStockAvgAggregateInputType
    _sum?: RecorStockSumAggregateInputType
    _min?: RecorStockMinAggregateInputType
    _max?: RecorStockMaxAggregateInputType
  }

  export type RecorStockGroupByOutputType = {
    idRecordatorio: number
    idProducto: number
    cantidadMinima: number
    fechaRecordatorio: Date
    estado: $Enums.EstadoRecordatorio
    createdAt: Date
    updatedAt: Date
    _count: RecorStockCountAggregateOutputType | null
    _avg: RecorStockAvgAggregateOutputType | null
    _sum: RecorStockSumAggregateOutputType | null
    _min: RecorStockMinAggregateOutputType | null
    _max: RecorStockMaxAggregateOutputType | null
  }

  type GetRecorStockGroupByPayload<T extends recorStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecorStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecorStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecorStockGroupByOutputType[P]>
            : GetScalarType<T[P], RecorStockGroupByOutputType[P]>
        }
      >
    >


  export type recorStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    idProducto?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    idProducto?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    idProducto?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectScalar = {
    idRecordatorio?: boolean
    idProducto?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type recorStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idRecordatorio" | "idProducto" | "cantidadMinima" | "fechaRecordatorio" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["recorStock"]>
  export type recorStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type recorStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type recorStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $recorStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recorStock"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idRecordatorio: number
      idProducto: number
      cantidadMinima: number
      fechaRecordatorio: Date
      estado: $Enums.EstadoRecordatorio
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recorStock"]>
    composites: {}
  }

  type recorStockGetPayload<S extends boolean | null | undefined | recorStockDefaultArgs> = $Result.GetResult<Prisma.$recorStockPayload, S>

  type recorStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recorStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecorStockCountAggregateInputType | true
    }

  export interface recorStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recorStock'], meta: { name: 'recorStock' } }
    /**
     * Find zero or one RecorStock that matches the filter.
     * @param {recorStockFindUniqueArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recorStockFindUniqueArgs>(args: SelectSubset<T, recorStockFindUniqueArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecorStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recorStockFindUniqueOrThrowArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recorStockFindUniqueOrThrowArgs>(args: SelectSubset<T, recorStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecorStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindFirstArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recorStockFindFirstArgs>(args?: SelectSubset<T, recorStockFindFirstArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecorStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindFirstOrThrowArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recorStockFindFirstOrThrowArgs>(args?: SelectSubset<T, recorStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecorStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecorStocks
     * const recorStocks = await prisma.recorStock.findMany()
     * 
     * // Get first 10 RecorStocks
     * const recorStocks = await prisma.recorStock.findMany({ take: 10 })
     * 
     * // Only select the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.findMany({ select: { idRecordatorio: true } })
     * 
     */
    findMany<T extends recorStockFindManyArgs>(args?: SelectSubset<T, recorStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecorStock.
     * @param {recorStockCreateArgs} args - Arguments to create a RecorStock.
     * @example
     * // Create one RecorStock
     * const RecorStock = await prisma.recorStock.create({
     *   data: {
     *     // ... data to create a RecorStock
     *   }
     * })
     * 
     */
    create<T extends recorStockCreateArgs>(args: SelectSubset<T, recorStockCreateArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecorStocks.
     * @param {recorStockCreateManyArgs} args - Arguments to create many RecorStocks.
     * @example
     * // Create many RecorStocks
     * const recorStock = await prisma.recorStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recorStockCreateManyArgs>(args?: SelectSubset<T, recorStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecorStocks and returns the data saved in the database.
     * @param {recorStockCreateManyAndReturnArgs} args - Arguments to create many RecorStocks.
     * @example
     * // Create many RecorStocks
     * const recorStock = await prisma.recorStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecorStocks and only return the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.createManyAndReturn({
     *   select: { idRecordatorio: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recorStockCreateManyAndReturnArgs>(args?: SelectSubset<T, recorStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecorStock.
     * @param {recorStockDeleteArgs} args - Arguments to delete one RecorStock.
     * @example
     * // Delete one RecorStock
     * const RecorStock = await prisma.recorStock.delete({
     *   where: {
     *     // ... filter to delete one RecorStock
     *   }
     * })
     * 
     */
    delete<T extends recorStockDeleteArgs>(args: SelectSubset<T, recorStockDeleteArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecorStock.
     * @param {recorStockUpdateArgs} args - Arguments to update one RecorStock.
     * @example
     * // Update one RecorStock
     * const recorStock = await prisma.recorStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recorStockUpdateArgs>(args: SelectSubset<T, recorStockUpdateArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecorStocks.
     * @param {recorStockDeleteManyArgs} args - Arguments to filter RecorStocks to delete.
     * @example
     * // Delete a few RecorStocks
     * const { count } = await prisma.recorStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recorStockDeleteManyArgs>(args?: SelectSubset<T, recorStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecorStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecorStocks
     * const recorStock = await prisma.recorStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recorStockUpdateManyArgs>(args: SelectSubset<T, recorStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecorStocks and returns the data updated in the database.
     * @param {recorStockUpdateManyAndReturnArgs} args - Arguments to update many RecorStocks.
     * @example
     * // Update many RecorStocks
     * const recorStock = await prisma.recorStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecorStocks and only return the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.updateManyAndReturn({
     *   select: { idRecordatorio: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recorStockUpdateManyAndReturnArgs>(args: SelectSubset<T, recorStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecorStock.
     * @param {recorStockUpsertArgs} args - Arguments to update or create a RecorStock.
     * @example
     * // Update or create a RecorStock
     * const recorStock = await prisma.recorStock.upsert({
     *   create: {
     *     // ... data to create a RecorStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecorStock we want to update
     *   }
     * })
     */
    upsert<T extends recorStockUpsertArgs>(args: SelectSubset<T, recorStockUpsertArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecorStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockCountArgs} args - Arguments to filter RecorStocks to count.
     * @example
     * // Count the number of RecorStocks
     * const count = await prisma.recorStock.count({
     *   where: {
     *     // ... the filter for the RecorStocks we want to count
     *   }
     * })
    **/
    count<T extends recorStockCountArgs>(
      args?: Subset<T, recorStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecorStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecorStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecorStockAggregateArgs>(args: Subset<T, RecorStockAggregateArgs>): Prisma.PrismaPromise<GetRecorStockAggregateType<T>>

    /**
     * Group by RecorStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recorStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recorStockGroupByArgs['orderBy'] }
        : { orderBy?: recorStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recorStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecorStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recorStock model
   */
  readonly fields: recorStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recorStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recorStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recorStock model
   */
  interface recorStockFieldRefs {
    readonly idRecordatorio: FieldRef<"recorStock", 'Int'>
    readonly idProducto: FieldRef<"recorStock", 'Int'>
    readonly cantidadMinima: FieldRef<"recorStock", 'Int'>
    readonly fechaRecordatorio: FieldRef<"recorStock", 'DateTime'>
    readonly estado: FieldRef<"recorStock", 'EstadoRecordatorio'>
    readonly createdAt: FieldRef<"recorStock", 'DateTime'>
    readonly updatedAt: FieldRef<"recorStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * recorStock findUnique
   */
  export type recorStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock findUniqueOrThrow
   */
  export type recorStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock findFirst
   */
  export type recorStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recorStocks.
     */
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock findFirstOrThrow
   */
  export type recorStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recorStocks.
     */
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock findMany
   */
  export type recorStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStocks to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock create
   */
  export type recorStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The data needed to create a recorStock.
     */
    data: XOR<recorStockCreateInput, recorStockUncheckedCreateInput>
  }

  /**
   * recorStock createMany
   */
  export type recorStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recorStocks.
     */
    data: recorStockCreateManyInput | recorStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recorStock createManyAndReturn
   */
  export type recorStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * The data used to create many recorStocks.
     */
    data: recorStockCreateManyInput | recorStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recorStock update
   */
  export type recorStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The data needed to update a recorStock.
     */
    data: XOR<recorStockUpdateInput, recorStockUncheckedUpdateInput>
    /**
     * Choose, which recorStock to update.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock updateMany
   */
  export type recorStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recorStocks.
     */
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyInput>
    /**
     * Filter which recorStocks to update
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to update.
     */
    limit?: number
  }

  /**
   * recorStock updateManyAndReturn
   */
  export type recorStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * The data used to update recorStocks.
     */
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyInput>
    /**
     * Filter which recorStocks to update
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * recorStock upsert
   */
  export type recorStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The filter to search for the recorStock to update in case it exists.
     */
    where: recorStockWhereUniqueInput
    /**
     * In case the recorStock found by the `where` argument doesn't exist, create a new recorStock with this data.
     */
    create: XOR<recorStockCreateInput, recorStockUncheckedCreateInput>
    /**
     * In case the recorStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recorStockUpdateInput, recorStockUncheckedUpdateInput>
  }

  /**
   * recorStock delete
   */
  export type recorStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter which recorStock to delete.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock deleteMany
   */
  export type recorStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recorStocks to delete
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to delete.
     */
    limit?: number
  }

  /**
   * recorStock without action
   */
  export type recorStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
  }


  /**
   * Model comentarios
   */

  export type AggregateComentarios = {
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  export type ComentariosAvgAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
  }

  export type ComentariosSumAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
  }

  export type ComentariosMinAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    comentario: string | null
    fechaComentario: Date | null
    estado: $Enums.EstadoComentario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosMaxAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    comentario: string | null
    fechaComentario: Date | null
    estado: $Enums.EstadoComentario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosCountAggregateOutputType = {
    idComentario: number
    idUsuario: number
    comentario: number
    fechaComentario: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComentariosAvgAggregateInputType = {
    idComentario?: true
    idUsuario?: true
  }

  export type ComentariosSumAggregateInputType = {
    idComentario?: true
    idUsuario?: true
  }

  export type ComentariosMinAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosMaxAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosCountAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComentariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to aggregate.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentarios
    **/
    _count?: true | ComentariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentariosMaxAggregateInputType
  }

  export type GetComentariosAggregateType<T extends ComentariosAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarios[P]>
      : GetScalarType<T[P], AggregateComentarios[P]>
  }




  export type comentariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentariosWhereInput
    orderBy?: comentariosOrderByWithAggregationInput | comentariosOrderByWithAggregationInput[]
    by: ComentariosScalarFieldEnum[] | ComentariosScalarFieldEnum
    having?: comentariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentariosCountAggregateInputType | true
    _avg?: ComentariosAvgAggregateInputType
    _sum?: ComentariosSumAggregateInputType
    _min?: ComentariosMinAggregateInputType
    _max?: ComentariosMaxAggregateInputType
  }

  export type ComentariosGroupByOutputType = {
    idComentario: number
    idUsuario: number
    comentario: string
    fechaComentario: Date
    estado: $Enums.EstadoComentario
    createdAt: Date
    updatedAt: Date
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  type GetComentariosGroupByPayload<T extends comentariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
            : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
        }
      >
    >


  export type comentariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectScalar = {
    idComentario?: boolean
    idUsuario?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type comentariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idComentario" | "idUsuario" | "comentario" | "fechaComentario" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["comentarios"]>
  export type comentariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type comentariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type comentariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $comentariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comentarios"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idComentario: number
      idUsuario: number
      comentario: string
      fechaComentario: Date
      estado: $Enums.EstadoComentario
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comentarios"]>
    composites: {}
  }

  type comentariosGetPayload<S extends boolean | null | undefined | comentariosDefaultArgs> = $Result.GetResult<Prisma.$comentariosPayload, S>

  type comentariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comentariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComentariosCountAggregateInputType | true
    }

  export interface comentariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comentarios'], meta: { name: 'comentarios' } }
    /**
     * Find zero or one Comentarios that matches the filter.
     * @param {comentariosFindUniqueArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comentariosFindUniqueArgs>(args: SelectSubset<T, comentariosFindUniqueArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comentarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comentariosFindUniqueOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comentariosFindUniqueOrThrowArgs>(args: SelectSubset<T, comentariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comentariosFindFirstArgs>(args?: SelectSubset<T, comentariosFindFirstArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comentariosFindFirstOrThrowArgs>(args?: SelectSubset<T, comentariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentarios.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentarios.findMany({ take: 10 })
     * 
     * // Only select the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.findMany({ select: { idComentario: true } })
     * 
     */
    findMany<T extends comentariosFindManyArgs>(args?: SelectSubset<T, comentariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comentarios.
     * @param {comentariosCreateArgs} args - Arguments to create a Comentarios.
     * @example
     * // Create one Comentarios
     * const Comentarios = await prisma.comentarios.create({
     *   data: {
     *     // ... data to create a Comentarios
     *   }
     * })
     * 
     */
    create<T extends comentariosCreateArgs>(args: SelectSubset<T, comentariosCreateArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comentarios.
     * @param {comentariosCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentarios = await prisma.comentarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comentariosCreateManyArgs>(args?: SelectSubset<T, comentariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comentarios and returns the data saved in the database.
     * @param {comentariosCreateManyAndReturnArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentarios = await prisma.comentarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comentarios and only return the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.createManyAndReturn({
     *   select: { idComentario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comentariosCreateManyAndReturnArgs>(args?: SelectSubset<T, comentariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comentarios.
     * @param {comentariosDeleteArgs} args - Arguments to delete one Comentarios.
     * @example
     * // Delete one Comentarios
     * const Comentarios = await prisma.comentarios.delete({
     *   where: {
     *     // ... filter to delete one Comentarios
     *   }
     * })
     * 
     */
    delete<T extends comentariosDeleteArgs>(args: SelectSubset<T, comentariosDeleteArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comentarios.
     * @param {comentariosUpdateArgs} args - Arguments to update one Comentarios.
     * @example
     * // Update one Comentarios
     * const comentarios = await prisma.comentarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comentariosUpdateArgs>(args: SelectSubset<T, comentariosUpdateArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comentarios.
     * @param {comentariosDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comentariosDeleteManyArgs>(args?: SelectSubset<T, comentariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comentariosUpdateManyArgs>(args: SelectSubset<T, comentariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios and returns the data updated in the database.
     * @param {comentariosUpdateManyAndReturnArgs} args - Arguments to update many Comentarios.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comentarios and only return the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.updateManyAndReturn({
     *   select: { idComentario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comentariosUpdateManyAndReturnArgs>(args: SelectSubset<T, comentariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comentarios.
     * @param {comentariosUpsertArgs} args - Arguments to update or create a Comentarios.
     * @example
     * // Update or create a Comentarios
     * const comentarios = await prisma.comentarios.upsert({
     *   create: {
     *     // ... data to create a Comentarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentarios we want to update
     *   }
     * })
     */
    upsert<T extends comentariosUpsertArgs>(args: SelectSubset<T, comentariosUpsertArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentarios.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends comentariosCountArgs>(
      args?: Subset<T, comentariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentariosAggregateArgs>(args: Subset<T, ComentariosAggregateArgs>): Prisma.PrismaPromise<GetComentariosAggregateType<T>>

    /**
     * Group by Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comentariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comentariosGroupByArgs['orderBy'] }
        : { orderBy?: comentariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comentariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comentarios model
   */
  readonly fields: comentariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comentarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comentariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comentarios model
   */
  interface comentariosFieldRefs {
    readonly idComentario: FieldRef<"comentarios", 'Int'>
    readonly idUsuario: FieldRef<"comentarios", 'Int'>
    readonly comentario: FieldRef<"comentarios", 'String'>
    readonly fechaComentario: FieldRef<"comentarios", 'DateTime'>
    readonly estado: FieldRef<"comentarios", 'EstadoComentario'>
    readonly createdAt: FieldRef<"comentarios", 'DateTime'>
    readonly updatedAt: FieldRef<"comentarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comentarios findUnique
   */
  export type comentariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios findUniqueOrThrow
   */
  export type comentariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios findFirst
   */
  export type comentariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios findFirstOrThrow
   */
  export type comentariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios findMany
   */
  export type comentariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios create
   */
  export type comentariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The data needed to create a comentarios.
     */
    data: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
  }

  /**
   * comentarios createMany
   */
  export type comentariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comentarios.
     */
    data: comentariosCreateManyInput | comentariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comentarios createManyAndReturn
   */
  export type comentariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * The data used to create many comentarios.
     */
    data: comentariosCreateManyInput | comentariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comentarios update
   */
  export type comentariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The data needed to update a comentarios.
     */
    data: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
    /**
     * Choose, which comentarios to update.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios updateMany
   */
  export type comentariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to update.
     */
    limit?: number
  }

  /**
   * comentarios updateManyAndReturn
   */
  export type comentariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comentarios upsert
   */
  export type comentariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The filter to search for the comentarios to update in case it exists.
     */
    where: comentariosWhereUniqueInput
    /**
     * In case the comentarios found by the `where` argument doesn't exist, create a new comentarios with this data.
     */
    create: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
    /**
     * In case the comentarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
  }

  /**
   * comentarios delete
   */
  export type comentariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter which comentarios to delete.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios deleteMany
   */
  export type comentariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to delete
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to delete.
     */
    limit?: number
  }

  /**
   * comentarios without action
   */
  export type comentariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
  }


  /**
   * Model soporte
   */

  export type AggregateSoporte = {
    _count: SoporteCountAggregateOutputType | null
    _avg: SoporteAvgAggregateOutputType | null
    _sum: SoporteSumAggregateOutputType | null
    _min: SoporteMinAggregateOutputType | null
    _max: SoporteMaxAggregateOutputType | null
  }

  export type SoporteAvgAggregateOutputType = {
    idSoporte: number | null
    idUsuario: number | null
  }

  export type SoporteSumAggregateOutputType = {
    idSoporte: number | null
    idUsuario: number | null
  }

  export type SoporteMinAggregateOutputType = {
    idSoporte: number | null
    idUsuario: number | null
    asunto: string | null
    descripcion: string | null
    estado: $Enums.EstadoSoporte | null
    respuesta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoporteMaxAggregateOutputType = {
    idSoporte: number | null
    idUsuario: number | null
    asunto: string | null
    descripcion: string | null
    estado: $Enums.EstadoSoporte | null
    respuesta: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoporteCountAggregateOutputType = {
    idSoporte: number
    idUsuario: number
    asunto: number
    descripcion: number
    estado: number
    respuesta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SoporteAvgAggregateInputType = {
    idSoporte?: true
    idUsuario?: true
  }

  export type SoporteSumAggregateInputType = {
    idSoporte?: true
    idUsuario?: true
  }

  export type SoporteMinAggregateInputType = {
    idSoporte?: true
    idUsuario?: true
    asunto?: true
    descripcion?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoporteMaxAggregateInputType = {
    idSoporte?: true
    idUsuario?: true
    asunto?: true
    descripcion?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoporteCountAggregateInputType = {
    idSoporte?: true
    idUsuario?: true
    asunto?: true
    descripcion?: true
    estado?: true
    respuesta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SoporteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soporte to aggregate.
     */
    where?: soporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soportes to fetch.
     */
    orderBy?: soporteOrderByWithRelationInput | soporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: soporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned soportes
    **/
    _count?: true | SoporteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoporteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoporteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoporteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoporteMaxAggregateInputType
  }

  export type GetSoporteAggregateType<T extends SoporteAggregateArgs> = {
        [P in keyof T & keyof AggregateSoporte]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoporte[P]>
      : GetScalarType<T[P], AggregateSoporte[P]>
  }




  export type soporteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: soporteWhereInput
    orderBy?: soporteOrderByWithAggregationInput | soporteOrderByWithAggregationInput[]
    by: SoporteScalarFieldEnum[] | SoporteScalarFieldEnum
    having?: soporteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoporteCountAggregateInputType | true
    _avg?: SoporteAvgAggregateInputType
    _sum?: SoporteSumAggregateInputType
    _min?: SoporteMinAggregateInputType
    _max?: SoporteMaxAggregateInputType
  }

  export type SoporteGroupByOutputType = {
    idSoporte: number
    idUsuario: number
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt: Date
    updatedAt: Date
    _count: SoporteCountAggregateOutputType | null
    _avg: SoporteAvgAggregateOutputType | null
    _sum: SoporteSumAggregateOutputType | null
    _min: SoporteMinAggregateOutputType | null
    _max: SoporteMaxAggregateOutputType | null
  }

  type GetSoporteGroupByPayload<T extends soporteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoporteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoporteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoporteGroupByOutputType[P]>
            : GetScalarType<T[P], SoporteGroupByOutputType[P]>
        }
      >
    >


  export type soporteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSoporte?: boolean
    idUsuario?: boolean
    asunto?: boolean
    descripcion?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soporte"]>

  export type soporteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSoporte?: boolean
    idUsuario?: boolean
    asunto?: boolean
    descripcion?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soporte"]>

  export type soporteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSoporte?: boolean
    idUsuario?: boolean
    asunto?: boolean
    descripcion?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soporte"]>

  export type soporteSelectScalar = {
    idSoporte?: boolean
    idUsuario?: boolean
    asunto?: boolean
    descripcion?: boolean
    estado?: boolean
    respuesta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type soporteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSoporte" | "idUsuario" | "asunto" | "descripcion" | "estado" | "respuesta" | "createdAt" | "updatedAt", ExtArgs["result"]["soporte"]>
  export type soporteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type soporteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type soporteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $soportePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "soporte"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idSoporte: number
      idUsuario: number
      asunto: string
      descripcion: string
      estado: $Enums.EstadoSoporte
      respuesta: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["soporte"]>
    composites: {}
  }

  type soporteGetPayload<S extends boolean | null | undefined | soporteDefaultArgs> = $Result.GetResult<Prisma.$soportePayload, S>

  type soporteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<soporteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoporteCountAggregateInputType | true
    }

  export interface soporteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['soporte'], meta: { name: 'soporte' } }
    /**
     * Find zero or one Soporte that matches the filter.
     * @param {soporteFindUniqueArgs} args - Arguments to find a Soporte
     * @example
     * // Get one Soporte
     * const soporte = await prisma.soporte.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends soporteFindUniqueArgs>(args: SelectSubset<T, soporteFindUniqueArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Soporte that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {soporteFindUniqueOrThrowArgs} args - Arguments to find a Soporte
     * @example
     * // Get one Soporte
     * const soporte = await prisma.soporte.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends soporteFindUniqueOrThrowArgs>(args: SelectSubset<T, soporteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soporte that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteFindFirstArgs} args - Arguments to find a Soporte
     * @example
     * // Get one Soporte
     * const soporte = await prisma.soporte.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends soporteFindFirstArgs>(args?: SelectSubset<T, soporteFindFirstArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Soporte that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteFindFirstOrThrowArgs} args - Arguments to find a Soporte
     * @example
     * // Get one Soporte
     * const soporte = await prisma.soporte.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends soporteFindFirstOrThrowArgs>(args?: SelectSubset<T, soporteFindFirstOrThrowArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Soportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Soportes
     * const soportes = await prisma.soporte.findMany()
     * 
     * // Get first 10 Soportes
     * const soportes = await prisma.soporte.findMany({ take: 10 })
     * 
     * // Only select the `idSoporte`
     * const soporteWithIdSoporteOnly = await prisma.soporte.findMany({ select: { idSoporte: true } })
     * 
     */
    findMany<T extends soporteFindManyArgs>(args?: SelectSubset<T, soporteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Soporte.
     * @param {soporteCreateArgs} args - Arguments to create a Soporte.
     * @example
     * // Create one Soporte
     * const Soporte = await prisma.soporte.create({
     *   data: {
     *     // ... data to create a Soporte
     *   }
     * })
     * 
     */
    create<T extends soporteCreateArgs>(args: SelectSubset<T, soporteCreateArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Soportes.
     * @param {soporteCreateManyArgs} args - Arguments to create many Soportes.
     * @example
     * // Create many Soportes
     * const soporte = await prisma.soporte.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends soporteCreateManyArgs>(args?: SelectSubset<T, soporteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Soportes and returns the data saved in the database.
     * @param {soporteCreateManyAndReturnArgs} args - Arguments to create many Soportes.
     * @example
     * // Create many Soportes
     * const soporte = await prisma.soporte.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Soportes and only return the `idSoporte`
     * const soporteWithIdSoporteOnly = await prisma.soporte.createManyAndReturn({
     *   select: { idSoporte: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends soporteCreateManyAndReturnArgs>(args?: SelectSubset<T, soporteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Soporte.
     * @param {soporteDeleteArgs} args - Arguments to delete one Soporte.
     * @example
     * // Delete one Soporte
     * const Soporte = await prisma.soporte.delete({
     *   where: {
     *     // ... filter to delete one Soporte
     *   }
     * })
     * 
     */
    delete<T extends soporteDeleteArgs>(args: SelectSubset<T, soporteDeleteArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Soporte.
     * @param {soporteUpdateArgs} args - Arguments to update one Soporte.
     * @example
     * // Update one Soporte
     * const soporte = await prisma.soporte.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends soporteUpdateArgs>(args: SelectSubset<T, soporteUpdateArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Soportes.
     * @param {soporteDeleteManyArgs} args - Arguments to filter Soportes to delete.
     * @example
     * // Delete a few Soportes
     * const { count } = await prisma.soporte.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends soporteDeleteManyArgs>(args?: SelectSubset<T, soporteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Soportes
     * const soporte = await prisma.soporte.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends soporteUpdateManyArgs>(args: SelectSubset<T, soporteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Soportes and returns the data updated in the database.
     * @param {soporteUpdateManyAndReturnArgs} args - Arguments to update many Soportes.
     * @example
     * // Update many Soportes
     * const soporte = await prisma.soporte.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Soportes and only return the `idSoporte`
     * const soporteWithIdSoporteOnly = await prisma.soporte.updateManyAndReturn({
     *   select: { idSoporte: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends soporteUpdateManyAndReturnArgs>(args: SelectSubset<T, soporteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Soporte.
     * @param {soporteUpsertArgs} args - Arguments to update or create a Soporte.
     * @example
     * // Update or create a Soporte
     * const soporte = await prisma.soporte.upsert({
     *   create: {
     *     // ... data to create a Soporte
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Soporte we want to update
     *   }
     * })
     */
    upsert<T extends soporteUpsertArgs>(args: SelectSubset<T, soporteUpsertArgs<ExtArgs>>): Prisma__soporteClient<$Result.GetResult<Prisma.$soportePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Soportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteCountArgs} args - Arguments to filter Soportes to count.
     * @example
     * // Count the number of Soportes
     * const count = await prisma.soporte.count({
     *   where: {
     *     // ... the filter for the Soportes we want to count
     *   }
     * })
    **/
    count<T extends soporteCountArgs>(
      args?: Subset<T, soporteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoporteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Soporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoporteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoporteAggregateArgs>(args: Subset<T, SoporteAggregateArgs>): Prisma.PrismaPromise<GetSoporteAggregateType<T>>

    /**
     * Group by Soporte.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {soporteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends soporteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: soporteGroupByArgs['orderBy'] }
        : { orderBy?: soporteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, soporteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoporteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the soporte model
   */
  readonly fields: soporteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for soporte.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__soporteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the soporte model
   */
  interface soporteFieldRefs {
    readonly idSoporte: FieldRef<"soporte", 'Int'>
    readonly idUsuario: FieldRef<"soporte", 'Int'>
    readonly asunto: FieldRef<"soporte", 'String'>
    readonly descripcion: FieldRef<"soporte", 'String'>
    readonly estado: FieldRef<"soporte", 'EstadoSoporte'>
    readonly respuesta: FieldRef<"soporte", 'String'>
    readonly createdAt: FieldRef<"soporte", 'DateTime'>
    readonly updatedAt: FieldRef<"soporte", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * soporte findUnique
   */
  export type soporteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter, which soporte to fetch.
     */
    where: soporteWhereUniqueInput
  }

  /**
   * soporte findUniqueOrThrow
   */
  export type soporteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter, which soporte to fetch.
     */
    where: soporteWhereUniqueInput
  }

  /**
   * soporte findFirst
   */
  export type soporteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter, which soporte to fetch.
     */
    where?: soporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soportes to fetch.
     */
    orderBy?: soporteOrderByWithRelationInput | soporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soportes.
     */
    cursor?: soporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soportes.
     */
    distinct?: SoporteScalarFieldEnum | SoporteScalarFieldEnum[]
  }

  /**
   * soporte findFirstOrThrow
   */
  export type soporteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter, which soporte to fetch.
     */
    where?: soporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soportes to fetch.
     */
    orderBy?: soporteOrderByWithRelationInput | soporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for soportes.
     */
    cursor?: soporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of soportes.
     */
    distinct?: SoporteScalarFieldEnum | SoporteScalarFieldEnum[]
  }

  /**
   * soporte findMany
   */
  export type soporteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter, which soportes to fetch.
     */
    where?: soporteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of soportes to fetch.
     */
    orderBy?: soporteOrderByWithRelationInput | soporteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing soportes.
     */
    cursor?: soporteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` soportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` soportes.
     */
    skip?: number
    distinct?: SoporteScalarFieldEnum | SoporteScalarFieldEnum[]
  }

  /**
   * soporte create
   */
  export type soporteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * The data needed to create a soporte.
     */
    data: XOR<soporteCreateInput, soporteUncheckedCreateInput>
  }

  /**
   * soporte createMany
   */
  export type soporteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many soportes.
     */
    data: soporteCreateManyInput | soporteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * soporte createManyAndReturn
   */
  export type soporteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * The data used to create many soportes.
     */
    data: soporteCreateManyInput | soporteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * soporte update
   */
  export type soporteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * The data needed to update a soporte.
     */
    data: XOR<soporteUpdateInput, soporteUncheckedUpdateInput>
    /**
     * Choose, which soporte to update.
     */
    where: soporteWhereUniqueInput
  }

  /**
   * soporte updateMany
   */
  export type soporteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update soportes.
     */
    data: XOR<soporteUpdateManyMutationInput, soporteUncheckedUpdateManyInput>
    /**
     * Filter which soportes to update
     */
    where?: soporteWhereInput
    /**
     * Limit how many soportes to update.
     */
    limit?: number
  }

  /**
   * soporte updateManyAndReturn
   */
  export type soporteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * The data used to update soportes.
     */
    data: XOR<soporteUpdateManyMutationInput, soporteUncheckedUpdateManyInput>
    /**
     * Filter which soportes to update
     */
    where?: soporteWhereInput
    /**
     * Limit how many soportes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * soporte upsert
   */
  export type soporteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * The filter to search for the soporte to update in case it exists.
     */
    where: soporteWhereUniqueInput
    /**
     * In case the soporte found by the `where` argument doesn't exist, create a new soporte with this data.
     */
    create: XOR<soporteCreateInput, soporteUncheckedCreateInput>
    /**
     * In case the soporte was found with the provided `where` argument, update it with this data.
     */
    update: XOR<soporteUpdateInput, soporteUncheckedUpdateInput>
  }

  /**
   * soporte delete
   */
  export type soporteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
    /**
     * Filter which soporte to delete.
     */
    where: soporteWhereUniqueInput
  }

  /**
   * soporte deleteMany
   */
  export type soporteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which soportes to delete
     */
    where?: soporteWhereInput
    /**
     * Limit how many soportes to delete.
     */
    limit?: number
  }

  /**
   * soporte without action
   */
  export type soporteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the soporte
     */
    select?: soporteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the soporte
     */
    omit?: soporteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: soporteInclude<ExtArgs> | null
  }


  /**
   * Model ajustInven
   */

  export type AggregateAjustInven = {
    _count: AjustInvenCountAggregateOutputType | null
    _avg: AjustInvenAvgAggregateOutputType | null
    _sum: AjustInvenSumAggregateOutputType | null
    _min: AjustInvenMinAggregateOutputType | null
    _max: AjustInvenMaxAggregateOutputType | null
  }

  export type AjustInvenAvgAggregateOutputType = {
    idAjuste: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidadAnterior: number | null
    cantidadNueva: number | null
  }

  export type AjustInvenSumAggregateOutputType = {
    idAjuste: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidadAnterior: number | null
    cantidadNueva: number | null
  }

  export type AjustInvenMinAggregateOutputType = {
    idAjuste: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidadAnterior: number | null
    cantidadNueva: number | null
    motivo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AjustInvenMaxAggregateOutputType = {
    idAjuste: number | null
    idProducto: number | null
    idUsuario: number | null
    cantidadAnterior: number | null
    cantidadNueva: number | null
    motivo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AjustInvenCountAggregateOutputType = {
    idAjuste: number
    idProducto: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AjustInvenAvgAggregateInputType = {
    idAjuste?: true
    idProducto?: true
    idUsuario?: true
    cantidadAnterior?: true
    cantidadNueva?: true
  }

  export type AjustInvenSumAggregateInputType = {
    idAjuste?: true
    idProducto?: true
    idUsuario?: true
    cantidadAnterior?: true
    cantidadNueva?: true
  }

  export type AjustInvenMinAggregateInputType = {
    idAjuste?: true
    idProducto?: true
    idUsuario?: true
    cantidadAnterior?: true
    cantidadNueva?: true
    motivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AjustInvenMaxAggregateInputType = {
    idAjuste?: true
    idProducto?: true
    idUsuario?: true
    cantidadAnterior?: true
    cantidadNueva?: true
    motivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AjustInvenCountAggregateInputType = {
    idAjuste?: true
    idProducto?: true
    idUsuario?: true
    cantidadAnterior?: true
    cantidadNueva?: true
    motivo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AjustInvenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ajustInven to aggregate.
     */
    where?: ajustInvenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ajustInvens to fetch.
     */
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ajustInvenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ajustInvens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ajustInvens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ajustInvens
    **/
    _count?: true | AjustInvenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AjustInvenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AjustInvenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AjustInvenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AjustInvenMaxAggregateInputType
  }

  export type GetAjustInvenAggregateType<T extends AjustInvenAggregateArgs> = {
        [P in keyof T & keyof AggregateAjustInven]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAjustInven[P]>
      : GetScalarType<T[P], AggregateAjustInven[P]>
  }




  export type ajustInvenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ajustInvenWhereInput
    orderBy?: ajustInvenOrderByWithAggregationInput | ajustInvenOrderByWithAggregationInput[]
    by: AjustInvenScalarFieldEnum[] | AjustInvenScalarFieldEnum
    having?: ajustInvenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AjustInvenCountAggregateInputType | true
    _avg?: AjustInvenAvgAggregateInputType
    _sum?: AjustInvenSumAggregateInputType
    _min?: AjustInvenMinAggregateInputType
    _max?: AjustInvenMaxAggregateInputType
  }

  export type AjustInvenGroupByOutputType = {
    idAjuste: number
    idProducto: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt: Date
    updatedAt: Date
    _count: AjustInvenCountAggregateOutputType | null
    _avg: AjustInvenAvgAggregateOutputType | null
    _sum: AjustInvenSumAggregateOutputType | null
    _min: AjustInvenMinAggregateOutputType | null
    _max: AjustInvenMaxAggregateOutputType | null
  }

  type GetAjustInvenGroupByPayload<T extends ajustInvenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AjustInvenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AjustInvenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AjustInvenGroupByOutputType[P]>
            : GetScalarType<T[P], AjustInvenGroupByOutputType[P]>
        }
      >
    >


  export type ajustInvenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAjuste?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    cantidadAnterior?: boolean
    cantidadNueva?: boolean
    motivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ajustInven"]>

  export type ajustInvenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAjuste?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    cantidadAnterior?: boolean
    cantidadNueva?: boolean
    motivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ajustInven"]>

  export type ajustInvenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAjuste?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    cantidadAnterior?: boolean
    cantidadNueva?: boolean
    motivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ajustInven"]>

  export type ajustInvenSelectScalar = {
    idAjuste?: boolean
    idProducto?: boolean
    idUsuario?: boolean
    cantidadAnterior?: boolean
    cantidadNueva?: boolean
    motivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ajustInvenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idAjuste" | "idProducto" | "idUsuario" | "cantidadAnterior" | "cantidadNueva" | "motivo" | "createdAt" | "updatedAt", ExtArgs["result"]["ajustInven"]>
  export type ajustInvenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ajustInvenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type ajustInvenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ajustInvenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ajustInven"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idAjuste: number
      idProducto: number
      idUsuario: number
      cantidadAnterior: number
      cantidadNueva: number
      motivo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ajustInven"]>
    composites: {}
  }

  type ajustInvenGetPayload<S extends boolean | null | undefined | ajustInvenDefaultArgs> = $Result.GetResult<Prisma.$ajustInvenPayload, S>

  type ajustInvenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ajustInvenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AjustInvenCountAggregateInputType | true
    }

  export interface ajustInvenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ajustInven'], meta: { name: 'ajustInven' } }
    /**
     * Find zero or one AjustInven that matches the filter.
     * @param {ajustInvenFindUniqueArgs} args - Arguments to find a AjustInven
     * @example
     * // Get one AjustInven
     * const ajustInven = await prisma.ajustInven.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ajustInvenFindUniqueArgs>(args: SelectSubset<T, ajustInvenFindUniqueArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AjustInven that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ajustInvenFindUniqueOrThrowArgs} args - Arguments to find a AjustInven
     * @example
     * // Get one AjustInven
     * const ajustInven = await prisma.ajustInven.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ajustInvenFindUniqueOrThrowArgs>(args: SelectSubset<T, ajustInvenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AjustInven that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenFindFirstArgs} args - Arguments to find a AjustInven
     * @example
     * // Get one AjustInven
     * const ajustInven = await prisma.ajustInven.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ajustInvenFindFirstArgs>(args?: SelectSubset<T, ajustInvenFindFirstArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AjustInven that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenFindFirstOrThrowArgs} args - Arguments to find a AjustInven
     * @example
     * // Get one AjustInven
     * const ajustInven = await prisma.ajustInven.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ajustInvenFindFirstOrThrowArgs>(args?: SelectSubset<T, ajustInvenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AjustInvens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AjustInvens
     * const ajustInvens = await prisma.ajustInven.findMany()
     * 
     * // Get first 10 AjustInvens
     * const ajustInvens = await prisma.ajustInven.findMany({ take: 10 })
     * 
     * // Only select the `idAjuste`
     * const ajustInvenWithIdAjusteOnly = await prisma.ajustInven.findMany({ select: { idAjuste: true } })
     * 
     */
    findMany<T extends ajustInvenFindManyArgs>(args?: SelectSubset<T, ajustInvenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AjustInven.
     * @param {ajustInvenCreateArgs} args - Arguments to create a AjustInven.
     * @example
     * // Create one AjustInven
     * const AjustInven = await prisma.ajustInven.create({
     *   data: {
     *     // ... data to create a AjustInven
     *   }
     * })
     * 
     */
    create<T extends ajustInvenCreateArgs>(args: SelectSubset<T, ajustInvenCreateArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AjustInvens.
     * @param {ajustInvenCreateManyArgs} args - Arguments to create many AjustInvens.
     * @example
     * // Create many AjustInvens
     * const ajustInven = await prisma.ajustInven.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ajustInvenCreateManyArgs>(args?: SelectSubset<T, ajustInvenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AjustInvens and returns the data saved in the database.
     * @param {ajustInvenCreateManyAndReturnArgs} args - Arguments to create many AjustInvens.
     * @example
     * // Create many AjustInvens
     * const ajustInven = await prisma.ajustInven.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AjustInvens and only return the `idAjuste`
     * const ajustInvenWithIdAjusteOnly = await prisma.ajustInven.createManyAndReturn({
     *   select: { idAjuste: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ajustInvenCreateManyAndReturnArgs>(args?: SelectSubset<T, ajustInvenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AjustInven.
     * @param {ajustInvenDeleteArgs} args - Arguments to delete one AjustInven.
     * @example
     * // Delete one AjustInven
     * const AjustInven = await prisma.ajustInven.delete({
     *   where: {
     *     // ... filter to delete one AjustInven
     *   }
     * })
     * 
     */
    delete<T extends ajustInvenDeleteArgs>(args: SelectSubset<T, ajustInvenDeleteArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AjustInven.
     * @param {ajustInvenUpdateArgs} args - Arguments to update one AjustInven.
     * @example
     * // Update one AjustInven
     * const ajustInven = await prisma.ajustInven.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ajustInvenUpdateArgs>(args: SelectSubset<T, ajustInvenUpdateArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AjustInvens.
     * @param {ajustInvenDeleteManyArgs} args - Arguments to filter AjustInvens to delete.
     * @example
     * // Delete a few AjustInvens
     * const { count } = await prisma.ajustInven.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ajustInvenDeleteManyArgs>(args?: SelectSubset<T, ajustInvenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AjustInvens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AjustInvens
     * const ajustInven = await prisma.ajustInven.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ajustInvenUpdateManyArgs>(args: SelectSubset<T, ajustInvenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AjustInvens and returns the data updated in the database.
     * @param {ajustInvenUpdateManyAndReturnArgs} args - Arguments to update many AjustInvens.
     * @example
     * // Update many AjustInvens
     * const ajustInven = await prisma.ajustInven.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AjustInvens and only return the `idAjuste`
     * const ajustInvenWithIdAjusteOnly = await prisma.ajustInven.updateManyAndReturn({
     *   select: { idAjuste: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ajustInvenUpdateManyAndReturnArgs>(args: SelectSubset<T, ajustInvenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AjustInven.
     * @param {ajustInvenUpsertArgs} args - Arguments to update or create a AjustInven.
     * @example
     * // Update or create a AjustInven
     * const ajustInven = await prisma.ajustInven.upsert({
     *   create: {
     *     // ... data to create a AjustInven
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AjustInven we want to update
     *   }
     * })
     */
    upsert<T extends ajustInvenUpsertArgs>(args: SelectSubset<T, ajustInvenUpsertArgs<ExtArgs>>): Prisma__ajustInvenClient<$Result.GetResult<Prisma.$ajustInvenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AjustInvens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenCountArgs} args - Arguments to filter AjustInvens to count.
     * @example
     * // Count the number of AjustInvens
     * const count = await prisma.ajustInven.count({
     *   where: {
     *     // ... the filter for the AjustInvens we want to count
     *   }
     * })
    **/
    count<T extends ajustInvenCountArgs>(
      args?: Subset<T, ajustInvenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AjustInvenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AjustInven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AjustInvenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AjustInvenAggregateArgs>(args: Subset<T, AjustInvenAggregateArgs>): Prisma.PrismaPromise<GetAjustInvenAggregateType<T>>

    /**
     * Group by AjustInven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ajustInvenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ajustInvenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ajustInvenGroupByArgs['orderBy'] }
        : { orderBy?: ajustInvenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ajustInvenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAjustInvenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ajustInven model
   */
  readonly fields: ajustInvenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ajustInven.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ajustInvenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ajustInven model
   */
  interface ajustInvenFieldRefs {
    readonly idAjuste: FieldRef<"ajustInven", 'Int'>
    readonly idProducto: FieldRef<"ajustInven", 'Int'>
    readonly idUsuario: FieldRef<"ajustInven", 'Int'>
    readonly cantidadAnterior: FieldRef<"ajustInven", 'Int'>
    readonly cantidadNueva: FieldRef<"ajustInven", 'Int'>
    readonly motivo: FieldRef<"ajustInven", 'String'>
    readonly createdAt: FieldRef<"ajustInven", 'DateTime'>
    readonly updatedAt: FieldRef<"ajustInven", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ajustInven findUnique
   */
  export type ajustInvenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter, which ajustInven to fetch.
     */
    where: ajustInvenWhereUniqueInput
  }

  /**
   * ajustInven findUniqueOrThrow
   */
  export type ajustInvenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter, which ajustInven to fetch.
     */
    where: ajustInvenWhereUniqueInput
  }

  /**
   * ajustInven findFirst
   */
  export type ajustInvenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter, which ajustInven to fetch.
     */
    where?: ajustInvenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ajustInvens to fetch.
     */
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ajustInvens.
     */
    cursor?: ajustInvenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ajustInvens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ajustInvens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ajustInvens.
     */
    distinct?: AjustInvenScalarFieldEnum | AjustInvenScalarFieldEnum[]
  }

  /**
   * ajustInven findFirstOrThrow
   */
  export type ajustInvenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter, which ajustInven to fetch.
     */
    where?: ajustInvenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ajustInvens to fetch.
     */
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ajustInvens.
     */
    cursor?: ajustInvenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ajustInvens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ajustInvens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ajustInvens.
     */
    distinct?: AjustInvenScalarFieldEnum | AjustInvenScalarFieldEnum[]
  }

  /**
   * ajustInven findMany
   */
  export type ajustInvenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter, which ajustInvens to fetch.
     */
    where?: ajustInvenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ajustInvens to fetch.
     */
    orderBy?: ajustInvenOrderByWithRelationInput | ajustInvenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ajustInvens.
     */
    cursor?: ajustInvenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ajustInvens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ajustInvens.
     */
    skip?: number
    distinct?: AjustInvenScalarFieldEnum | AjustInvenScalarFieldEnum[]
  }

  /**
   * ajustInven create
   */
  export type ajustInvenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * The data needed to create a ajustInven.
     */
    data: XOR<ajustInvenCreateInput, ajustInvenUncheckedCreateInput>
  }

  /**
   * ajustInven createMany
   */
  export type ajustInvenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ajustInvens.
     */
    data: ajustInvenCreateManyInput | ajustInvenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ajustInven createManyAndReturn
   */
  export type ajustInvenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * The data used to create many ajustInvens.
     */
    data: ajustInvenCreateManyInput | ajustInvenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ajustInven update
   */
  export type ajustInvenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * The data needed to update a ajustInven.
     */
    data: XOR<ajustInvenUpdateInput, ajustInvenUncheckedUpdateInput>
    /**
     * Choose, which ajustInven to update.
     */
    where: ajustInvenWhereUniqueInput
  }

  /**
   * ajustInven updateMany
   */
  export type ajustInvenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ajustInvens.
     */
    data: XOR<ajustInvenUpdateManyMutationInput, ajustInvenUncheckedUpdateManyInput>
    /**
     * Filter which ajustInvens to update
     */
    where?: ajustInvenWhereInput
    /**
     * Limit how many ajustInvens to update.
     */
    limit?: number
  }

  /**
   * ajustInven updateManyAndReturn
   */
  export type ajustInvenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * The data used to update ajustInvens.
     */
    data: XOR<ajustInvenUpdateManyMutationInput, ajustInvenUncheckedUpdateManyInput>
    /**
     * Filter which ajustInvens to update
     */
    where?: ajustInvenWhereInput
    /**
     * Limit how many ajustInvens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ajustInven upsert
   */
  export type ajustInvenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * The filter to search for the ajustInven to update in case it exists.
     */
    where: ajustInvenWhereUniqueInput
    /**
     * In case the ajustInven found by the `where` argument doesn't exist, create a new ajustInven with this data.
     */
    create: XOR<ajustInvenCreateInput, ajustInvenUncheckedCreateInput>
    /**
     * In case the ajustInven was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ajustInvenUpdateInput, ajustInvenUncheckedUpdateInput>
  }

  /**
   * ajustInven delete
   */
  export type ajustInvenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
    /**
     * Filter which ajustInven to delete.
     */
    where: ajustInvenWhereUniqueInput
  }

  /**
   * ajustInven deleteMany
   */
  export type ajustInvenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ajustInvens to delete
     */
    where?: ajustInvenWhereInput
    /**
     * Limit how many ajustInvens to delete.
     */
    limit?: number
  }

  /**
   * ajustInven without action
   */
  export type ajustInvenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ajustInven
     */
    select?: ajustInvenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ajustInven
     */
    omit?: ajustInvenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ajustInvenInclude<ExtArgs> | null
  }


  /**
   * Model alertVen
   */

  export type AggregateAlertVen = {
    _count: AlertVenCountAggregateOutputType | null
    _avg: AlertVenAvgAggregateOutputType | null
    _sum: AlertVenSumAggregateOutputType | null
    _min: AlertVenMinAggregateOutputType | null
    _max: AlertVenMaxAggregateOutputType | null
  }

  export type AlertVenAvgAggregateOutputType = {
    idAlerta: number | null
    idProducto: number | null
  }

  export type AlertVenSumAggregateOutputType = {
    idAlerta: number | null
    idProducto: number | null
  }

  export type AlertVenMinAggregateOutputType = {
    idAlerta: number | null
    idProducto: number | null
    fechaAlerta: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertVenMaxAggregateOutputType = {
    idAlerta: number | null
    idProducto: number | null
    fechaAlerta: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertVenCountAggregateOutputType = {
    idAlerta: number
    idProducto: number
    fechaAlerta: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertVenAvgAggregateInputType = {
    idAlerta?: true
    idProducto?: true
  }

  export type AlertVenSumAggregateInputType = {
    idAlerta?: true
    idProducto?: true
  }

  export type AlertVenMinAggregateInputType = {
    idAlerta?: true
    idProducto?: true
    fechaAlerta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertVenMaxAggregateInputType = {
    idAlerta?: true
    idProducto?: true
    fechaAlerta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertVenCountAggregateInputType = {
    idAlerta?: true
    idProducto?: true
    fechaAlerta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertVenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alertVen to aggregate.
     */
    where?: alertVenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertVens to fetch.
     */
    orderBy?: alertVenOrderByWithRelationInput | alertVenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alertVenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertVens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertVens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alertVens
    **/
    _count?: true | AlertVenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertVenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertVenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertVenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertVenMaxAggregateInputType
  }

  export type GetAlertVenAggregateType<T extends AlertVenAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertVen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertVen[P]>
      : GetScalarType<T[P], AggregateAlertVen[P]>
  }




  export type alertVenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertVenWhereInput
    orderBy?: alertVenOrderByWithAggregationInput | alertVenOrderByWithAggregationInput[]
    by: AlertVenScalarFieldEnum[] | AlertVenScalarFieldEnum
    having?: alertVenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertVenCountAggregateInputType | true
    _avg?: AlertVenAvgAggregateInputType
    _sum?: AlertVenSumAggregateInputType
    _min?: AlertVenMinAggregateInputType
    _max?: AlertVenMaxAggregateInputType
  }

  export type AlertVenGroupByOutputType = {
    idAlerta: number
    idProducto: number
    fechaAlerta: Date
    estado: $Enums.EstadoRecordatorio
    createdAt: Date
    updatedAt: Date
    _count: AlertVenCountAggregateOutputType | null
    _avg: AlertVenAvgAggregateOutputType | null
    _sum: AlertVenSumAggregateOutputType | null
    _min: AlertVenMinAggregateOutputType | null
    _max: AlertVenMaxAggregateOutputType | null
  }

  type GetAlertVenGroupByPayload<T extends alertVenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertVenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertVenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertVenGroupByOutputType[P]>
            : GetScalarType<T[P], AlertVenGroupByOutputType[P]>
        }
      >
    >


  export type alertVenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAlerta?: boolean
    idProducto?: boolean
    fechaAlerta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertVen"]>

  export type alertVenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAlerta?: boolean
    idProducto?: boolean
    fechaAlerta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertVen"]>

  export type alertVenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAlerta?: boolean
    idProducto?: boolean
    fechaAlerta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertVen"]>

  export type alertVenSelectScalar = {
    idAlerta?: boolean
    idProducto?: boolean
    fechaAlerta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type alertVenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idAlerta" | "idProducto" | "fechaAlerta" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["alertVen"]>
  export type alertVenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type alertVenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type alertVenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $alertVenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alertVen"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idAlerta: number
      idProducto: number
      fechaAlerta: Date
      estado: $Enums.EstadoRecordatorio
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alertVen"]>
    composites: {}
  }

  type alertVenGetPayload<S extends boolean | null | undefined | alertVenDefaultArgs> = $Result.GetResult<Prisma.$alertVenPayload, S>

  type alertVenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<alertVenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertVenCountAggregateInputType | true
    }

  export interface alertVenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alertVen'], meta: { name: 'alertVen' } }
    /**
     * Find zero or one AlertVen that matches the filter.
     * @param {alertVenFindUniqueArgs} args - Arguments to find a AlertVen
     * @example
     * // Get one AlertVen
     * const alertVen = await prisma.alertVen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alertVenFindUniqueArgs>(args: SelectSubset<T, alertVenFindUniqueArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlertVen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {alertVenFindUniqueOrThrowArgs} args - Arguments to find a AlertVen
     * @example
     * // Get one AlertVen
     * const alertVen = await prisma.alertVen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alertVenFindUniqueOrThrowArgs>(args: SelectSubset<T, alertVenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertVen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenFindFirstArgs} args - Arguments to find a AlertVen
     * @example
     * // Get one AlertVen
     * const alertVen = await prisma.alertVen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alertVenFindFirstArgs>(args?: SelectSubset<T, alertVenFindFirstArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertVen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenFindFirstOrThrowArgs} args - Arguments to find a AlertVen
     * @example
     * // Get one AlertVen
     * const alertVen = await prisma.alertVen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alertVenFindFirstOrThrowArgs>(args?: SelectSubset<T, alertVenFindFirstOrThrowArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlertVens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertVens
     * const alertVens = await prisma.alertVen.findMany()
     * 
     * // Get first 10 AlertVens
     * const alertVens = await prisma.alertVen.findMany({ take: 10 })
     * 
     * // Only select the `idAlerta`
     * const alertVenWithIdAlertaOnly = await prisma.alertVen.findMany({ select: { idAlerta: true } })
     * 
     */
    findMany<T extends alertVenFindManyArgs>(args?: SelectSubset<T, alertVenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlertVen.
     * @param {alertVenCreateArgs} args - Arguments to create a AlertVen.
     * @example
     * // Create one AlertVen
     * const AlertVen = await prisma.alertVen.create({
     *   data: {
     *     // ... data to create a AlertVen
     *   }
     * })
     * 
     */
    create<T extends alertVenCreateArgs>(args: SelectSubset<T, alertVenCreateArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlertVens.
     * @param {alertVenCreateManyArgs} args - Arguments to create many AlertVens.
     * @example
     * // Create many AlertVens
     * const alertVen = await prisma.alertVen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alertVenCreateManyArgs>(args?: SelectSubset<T, alertVenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertVens and returns the data saved in the database.
     * @param {alertVenCreateManyAndReturnArgs} args - Arguments to create many AlertVens.
     * @example
     * // Create many AlertVens
     * const alertVen = await prisma.alertVen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertVens and only return the `idAlerta`
     * const alertVenWithIdAlertaOnly = await prisma.alertVen.createManyAndReturn({
     *   select: { idAlerta: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends alertVenCreateManyAndReturnArgs>(args?: SelectSubset<T, alertVenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlertVen.
     * @param {alertVenDeleteArgs} args - Arguments to delete one AlertVen.
     * @example
     * // Delete one AlertVen
     * const AlertVen = await prisma.alertVen.delete({
     *   where: {
     *     // ... filter to delete one AlertVen
     *   }
     * })
     * 
     */
    delete<T extends alertVenDeleteArgs>(args: SelectSubset<T, alertVenDeleteArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlertVen.
     * @param {alertVenUpdateArgs} args - Arguments to update one AlertVen.
     * @example
     * // Update one AlertVen
     * const alertVen = await prisma.alertVen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alertVenUpdateArgs>(args: SelectSubset<T, alertVenUpdateArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlertVens.
     * @param {alertVenDeleteManyArgs} args - Arguments to filter AlertVens to delete.
     * @example
     * // Delete a few AlertVens
     * const { count } = await prisma.alertVen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alertVenDeleteManyArgs>(args?: SelectSubset<T, alertVenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertVens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertVens
     * const alertVen = await prisma.alertVen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alertVenUpdateManyArgs>(args: SelectSubset<T, alertVenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertVens and returns the data updated in the database.
     * @param {alertVenUpdateManyAndReturnArgs} args - Arguments to update many AlertVens.
     * @example
     * // Update many AlertVens
     * const alertVen = await prisma.alertVen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertVens and only return the `idAlerta`
     * const alertVenWithIdAlertaOnly = await prisma.alertVen.updateManyAndReturn({
     *   select: { idAlerta: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends alertVenUpdateManyAndReturnArgs>(args: SelectSubset<T, alertVenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlertVen.
     * @param {alertVenUpsertArgs} args - Arguments to update or create a AlertVen.
     * @example
     * // Update or create a AlertVen
     * const alertVen = await prisma.alertVen.upsert({
     *   create: {
     *     // ... data to create a AlertVen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertVen we want to update
     *   }
     * })
     */
    upsert<T extends alertVenUpsertArgs>(args: SelectSubset<T, alertVenUpsertArgs<ExtArgs>>): Prisma__alertVenClient<$Result.GetResult<Prisma.$alertVenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlertVens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenCountArgs} args - Arguments to filter AlertVens to count.
     * @example
     * // Count the number of AlertVens
     * const count = await prisma.alertVen.count({
     *   where: {
     *     // ... the filter for the AlertVens we want to count
     *   }
     * })
    **/
    count<T extends alertVenCountArgs>(
      args?: Subset<T, alertVenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertVenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertVen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertVenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertVenAggregateArgs>(args: Subset<T, AlertVenAggregateArgs>): Prisma.PrismaPromise<GetAlertVenAggregateType<T>>

    /**
     * Group by AlertVen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertVenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alertVenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alertVenGroupByArgs['orderBy'] }
        : { orderBy?: alertVenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alertVenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertVenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alertVen model
   */
  readonly fields: alertVenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alertVen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alertVenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alertVen model
   */
  interface alertVenFieldRefs {
    readonly idAlerta: FieldRef<"alertVen", 'Int'>
    readonly idProducto: FieldRef<"alertVen", 'Int'>
    readonly fechaAlerta: FieldRef<"alertVen", 'DateTime'>
    readonly estado: FieldRef<"alertVen", 'EstadoRecordatorio'>
    readonly createdAt: FieldRef<"alertVen", 'DateTime'>
    readonly updatedAt: FieldRef<"alertVen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * alertVen findUnique
   */
  export type alertVenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter, which alertVen to fetch.
     */
    where: alertVenWhereUniqueInput
  }

  /**
   * alertVen findUniqueOrThrow
   */
  export type alertVenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter, which alertVen to fetch.
     */
    where: alertVenWhereUniqueInput
  }

  /**
   * alertVen findFirst
   */
  export type alertVenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter, which alertVen to fetch.
     */
    where?: alertVenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertVens to fetch.
     */
    orderBy?: alertVenOrderByWithRelationInput | alertVenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alertVens.
     */
    cursor?: alertVenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertVens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertVens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alertVens.
     */
    distinct?: AlertVenScalarFieldEnum | AlertVenScalarFieldEnum[]
  }

  /**
   * alertVen findFirstOrThrow
   */
  export type alertVenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter, which alertVen to fetch.
     */
    where?: alertVenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertVens to fetch.
     */
    orderBy?: alertVenOrderByWithRelationInput | alertVenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alertVens.
     */
    cursor?: alertVenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertVens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertVens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alertVens.
     */
    distinct?: AlertVenScalarFieldEnum | AlertVenScalarFieldEnum[]
  }

  /**
   * alertVen findMany
   */
  export type alertVenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter, which alertVens to fetch.
     */
    where?: alertVenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertVens to fetch.
     */
    orderBy?: alertVenOrderByWithRelationInput | alertVenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alertVens.
     */
    cursor?: alertVenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertVens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertVens.
     */
    skip?: number
    distinct?: AlertVenScalarFieldEnum | AlertVenScalarFieldEnum[]
  }

  /**
   * alertVen create
   */
  export type alertVenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * The data needed to create a alertVen.
     */
    data: XOR<alertVenCreateInput, alertVenUncheckedCreateInput>
  }

  /**
   * alertVen createMany
   */
  export type alertVenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alertVens.
     */
    data: alertVenCreateManyInput | alertVenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alertVen createManyAndReturn
   */
  export type alertVenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * The data used to create many alertVens.
     */
    data: alertVenCreateManyInput | alertVenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * alertVen update
   */
  export type alertVenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * The data needed to update a alertVen.
     */
    data: XOR<alertVenUpdateInput, alertVenUncheckedUpdateInput>
    /**
     * Choose, which alertVen to update.
     */
    where: alertVenWhereUniqueInput
  }

  /**
   * alertVen updateMany
   */
  export type alertVenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alertVens.
     */
    data: XOR<alertVenUpdateManyMutationInput, alertVenUncheckedUpdateManyInput>
    /**
     * Filter which alertVens to update
     */
    where?: alertVenWhereInput
    /**
     * Limit how many alertVens to update.
     */
    limit?: number
  }

  /**
   * alertVen updateManyAndReturn
   */
  export type alertVenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * The data used to update alertVens.
     */
    data: XOR<alertVenUpdateManyMutationInput, alertVenUncheckedUpdateManyInput>
    /**
     * Filter which alertVens to update
     */
    where?: alertVenWhereInput
    /**
     * Limit how many alertVens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * alertVen upsert
   */
  export type alertVenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * The filter to search for the alertVen to update in case it exists.
     */
    where: alertVenWhereUniqueInput
    /**
     * In case the alertVen found by the `where` argument doesn't exist, create a new alertVen with this data.
     */
    create: XOR<alertVenCreateInput, alertVenUncheckedCreateInput>
    /**
     * In case the alertVen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alertVenUpdateInput, alertVenUncheckedUpdateInput>
  }

  /**
   * alertVen delete
   */
  export type alertVenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
    /**
     * Filter which alertVen to delete.
     */
    where: alertVenWhereUniqueInput
  }

  /**
   * alertVen deleteMany
   */
  export type alertVenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alertVens to delete
     */
    where?: alertVenWhereInput
    /**
     * Limit how many alertVens to delete.
     */
    limit?: number
  }

  /**
   * alertVen without action
   */
  export type alertVenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertVen
     */
    select?: alertVenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alertVen
     */
    omit?: alertVenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertVenInclude<ExtArgs> | null
  }


  /**
   * Model analisisImagenes
   */

  export type AggregateAnalisisImagenes = {
    _count: AnalisisImagenesCountAggregateOutputType | null
    _avg: AnalisisImagenesAvgAggregateOutputType | null
    _sum: AnalisisImagenesSumAggregateOutputType | null
    _min: AnalisisImagenesMinAggregateOutputType | null
    _max: AnalisisImagenesMaxAggregateOutputType | null
  }

  export type AnalisisImagenesAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AnalisisImagenesSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AnalisisImagenesMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    esAlimento: boolean | null
    consulta: string | null
    fechaAnalisis: Date | null
  }

  export type AnalisisImagenesMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    esAlimento: boolean | null
    consulta: string | null
    fechaAnalisis: Date | null
  }

  export type AnalisisImagenesCountAggregateOutputType = {
    id: number
    usuarioId: number
    esAlimento: number
    consulta: number
    respuesta: number
    fechaAnalisis: number
    _all: number
  }


  export type AnalisisImagenesAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AnalisisImagenesSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AnalisisImagenesMinAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    fechaAnalisis?: true
  }

  export type AnalisisImagenesMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    fechaAnalisis?: true
  }

  export type AnalisisImagenesCountAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    respuesta?: true
    fechaAnalisis?: true
    _all?: true
  }

  export type AnalisisImagenesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisisImagenes to aggregate.
     */
    where?: analisisImagenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisisImagenes to fetch.
     */
    orderBy?: analisisImagenesOrderByWithRelationInput | analisisImagenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: analisisImagenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisisImagenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisisImagenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned analisisImagenes
    **/
    _count?: true | AnalisisImagenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalisisImagenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalisisImagenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalisisImagenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalisisImagenesMaxAggregateInputType
  }

  export type GetAnalisisImagenesAggregateType<T extends AnalisisImagenesAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalisisImagenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalisisImagenes[P]>
      : GetScalarType<T[P], AggregateAnalisisImagenes[P]>
  }




  export type analisisImagenesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: analisisImagenesWhereInput
    orderBy?: analisisImagenesOrderByWithAggregationInput | analisisImagenesOrderByWithAggregationInput[]
    by: AnalisisImagenesScalarFieldEnum[] | AnalisisImagenesScalarFieldEnum
    having?: analisisImagenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalisisImagenesCountAggregateInputType | true
    _avg?: AnalisisImagenesAvgAggregateInputType
    _sum?: AnalisisImagenesSumAggregateInputType
    _min?: AnalisisImagenesMinAggregateInputType
    _max?: AnalisisImagenesMaxAggregateInputType
  }

  export type AnalisisImagenesGroupByOutputType = {
    id: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonValue
    fechaAnalisis: Date
    _count: AnalisisImagenesCountAggregateOutputType | null
    _avg: AnalisisImagenesAvgAggregateOutputType | null
    _sum: AnalisisImagenesSumAggregateOutputType | null
    _min: AnalisisImagenesMinAggregateOutputType | null
    _max: AnalisisImagenesMaxAggregateOutputType | null
  }

  type GetAnalisisImagenesGroupByPayload<T extends analisisImagenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalisisImagenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalisisImagenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalisisImagenesGroupByOutputType[P]>
            : GetScalarType<T[P], AnalisisImagenesGroupByOutputType[P]>
        }
      >
    >


  export type analisisImagenesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    fechaAnalisis?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analisisImagenes"]>

  export type analisisImagenesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    fechaAnalisis?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analisisImagenes"]>

  export type analisisImagenesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    fechaAnalisis?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analisisImagenes"]>

  export type analisisImagenesSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    fechaAnalisis?: boolean
  }

  export type analisisImagenesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "esAlimento" | "consulta" | "respuesta" | "fechaAnalisis", ExtArgs["result"]["analisisImagenes"]>
  export type analisisImagenesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type analisisImagenesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type analisisImagenesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $analisisImagenesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "analisisImagenes"
    objects: {
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      esAlimento: boolean
      consulta: string
      respuesta: Prisma.JsonValue
      fechaAnalisis: Date
    }, ExtArgs["result"]["analisisImagenes"]>
    composites: {}
  }

  type analisisImagenesGetPayload<S extends boolean | null | undefined | analisisImagenesDefaultArgs> = $Result.GetResult<Prisma.$analisisImagenesPayload, S>

  type analisisImagenesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<analisisImagenesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalisisImagenesCountAggregateInputType | true
    }

  export interface analisisImagenesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['analisisImagenes'], meta: { name: 'analisisImagenes' } }
    /**
     * Find zero or one AnalisisImagenes that matches the filter.
     * @param {analisisImagenesFindUniqueArgs} args - Arguments to find a AnalisisImagenes
     * @example
     * // Get one AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends analisisImagenesFindUniqueArgs>(args: SelectSubset<T, analisisImagenesFindUniqueArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalisisImagenes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {analisisImagenesFindUniqueOrThrowArgs} args - Arguments to find a AnalisisImagenes
     * @example
     * // Get one AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends analisisImagenesFindUniqueOrThrowArgs>(args: SelectSubset<T, analisisImagenesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalisisImagenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesFindFirstArgs} args - Arguments to find a AnalisisImagenes
     * @example
     * // Get one AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends analisisImagenesFindFirstArgs>(args?: SelectSubset<T, analisisImagenesFindFirstArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalisisImagenes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesFindFirstOrThrowArgs} args - Arguments to find a AnalisisImagenes
     * @example
     * // Get one AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends analisisImagenesFindFirstOrThrowArgs>(args?: SelectSubset<T, analisisImagenesFindFirstOrThrowArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalisisImagenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findMany()
     * 
     * // Get first 10 AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analisisImagenesWithIdOnly = await prisma.analisisImagenes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends analisisImagenesFindManyArgs>(args?: SelectSubset<T, analisisImagenesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalisisImagenes.
     * @param {analisisImagenesCreateArgs} args - Arguments to create a AnalisisImagenes.
     * @example
     * // Create one AnalisisImagenes
     * const AnalisisImagenes = await prisma.analisisImagenes.create({
     *   data: {
     *     // ... data to create a AnalisisImagenes
     *   }
     * })
     * 
     */
    create<T extends analisisImagenesCreateArgs>(args: SelectSubset<T, analisisImagenesCreateArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalisisImagenes.
     * @param {analisisImagenesCreateManyArgs} args - Arguments to create many AnalisisImagenes.
     * @example
     * // Create many AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends analisisImagenesCreateManyArgs>(args?: SelectSubset<T, analisisImagenesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalisisImagenes and returns the data saved in the database.
     * @param {analisisImagenesCreateManyAndReturnArgs} args - Arguments to create many AnalisisImagenes.
     * @example
     * // Create many AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalisisImagenes and only return the `id`
     * const analisisImagenesWithIdOnly = await prisma.analisisImagenes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends analisisImagenesCreateManyAndReturnArgs>(args?: SelectSubset<T, analisisImagenesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalisisImagenes.
     * @param {analisisImagenesDeleteArgs} args - Arguments to delete one AnalisisImagenes.
     * @example
     * // Delete one AnalisisImagenes
     * const AnalisisImagenes = await prisma.analisisImagenes.delete({
     *   where: {
     *     // ... filter to delete one AnalisisImagenes
     *   }
     * })
     * 
     */
    delete<T extends analisisImagenesDeleteArgs>(args: SelectSubset<T, analisisImagenesDeleteArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalisisImagenes.
     * @param {analisisImagenesUpdateArgs} args - Arguments to update one AnalisisImagenes.
     * @example
     * // Update one AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends analisisImagenesUpdateArgs>(args: SelectSubset<T, analisisImagenesUpdateArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalisisImagenes.
     * @param {analisisImagenesDeleteManyArgs} args - Arguments to filter AnalisisImagenes to delete.
     * @example
     * // Delete a few AnalisisImagenes
     * const { count } = await prisma.analisisImagenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends analisisImagenesDeleteManyArgs>(args?: SelectSubset<T, analisisImagenesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalisisImagenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends analisisImagenesUpdateManyArgs>(args: SelectSubset<T, analisisImagenesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalisisImagenes and returns the data updated in the database.
     * @param {analisisImagenesUpdateManyAndReturnArgs} args - Arguments to update many AnalisisImagenes.
     * @example
     * // Update many AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalisisImagenes and only return the `id`
     * const analisisImagenesWithIdOnly = await prisma.analisisImagenes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends analisisImagenesUpdateManyAndReturnArgs>(args: SelectSubset<T, analisisImagenesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalisisImagenes.
     * @param {analisisImagenesUpsertArgs} args - Arguments to update or create a AnalisisImagenes.
     * @example
     * // Update or create a AnalisisImagenes
     * const analisisImagenes = await prisma.analisisImagenes.upsert({
     *   create: {
     *     // ... data to create a AnalisisImagenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalisisImagenes we want to update
     *   }
     * })
     */
    upsert<T extends analisisImagenesUpsertArgs>(args: SelectSubset<T, analisisImagenesUpsertArgs<ExtArgs>>): Prisma__analisisImagenesClient<$Result.GetResult<Prisma.$analisisImagenesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalisisImagenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesCountArgs} args - Arguments to filter AnalisisImagenes to count.
     * @example
     * // Count the number of AnalisisImagenes
     * const count = await prisma.analisisImagenes.count({
     *   where: {
     *     // ... the filter for the AnalisisImagenes we want to count
     *   }
     * })
    **/
    count<T extends analisisImagenesCountArgs>(
      args?: Subset<T, analisisImagenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalisisImagenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalisisImagenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalisisImagenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalisisImagenesAggregateArgs>(args: Subset<T, AnalisisImagenesAggregateArgs>): Prisma.PrismaPromise<GetAnalisisImagenesAggregateType<T>>

    /**
     * Group by AnalisisImagenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {analisisImagenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends analisisImagenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: analisisImagenesGroupByArgs['orderBy'] }
        : { orderBy?: analisisImagenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, analisisImagenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalisisImagenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the analisisImagenes model
   */
  readonly fields: analisisImagenesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for analisisImagenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__analisisImagenesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the analisisImagenes model
   */
  interface analisisImagenesFieldRefs {
    readonly id: FieldRef<"analisisImagenes", 'Int'>
    readonly usuarioId: FieldRef<"analisisImagenes", 'Int'>
    readonly esAlimento: FieldRef<"analisisImagenes", 'Boolean'>
    readonly consulta: FieldRef<"analisisImagenes", 'String'>
    readonly respuesta: FieldRef<"analisisImagenes", 'Json'>
    readonly fechaAnalisis: FieldRef<"analisisImagenes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * analisisImagenes findUnique
   */
  export type analisisImagenesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter, which analisisImagenes to fetch.
     */
    where: analisisImagenesWhereUniqueInput
  }

  /**
   * analisisImagenes findUniqueOrThrow
   */
  export type analisisImagenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter, which analisisImagenes to fetch.
     */
    where: analisisImagenesWhereUniqueInput
  }

  /**
   * analisisImagenes findFirst
   */
  export type analisisImagenesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter, which analisisImagenes to fetch.
     */
    where?: analisisImagenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisisImagenes to fetch.
     */
    orderBy?: analisisImagenesOrderByWithRelationInput | analisisImagenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisisImagenes.
     */
    cursor?: analisisImagenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisisImagenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisisImagenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisisImagenes.
     */
    distinct?: AnalisisImagenesScalarFieldEnum | AnalisisImagenesScalarFieldEnum[]
  }

  /**
   * analisisImagenes findFirstOrThrow
   */
  export type analisisImagenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter, which analisisImagenes to fetch.
     */
    where?: analisisImagenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisisImagenes to fetch.
     */
    orderBy?: analisisImagenesOrderByWithRelationInput | analisisImagenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for analisisImagenes.
     */
    cursor?: analisisImagenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisisImagenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisisImagenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of analisisImagenes.
     */
    distinct?: AnalisisImagenesScalarFieldEnum | AnalisisImagenesScalarFieldEnum[]
  }

  /**
   * analisisImagenes findMany
   */
  export type analisisImagenesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter, which analisisImagenes to fetch.
     */
    where?: analisisImagenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of analisisImagenes to fetch.
     */
    orderBy?: analisisImagenesOrderByWithRelationInput | analisisImagenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing analisisImagenes.
     */
    cursor?: analisisImagenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` analisisImagenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` analisisImagenes.
     */
    skip?: number
    distinct?: AnalisisImagenesScalarFieldEnum | AnalisisImagenesScalarFieldEnum[]
  }

  /**
   * analisisImagenes create
   */
  export type analisisImagenesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * The data needed to create a analisisImagenes.
     */
    data: XOR<analisisImagenesCreateInput, analisisImagenesUncheckedCreateInput>
  }

  /**
   * analisisImagenes createMany
   */
  export type analisisImagenesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many analisisImagenes.
     */
    data: analisisImagenesCreateManyInput | analisisImagenesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * analisisImagenes createManyAndReturn
   */
  export type analisisImagenesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * The data used to create many analisisImagenes.
     */
    data: analisisImagenesCreateManyInput | analisisImagenesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * analisisImagenes update
   */
  export type analisisImagenesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * The data needed to update a analisisImagenes.
     */
    data: XOR<analisisImagenesUpdateInput, analisisImagenesUncheckedUpdateInput>
    /**
     * Choose, which analisisImagenes to update.
     */
    where: analisisImagenesWhereUniqueInput
  }

  /**
   * analisisImagenes updateMany
   */
  export type analisisImagenesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update analisisImagenes.
     */
    data: XOR<analisisImagenesUpdateManyMutationInput, analisisImagenesUncheckedUpdateManyInput>
    /**
     * Filter which analisisImagenes to update
     */
    where?: analisisImagenesWhereInput
    /**
     * Limit how many analisisImagenes to update.
     */
    limit?: number
  }

  /**
   * analisisImagenes updateManyAndReturn
   */
  export type analisisImagenesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * The data used to update analisisImagenes.
     */
    data: XOR<analisisImagenesUpdateManyMutationInput, analisisImagenesUncheckedUpdateManyInput>
    /**
     * Filter which analisisImagenes to update
     */
    where?: analisisImagenesWhereInput
    /**
     * Limit how many analisisImagenes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * analisisImagenes upsert
   */
  export type analisisImagenesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * The filter to search for the analisisImagenes to update in case it exists.
     */
    where: analisisImagenesWhereUniqueInput
    /**
     * In case the analisisImagenes found by the `where` argument doesn't exist, create a new analisisImagenes with this data.
     */
    create: XOR<analisisImagenesCreateInput, analisisImagenesUncheckedCreateInput>
    /**
     * In case the analisisImagenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<analisisImagenesUpdateInput, analisisImagenesUncheckedUpdateInput>
  }

  /**
   * analisisImagenes delete
   */
  export type analisisImagenesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
    /**
     * Filter which analisisImagenes to delete.
     */
    where: analisisImagenesWhereUniqueInput
  }

  /**
   * analisisImagenes deleteMany
   */
  export type analisisImagenesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which analisisImagenes to delete
     */
    where?: analisisImagenesWhereInput
    /**
     * Limit how many analisisImagenes to delete.
     */
    limit?: number
  }

  /**
   * analisisImagenes without action
   */
  export type analisisImagenesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the analisisImagenes
     */
    select?: analisisImagenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the analisisImagenes
     */
    omit?: analisisImagenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: analisisImagenesInclude<ExtArgs> | null
  }


  /**
   * Model colaboraciones
   */

  export type AggregateColaboraciones = {
    _count: ColaboracionesCountAggregateOutputType | null
    _avg: ColaboracionesAvgAggregateOutputType | null
    _sum: ColaboracionesSumAggregateOutputType | null
    _min: ColaboracionesMinAggregateOutputType | null
    _max: ColaboracionesMaxAggregateOutputType | null
  }

  export type ColaboracionesAvgAggregateOutputType = {
    id: number | null
    productoId: number | null
    tarifa: Decimal | null
  }

  export type ColaboracionesSumAggregateOutputType = {
    id: number | null
    productoId: number | null
    tarifa: Decimal | null
  }

  export type ColaboracionesMinAggregateOutputType = {
    id: number | null
    productoId: number | null
    marca: string | null
    tarifa: Decimal | null
    fechaInicio: Date | null
    fechaFin: Date | null
  }

  export type ColaboracionesMaxAggregateOutputType = {
    id: number | null
    productoId: number | null
    marca: string | null
    tarifa: Decimal | null
    fechaInicio: Date | null
    fechaFin: Date | null
  }

  export type ColaboracionesCountAggregateOutputType = {
    id: number
    productoId: number
    marca: number
    tarifa: number
    fechaInicio: number
    fechaFin: number
    _all: number
  }


  export type ColaboracionesAvgAggregateInputType = {
    id?: true
    productoId?: true
    tarifa?: true
  }

  export type ColaboracionesSumAggregateInputType = {
    id?: true
    productoId?: true
    tarifa?: true
  }

  export type ColaboracionesMinAggregateInputType = {
    id?: true
    productoId?: true
    marca?: true
    tarifa?: true
    fechaInicio?: true
    fechaFin?: true
  }

  export type ColaboracionesMaxAggregateInputType = {
    id?: true
    productoId?: true
    marca?: true
    tarifa?: true
    fechaInicio?: true
    fechaFin?: true
  }

  export type ColaboracionesCountAggregateInputType = {
    id?: true
    productoId?: true
    marca?: true
    tarifa?: true
    fechaInicio?: true
    fechaFin?: true
    _all?: true
  }

  export type ColaboracionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which colaboraciones to aggregate.
     */
    where?: colaboracionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colaboraciones to fetch.
     */
    orderBy?: colaboracionesOrderByWithRelationInput | colaboracionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: colaboracionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colaboraciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colaboraciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned colaboraciones
    **/
    _count?: true | ColaboracionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColaboracionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColaboracionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColaboracionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColaboracionesMaxAggregateInputType
  }

  export type GetColaboracionesAggregateType<T extends ColaboracionesAggregateArgs> = {
        [P in keyof T & keyof AggregateColaboraciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColaboraciones[P]>
      : GetScalarType<T[P], AggregateColaboraciones[P]>
  }




  export type colaboracionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: colaboracionesWhereInput
    orderBy?: colaboracionesOrderByWithAggregationInput | colaboracionesOrderByWithAggregationInput[]
    by: ColaboracionesScalarFieldEnum[] | ColaboracionesScalarFieldEnum
    having?: colaboracionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColaboracionesCountAggregateInputType | true
    _avg?: ColaboracionesAvgAggregateInputType
    _sum?: ColaboracionesSumAggregateInputType
    _min?: ColaboracionesMinAggregateInputType
    _max?: ColaboracionesMaxAggregateInputType
  }

  export type ColaboracionesGroupByOutputType = {
    id: number
    productoId: number
    marca: string
    tarifa: Decimal
    fechaInicio: Date
    fechaFin: Date
    _count: ColaboracionesCountAggregateOutputType | null
    _avg: ColaboracionesAvgAggregateOutputType | null
    _sum: ColaboracionesSumAggregateOutputType | null
    _min: ColaboracionesMinAggregateOutputType | null
    _max: ColaboracionesMaxAggregateOutputType | null
  }

  type GetColaboracionesGroupByPayload<T extends colaboracionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColaboracionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColaboracionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColaboracionesGroupByOutputType[P]>
            : GetScalarType<T[P], ColaboracionesGroupByOutputType[P]>
        }
      >
    >


  export type colaboracionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    marca?: boolean
    tarifa?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colaboraciones"]>

  export type colaboracionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    marca?: boolean
    tarifa?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colaboraciones"]>

  export type colaboracionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    marca?: boolean
    tarifa?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["colaboraciones"]>

  export type colaboracionesSelectScalar = {
    id?: boolean
    productoId?: boolean
    marca?: boolean
    tarifa?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
  }

  export type colaboracionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productoId" | "marca" | "tarifa" | "fechaInicio" | "fechaFin", ExtArgs["result"]["colaboraciones"]>
  export type colaboracionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type colaboracionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type colaboracionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $colaboracionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "colaboraciones"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productoId: number
      marca: string
      tarifa: Prisma.Decimal
      fechaInicio: Date
      fechaFin: Date
    }, ExtArgs["result"]["colaboraciones"]>
    composites: {}
  }

  type colaboracionesGetPayload<S extends boolean | null | undefined | colaboracionesDefaultArgs> = $Result.GetResult<Prisma.$colaboracionesPayload, S>

  type colaboracionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<colaboracionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColaboracionesCountAggregateInputType | true
    }

  export interface colaboracionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['colaboraciones'], meta: { name: 'colaboraciones' } }
    /**
     * Find zero or one Colaboraciones that matches the filter.
     * @param {colaboracionesFindUniqueArgs} args - Arguments to find a Colaboraciones
     * @example
     * // Get one Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends colaboracionesFindUniqueArgs>(args: SelectSubset<T, colaboracionesFindUniqueArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Colaboraciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {colaboracionesFindUniqueOrThrowArgs} args - Arguments to find a Colaboraciones
     * @example
     * // Get one Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends colaboracionesFindUniqueOrThrowArgs>(args: SelectSubset<T, colaboracionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Colaboraciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesFindFirstArgs} args - Arguments to find a Colaboraciones
     * @example
     * // Get one Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends colaboracionesFindFirstArgs>(args?: SelectSubset<T, colaboracionesFindFirstArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Colaboraciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesFindFirstOrThrowArgs} args - Arguments to find a Colaboraciones
     * @example
     * // Get one Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends colaboracionesFindFirstOrThrowArgs>(args?: SelectSubset<T, colaboracionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colaboraciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findMany()
     * 
     * // Get first 10 Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colaboracionesWithIdOnly = await prisma.colaboraciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends colaboracionesFindManyArgs>(args?: SelectSubset<T, colaboracionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Colaboraciones.
     * @param {colaboracionesCreateArgs} args - Arguments to create a Colaboraciones.
     * @example
     * // Create one Colaboraciones
     * const Colaboraciones = await prisma.colaboraciones.create({
     *   data: {
     *     // ... data to create a Colaboraciones
     *   }
     * })
     * 
     */
    create<T extends colaboracionesCreateArgs>(args: SelectSubset<T, colaboracionesCreateArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colaboraciones.
     * @param {colaboracionesCreateManyArgs} args - Arguments to create many Colaboraciones.
     * @example
     * // Create many Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends colaboracionesCreateManyArgs>(args?: SelectSubset<T, colaboracionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colaboraciones and returns the data saved in the database.
     * @param {colaboracionesCreateManyAndReturnArgs} args - Arguments to create many Colaboraciones.
     * @example
     * // Create many Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colaboraciones and only return the `id`
     * const colaboracionesWithIdOnly = await prisma.colaboraciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends colaboracionesCreateManyAndReturnArgs>(args?: SelectSubset<T, colaboracionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Colaboraciones.
     * @param {colaboracionesDeleteArgs} args - Arguments to delete one Colaboraciones.
     * @example
     * // Delete one Colaboraciones
     * const Colaboraciones = await prisma.colaboraciones.delete({
     *   where: {
     *     // ... filter to delete one Colaboraciones
     *   }
     * })
     * 
     */
    delete<T extends colaboracionesDeleteArgs>(args: SelectSubset<T, colaboracionesDeleteArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Colaboraciones.
     * @param {colaboracionesUpdateArgs} args - Arguments to update one Colaboraciones.
     * @example
     * // Update one Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends colaboracionesUpdateArgs>(args: SelectSubset<T, colaboracionesUpdateArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colaboraciones.
     * @param {colaboracionesDeleteManyArgs} args - Arguments to filter Colaboraciones to delete.
     * @example
     * // Delete a few Colaboraciones
     * const { count } = await prisma.colaboraciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends colaboracionesDeleteManyArgs>(args?: SelectSubset<T, colaboracionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colaboraciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends colaboracionesUpdateManyArgs>(args: SelectSubset<T, colaboracionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colaboraciones and returns the data updated in the database.
     * @param {colaboracionesUpdateManyAndReturnArgs} args - Arguments to update many Colaboraciones.
     * @example
     * // Update many Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colaboraciones and only return the `id`
     * const colaboracionesWithIdOnly = await prisma.colaboraciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends colaboracionesUpdateManyAndReturnArgs>(args: SelectSubset<T, colaboracionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Colaboraciones.
     * @param {colaboracionesUpsertArgs} args - Arguments to update or create a Colaboraciones.
     * @example
     * // Update or create a Colaboraciones
     * const colaboraciones = await prisma.colaboraciones.upsert({
     *   create: {
     *     // ... data to create a Colaboraciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Colaboraciones we want to update
     *   }
     * })
     */
    upsert<T extends colaboracionesUpsertArgs>(args: SelectSubset<T, colaboracionesUpsertArgs<ExtArgs>>): Prisma__colaboracionesClient<$Result.GetResult<Prisma.$colaboracionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colaboraciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesCountArgs} args - Arguments to filter Colaboraciones to count.
     * @example
     * // Count the number of Colaboraciones
     * const count = await prisma.colaboraciones.count({
     *   where: {
     *     // ... the filter for the Colaboraciones we want to count
     *   }
     * })
    **/
    count<T extends colaboracionesCountArgs>(
      args?: Subset<T, colaboracionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColaboracionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Colaboraciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColaboracionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColaboracionesAggregateArgs>(args: Subset<T, ColaboracionesAggregateArgs>): Prisma.PrismaPromise<GetColaboracionesAggregateType<T>>

    /**
     * Group by Colaboraciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {colaboracionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends colaboracionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: colaboracionesGroupByArgs['orderBy'] }
        : { orderBy?: colaboracionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, colaboracionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColaboracionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the colaboraciones model
   */
  readonly fields: colaboracionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for colaboraciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__colaboracionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the colaboraciones model
   */
  interface colaboracionesFieldRefs {
    readonly id: FieldRef<"colaboraciones", 'Int'>
    readonly productoId: FieldRef<"colaboraciones", 'Int'>
    readonly marca: FieldRef<"colaboraciones", 'String'>
    readonly tarifa: FieldRef<"colaboraciones", 'Decimal'>
    readonly fechaInicio: FieldRef<"colaboraciones", 'DateTime'>
    readonly fechaFin: FieldRef<"colaboraciones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * colaboraciones findUnique
   */
  export type colaboracionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter, which colaboraciones to fetch.
     */
    where: colaboracionesWhereUniqueInput
  }

  /**
   * colaboraciones findUniqueOrThrow
   */
  export type colaboracionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter, which colaboraciones to fetch.
     */
    where: colaboracionesWhereUniqueInput
  }

  /**
   * colaboraciones findFirst
   */
  export type colaboracionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter, which colaboraciones to fetch.
     */
    where?: colaboracionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colaboraciones to fetch.
     */
    orderBy?: colaboracionesOrderByWithRelationInput | colaboracionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for colaboraciones.
     */
    cursor?: colaboracionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colaboraciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colaboraciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of colaboraciones.
     */
    distinct?: ColaboracionesScalarFieldEnum | ColaboracionesScalarFieldEnum[]
  }

  /**
   * colaboraciones findFirstOrThrow
   */
  export type colaboracionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter, which colaboraciones to fetch.
     */
    where?: colaboracionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colaboraciones to fetch.
     */
    orderBy?: colaboracionesOrderByWithRelationInput | colaboracionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for colaboraciones.
     */
    cursor?: colaboracionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colaboraciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colaboraciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of colaboraciones.
     */
    distinct?: ColaboracionesScalarFieldEnum | ColaboracionesScalarFieldEnum[]
  }

  /**
   * colaboraciones findMany
   */
  export type colaboracionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter, which colaboraciones to fetch.
     */
    where?: colaboracionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of colaboraciones to fetch.
     */
    orderBy?: colaboracionesOrderByWithRelationInput | colaboracionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing colaboraciones.
     */
    cursor?: colaboracionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` colaboraciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` colaboraciones.
     */
    skip?: number
    distinct?: ColaboracionesScalarFieldEnum | ColaboracionesScalarFieldEnum[]
  }

  /**
   * colaboraciones create
   */
  export type colaboracionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * The data needed to create a colaboraciones.
     */
    data: XOR<colaboracionesCreateInput, colaboracionesUncheckedCreateInput>
  }

  /**
   * colaboraciones createMany
   */
  export type colaboracionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many colaboraciones.
     */
    data: colaboracionesCreateManyInput | colaboracionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * colaboraciones createManyAndReturn
   */
  export type colaboracionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * The data used to create many colaboraciones.
     */
    data: colaboracionesCreateManyInput | colaboracionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * colaboraciones update
   */
  export type colaboracionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * The data needed to update a colaboraciones.
     */
    data: XOR<colaboracionesUpdateInput, colaboracionesUncheckedUpdateInput>
    /**
     * Choose, which colaboraciones to update.
     */
    where: colaboracionesWhereUniqueInput
  }

  /**
   * colaboraciones updateMany
   */
  export type colaboracionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update colaboraciones.
     */
    data: XOR<colaboracionesUpdateManyMutationInput, colaboracionesUncheckedUpdateManyInput>
    /**
     * Filter which colaboraciones to update
     */
    where?: colaboracionesWhereInput
    /**
     * Limit how many colaboraciones to update.
     */
    limit?: number
  }

  /**
   * colaboraciones updateManyAndReturn
   */
  export type colaboracionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * The data used to update colaboraciones.
     */
    data: XOR<colaboracionesUpdateManyMutationInput, colaboracionesUncheckedUpdateManyInput>
    /**
     * Filter which colaboraciones to update
     */
    where?: colaboracionesWhereInput
    /**
     * Limit how many colaboraciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * colaboraciones upsert
   */
  export type colaboracionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * The filter to search for the colaboraciones to update in case it exists.
     */
    where: colaboracionesWhereUniqueInput
    /**
     * In case the colaboraciones found by the `where` argument doesn't exist, create a new colaboraciones with this data.
     */
    create: XOR<colaboracionesCreateInput, colaboracionesUncheckedCreateInput>
    /**
     * In case the colaboraciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<colaboracionesUpdateInput, colaboracionesUncheckedUpdateInput>
  }

  /**
   * colaboraciones delete
   */
  export type colaboracionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
    /**
     * Filter which colaboraciones to delete.
     */
    where: colaboracionesWhereUniqueInput
  }

  /**
   * colaboraciones deleteMany
   */
  export type colaboracionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which colaboraciones to delete
     */
    where?: colaboracionesWhereInput
    /**
     * Limit how many colaboraciones to delete.
     */
    limit?: number
  }

  /**
   * colaboraciones without action
   */
  export type colaboracionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the colaboraciones
     */
    select?: colaboracionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the colaboraciones
     */
    omit?: colaboracionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: colaboracionesInclude<ExtArgs> | null
  }


  /**
   * Model histInv
   */

  export type AggregateHistInv = {
    _count: HistInvCountAggregateOutputType | null
    _avg: HistInvAvgAggregateOutputType | null
    _sum: HistInvSumAggregateOutputType | null
    _min: HistInvMinAggregateOutputType | null
    _max: HistInvMaxAggregateOutputType | null
  }

  export type HistInvAvgAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
  }

  export type HistInvSumAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
  }

  export type HistInvMinAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    accion: $Enums.AccionHistorial | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
    fechaCambio: Date | null
  }

  export type HistInvMaxAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    accion: $Enums.AccionHistorial | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
    fechaCambio: Date | null
  }

  export type HistInvCountAggregateOutputType = {
    id: number
    productoId: number
    usuarioId: number
    accion: number
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: number
    precio_nuevo: number
    fechaCambio: number
    _all: number
  }


  export type HistInvAvgAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
  }

  export type HistInvSumAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
  }

  export type HistInvMinAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
  }

  export type HistInvMaxAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
  }

  export type HistInvCountAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
    _all?: true
  }

  export type HistInvAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histInv to aggregate.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned histInvs
    **/
    _count?: true | HistInvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistInvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistInvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistInvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistInvMaxAggregateInputType
  }

  export type GetHistInvAggregateType<T extends HistInvAggregateArgs> = {
        [P in keyof T & keyof AggregateHistInv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistInv[P]>
      : GetScalarType<T[P], AggregateHistInv[P]>
  }




  export type histInvGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithAggregationInput | histInvOrderByWithAggregationInput[]
    by: HistInvScalarFieldEnum[] | HistInvScalarFieldEnum
    having?: histInvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistInvCountAggregateInputType | true
    _avg?: HistInvAvgAggregateInputType
    _sum?: HistInvSumAggregateInputType
    _min?: HistInvMinAggregateInputType
    _max?: HistInvMaxAggregateInputType
  }

  export type HistInvGroupByOutputType = {
    id: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal
    precio_nuevo: Decimal
    fechaCambio: Date
    _count: HistInvCountAggregateOutputType | null
    _avg: HistInvAvgAggregateOutputType | null
    _sum: HistInvSumAggregateOutputType | null
    _min: HistInvMinAggregateOutputType | null
    _max: HistInvMaxAggregateOutputType | null
  }

  type GetHistInvGroupByPayload<T extends histInvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistInvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistInvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistInvGroupByOutputType[P]>
            : GetScalarType<T[P], HistInvGroupByOutputType[P]>
        }
      >
    >


  export type histInvSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectScalar = {
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
  }

  export type histInvOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productoId" | "usuarioId" | "accion" | "cantidad_anterior" | "cantidad_nueva" | "precio_anterior" | "precio_nuevo" | "fechaCambio", ExtArgs["result"]["histInv"]>
  export type histInvInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type histInvIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type histInvIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $histInvPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "histInv"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productoId: number
      usuarioId: number
      accion: $Enums.AccionHistorial
      cantidad_anterior: number
      cantidad_nueva: number
      precio_anterior: Prisma.Decimal
      precio_nuevo: Prisma.Decimal
      fechaCambio: Date
    }, ExtArgs["result"]["histInv"]>
    composites: {}
  }

  type histInvGetPayload<S extends boolean | null | undefined | histInvDefaultArgs> = $Result.GetResult<Prisma.$histInvPayload, S>

  type histInvCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<histInvFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistInvCountAggregateInputType | true
    }

  export interface histInvDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['histInv'], meta: { name: 'histInv' } }
    /**
     * Find zero or one HistInv that matches the filter.
     * @param {histInvFindUniqueArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends histInvFindUniqueArgs>(args: SelectSubset<T, histInvFindUniqueArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistInv that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {histInvFindUniqueOrThrowArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends histInvFindUniqueOrThrowArgs>(args: SelectSubset<T, histInvFindUniqueOrThrowArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistInv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindFirstArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends histInvFindFirstArgs>(args?: SelectSubset<T, histInvFindFirstArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistInv that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindFirstOrThrowArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends histInvFindFirstOrThrowArgs>(args?: SelectSubset<T, histInvFindFirstOrThrowArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistInvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistInvs
     * const histInvs = await prisma.histInv.findMany()
     * 
     * // Get first 10 HistInvs
     * const histInvs = await prisma.histInv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const histInvWithIdOnly = await prisma.histInv.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends histInvFindManyArgs>(args?: SelectSubset<T, histInvFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistInv.
     * @param {histInvCreateArgs} args - Arguments to create a HistInv.
     * @example
     * // Create one HistInv
     * const HistInv = await prisma.histInv.create({
     *   data: {
     *     // ... data to create a HistInv
     *   }
     * })
     * 
     */
    create<T extends histInvCreateArgs>(args: SelectSubset<T, histInvCreateArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistInvs.
     * @param {histInvCreateManyArgs} args - Arguments to create many HistInvs.
     * @example
     * // Create many HistInvs
     * const histInv = await prisma.histInv.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends histInvCreateManyArgs>(args?: SelectSubset<T, histInvCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistInvs and returns the data saved in the database.
     * @param {histInvCreateManyAndReturnArgs} args - Arguments to create many HistInvs.
     * @example
     * // Create many HistInvs
     * const histInv = await prisma.histInv.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistInvs and only return the `id`
     * const histInvWithIdOnly = await prisma.histInv.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends histInvCreateManyAndReturnArgs>(args?: SelectSubset<T, histInvCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistInv.
     * @param {histInvDeleteArgs} args - Arguments to delete one HistInv.
     * @example
     * // Delete one HistInv
     * const HistInv = await prisma.histInv.delete({
     *   where: {
     *     // ... filter to delete one HistInv
     *   }
     * })
     * 
     */
    delete<T extends histInvDeleteArgs>(args: SelectSubset<T, histInvDeleteArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistInv.
     * @param {histInvUpdateArgs} args - Arguments to update one HistInv.
     * @example
     * // Update one HistInv
     * const histInv = await prisma.histInv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends histInvUpdateArgs>(args: SelectSubset<T, histInvUpdateArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistInvs.
     * @param {histInvDeleteManyArgs} args - Arguments to filter HistInvs to delete.
     * @example
     * // Delete a few HistInvs
     * const { count } = await prisma.histInv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends histInvDeleteManyArgs>(args?: SelectSubset<T, histInvDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistInvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistInvs
     * const histInv = await prisma.histInv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends histInvUpdateManyArgs>(args: SelectSubset<T, histInvUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistInvs and returns the data updated in the database.
     * @param {histInvUpdateManyAndReturnArgs} args - Arguments to update many HistInvs.
     * @example
     * // Update many HistInvs
     * const histInv = await prisma.histInv.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistInvs and only return the `id`
     * const histInvWithIdOnly = await prisma.histInv.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends histInvUpdateManyAndReturnArgs>(args: SelectSubset<T, histInvUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistInv.
     * @param {histInvUpsertArgs} args - Arguments to update or create a HistInv.
     * @example
     * // Update or create a HistInv
     * const histInv = await prisma.histInv.upsert({
     *   create: {
     *     // ... data to create a HistInv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistInv we want to update
     *   }
     * })
     */
    upsert<T extends histInvUpsertArgs>(args: SelectSubset<T, histInvUpsertArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistInvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvCountArgs} args - Arguments to filter HistInvs to count.
     * @example
     * // Count the number of HistInvs
     * const count = await prisma.histInv.count({
     *   where: {
     *     // ... the filter for the HistInvs we want to count
     *   }
     * })
    **/
    count<T extends histInvCountArgs>(
      args?: Subset<T, histInvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistInvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistInv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistInvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistInvAggregateArgs>(args: Subset<T, HistInvAggregateArgs>): Prisma.PrismaPromise<GetHistInvAggregateType<T>>

    /**
     * Group by HistInv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends histInvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: histInvGroupByArgs['orderBy'] }
        : { orderBy?: histInvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, histInvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistInvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the histInv model
   */
  readonly fields: histInvFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for histInv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__histInvClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the histInv model
   */
  interface histInvFieldRefs {
    readonly id: FieldRef<"histInv", 'Int'>
    readonly productoId: FieldRef<"histInv", 'Int'>
    readonly usuarioId: FieldRef<"histInv", 'Int'>
    readonly accion: FieldRef<"histInv", 'AccionHistorial'>
    readonly cantidad_anterior: FieldRef<"histInv", 'Int'>
    readonly cantidad_nueva: FieldRef<"histInv", 'Int'>
    readonly precio_anterior: FieldRef<"histInv", 'Decimal'>
    readonly precio_nuevo: FieldRef<"histInv", 'Decimal'>
    readonly fechaCambio: FieldRef<"histInv", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * histInv findUnique
   */
  export type histInvFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv findUniqueOrThrow
   */
  export type histInvFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv findFirst
   */
  export type histInvFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histInvs.
     */
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv findFirstOrThrow
   */
  export type histInvFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histInvs.
     */
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv findMany
   */
  export type histInvFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInvs to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv create
   */
  export type histInvCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The data needed to create a histInv.
     */
    data: XOR<histInvCreateInput, histInvUncheckedCreateInput>
  }

  /**
   * histInv createMany
   */
  export type histInvCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many histInvs.
     */
    data: histInvCreateManyInput | histInvCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * histInv createManyAndReturn
   */
  export type histInvCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * The data used to create many histInvs.
     */
    data: histInvCreateManyInput | histInvCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * histInv update
   */
  export type histInvUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The data needed to update a histInv.
     */
    data: XOR<histInvUpdateInput, histInvUncheckedUpdateInput>
    /**
     * Choose, which histInv to update.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv updateMany
   */
  export type histInvUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update histInvs.
     */
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyInput>
    /**
     * Filter which histInvs to update
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to update.
     */
    limit?: number
  }

  /**
   * histInv updateManyAndReturn
   */
  export type histInvUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * The data used to update histInvs.
     */
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyInput>
    /**
     * Filter which histInvs to update
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * histInv upsert
   */
  export type histInvUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The filter to search for the histInv to update in case it exists.
     */
    where: histInvWhereUniqueInput
    /**
     * In case the histInv found by the `where` argument doesn't exist, create a new histInv with this data.
     */
    create: XOR<histInvCreateInput, histInvUncheckedCreateInput>
    /**
     * In case the histInv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<histInvUpdateInput, histInvUncheckedUpdateInput>
  }

  /**
   * histInv delete
   */
  export type histInvDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter which histInv to delete.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv deleteMany
   */
  export type histInvDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histInvs to delete
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to delete.
     */
    limit?: number
  }

  /**
   * histInv without action
   */
  export type histInvDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
  }


  /**
   * Model api_logs
   */

  export type AggregateApi_logs = {
    _count: Api_logsCountAggregateOutputType | null
    _avg: Api_logsAvgAggregateOutputType | null
    _sum: Api_logsSumAggregateOutputType | null
    _min: Api_logsMinAggregateOutputType | null
    _max: Api_logsMaxAggregateOutputType | null
  }

  export type Api_logsAvgAggregateOutputType = {
    id: number | null
    statusCode: number | null
    tiempoRespuesta: Decimal | null
    usuarioId: number | null
  }

  export type Api_logsSumAggregateOutputType = {
    id: number | null
    statusCode: number | null
    tiempoRespuesta: Decimal | null
    usuarioId: number | null
  }

  export type Api_logsMinAggregateOutputType = {
    id: number | null
    endpoint: string | null
    metodo: $Enums.MetodoAPI | null
    statusCode: number | null
    tiempoRespuesta: Decimal | null
    fecha: Date | null
    errorMensaje: string | null
    usuarioId: number | null
  }

  export type Api_logsMaxAggregateOutputType = {
    id: number | null
    endpoint: string | null
    metodo: $Enums.MetodoAPI | null
    statusCode: number | null
    tiempoRespuesta: Decimal | null
    fecha: Date | null
    errorMensaje: string | null
    usuarioId: number | null
  }

  export type Api_logsCountAggregateOutputType = {
    id: number
    endpoint: number
    metodo: number
    statusCode: number
    tiempoRespuesta: number
    fecha: number
    errorMensaje: number
    usuarioId: number
    _all: number
  }


  export type Api_logsAvgAggregateInputType = {
    id?: true
    statusCode?: true
    tiempoRespuesta?: true
    usuarioId?: true
  }

  export type Api_logsSumAggregateInputType = {
    id?: true
    statusCode?: true
    tiempoRespuesta?: true
    usuarioId?: true
  }

  export type Api_logsMinAggregateInputType = {
    id?: true
    endpoint?: true
    metodo?: true
    statusCode?: true
    tiempoRespuesta?: true
    fecha?: true
    errorMensaje?: true
    usuarioId?: true
  }

  export type Api_logsMaxAggregateInputType = {
    id?: true
    endpoint?: true
    metodo?: true
    statusCode?: true
    tiempoRespuesta?: true
    fecha?: true
    errorMensaje?: true
    usuarioId?: true
  }

  export type Api_logsCountAggregateInputType = {
    id?: true
    endpoint?: true
    metodo?: true
    statusCode?: true
    tiempoRespuesta?: true
    fecha?: true
    errorMensaje?: true
    usuarioId?: true
    _all?: true
  }

  export type Api_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_logs to aggregate.
     */
    where?: api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_logs to fetch.
     */
    orderBy?: api_logsOrderByWithRelationInput | api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_logs
    **/
    _count?: true | Api_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Api_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Api_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_logsMaxAggregateInputType
  }

  export type GetApi_logsAggregateType<T extends Api_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_logs[P]>
      : GetScalarType<T[P], AggregateApi_logs[P]>
  }




  export type api_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_logsWhereInput
    orderBy?: api_logsOrderByWithAggregationInput | api_logsOrderByWithAggregationInput[]
    by: Api_logsScalarFieldEnum[] | Api_logsScalarFieldEnum
    having?: api_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_logsCountAggregateInputType | true
    _avg?: Api_logsAvgAggregateInputType
    _sum?: Api_logsSumAggregateInputType
    _min?: Api_logsMinAggregateInputType
    _max?: Api_logsMaxAggregateInputType
  }

  export type Api_logsGroupByOutputType = {
    id: number
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal
    fecha: Date
    errorMensaje: string
    usuarioId: number
    _count: Api_logsCountAggregateOutputType | null
    _avg: Api_logsAvgAggregateOutputType | null
    _sum: Api_logsSumAggregateOutputType | null
    _min: Api_logsMinAggregateOutputType | null
    _max: Api_logsMaxAggregateOutputType | null
  }

  type GetApi_logsGroupByPayload<T extends api_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Api_logsGroupByOutputType[P]>
        }
      >
    >


  export type api_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    metodo?: boolean
    statusCode?: boolean
    tiempoRespuesta?: boolean
    fecha?: boolean
    errorMensaje?: boolean
    usuarioId?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["api_logs"]>

  export type api_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    metodo?: boolean
    statusCode?: boolean
    tiempoRespuesta?: boolean
    fecha?: boolean
    errorMensaje?: boolean
    usuarioId?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["api_logs"]>

  export type api_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endpoint?: boolean
    metodo?: boolean
    statusCode?: boolean
    tiempoRespuesta?: boolean
    fecha?: boolean
    errorMensaje?: boolean
    usuarioId?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["api_logs"]>

  export type api_logsSelectScalar = {
    id?: boolean
    endpoint?: boolean
    metodo?: boolean
    statusCode?: boolean
    tiempoRespuesta?: boolean
    fecha?: boolean
    errorMensaje?: boolean
    usuarioId?: boolean
  }

  export type api_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "endpoint" | "metodo" | "statusCode" | "tiempoRespuesta" | "fecha" | "errorMensaje" | "usuarioId", ExtArgs["result"]["api_logs"]>
  export type api_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type api_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type api_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $api_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "api_logs"
    objects: {
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      endpoint: string
      metodo: $Enums.MetodoAPI
      statusCode: number
      tiempoRespuesta: Prisma.Decimal
      fecha: Date
      errorMensaje: string
      usuarioId: number
    }, ExtArgs["result"]["api_logs"]>
    composites: {}
  }

  type api_logsGetPayload<S extends boolean | null | undefined | api_logsDefaultArgs> = $Result.GetResult<Prisma.$api_logsPayload, S>

  type api_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<api_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Api_logsCountAggregateInputType | true
    }

  export interface api_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_logs'], meta: { name: 'api_logs' } }
    /**
     * Find zero or one Api_logs that matches the filter.
     * @param {api_logsFindUniqueArgs} args - Arguments to find a Api_logs
     * @example
     * // Get one Api_logs
     * const api_logs = await prisma.api_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends api_logsFindUniqueArgs>(args: SelectSubset<T, api_logsFindUniqueArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Api_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {api_logsFindUniqueOrThrowArgs} args - Arguments to find a Api_logs
     * @example
     * // Get one Api_logs
     * const api_logs = await prisma.api_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends api_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, api_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsFindFirstArgs} args - Arguments to find a Api_logs
     * @example
     * // Get one Api_logs
     * const api_logs = await prisma.api_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends api_logsFindFirstArgs>(args?: SelectSubset<T, api_logsFindFirstArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsFindFirstOrThrowArgs} args - Arguments to find a Api_logs
     * @example
     * // Get one Api_logs
     * const api_logs = await prisma.api_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends api_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, api_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Api_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_logs
     * const api_logs = await prisma.api_logs.findMany()
     * 
     * // Get first 10 Api_logs
     * const api_logs = await prisma.api_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const api_logsWithIdOnly = await prisma.api_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends api_logsFindManyArgs>(args?: SelectSubset<T, api_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Api_logs.
     * @param {api_logsCreateArgs} args - Arguments to create a Api_logs.
     * @example
     * // Create one Api_logs
     * const Api_logs = await prisma.api_logs.create({
     *   data: {
     *     // ... data to create a Api_logs
     *   }
     * })
     * 
     */
    create<T extends api_logsCreateArgs>(args: SelectSubset<T, api_logsCreateArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Api_logs.
     * @param {api_logsCreateManyArgs} args - Arguments to create many Api_logs.
     * @example
     * // Create many Api_logs
     * const api_logs = await prisma.api_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends api_logsCreateManyArgs>(args?: SelectSubset<T, api_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Api_logs and returns the data saved in the database.
     * @param {api_logsCreateManyAndReturnArgs} args - Arguments to create many Api_logs.
     * @example
     * // Create many Api_logs
     * const api_logs = await prisma.api_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Api_logs and only return the `id`
     * const api_logsWithIdOnly = await prisma.api_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends api_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, api_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Api_logs.
     * @param {api_logsDeleteArgs} args - Arguments to delete one Api_logs.
     * @example
     * // Delete one Api_logs
     * const Api_logs = await prisma.api_logs.delete({
     *   where: {
     *     // ... filter to delete one Api_logs
     *   }
     * })
     * 
     */
    delete<T extends api_logsDeleteArgs>(args: SelectSubset<T, api_logsDeleteArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Api_logs.
     * @param {api_logsUpdateArgs} args - Arguments to update one Api_logs.
     * @example
     * // Update one Api_logs
     * const api_logs = await prisma.api_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends api_logsUpdateArgs>(args: SelectSubset<T, api_logsUpdateArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Api_logs.
     * @param {api_logsDeleteManyArgs} args - Arguments to filter Api_logs to delete.
     * @example
     * // Delete a few Api_logs
     * const { count } = await prisma.api_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends api_logsDeleteManyArgs>(args?: SelectSubset<T, api_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_logs
     * const api_logs = await prisma.api_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends api_logsUpdateManyArgs>(args: SelectSubset<T, api_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_logs and returns the data updated in the database.
     * @param {api_logsUpdateManyAndReturnArgs} args - Arguments to update many Api_logs.
     * @example
     * // Update many Api_logs
     * const api_logs = await prisma.api_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Api_logs and only return the `id`
     * const api_logsWithIdOnly = await prisma.api_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends api_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, api_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Api_logs.
     * @param {api_logsUpsertArgs} args - Arguments to update or create a Api_logs.
     * @example
     * // Update or create a Api_logs
     * const api_logs = await prisma.api_logs.upsert({
     *   create: {
     *     // ... data to create a Api_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_logs we want to update
     *   }
     * })
     */
    upsert<T extends api_logsUpsertArgs>(args: SelectSubset<T, api_logsUpsertArgs<ExtArgs>>): Prisma__api_logsClient<$Result.GetResult<Prisma.$api_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsCountArgs} args - Arguments to filter Api_logs to count.
     * @example
     * // Count the number of Api_logs
     * const count = await prisma.api_logs.count({
     *   where: {
     *     // ... the filter for the Api_logs we want to count
     *   }
     * })
    **/
    count<T extends api_logsCountArgs>(
      args?: Subset<T, api_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_logsAggregateArgs>(args: Subset<T, Api_logsAggregateArgs>): Prisma.PrismaPromise<GetApi_logsAggregateType<T>>

    /**
     * Group by Api_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_logsGroupByArgs['orderBy'] }
        : { orderBy?: api_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_logs model
   */
  readonly fields: api_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__api_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the api_logs model
   */
  interface api_logsFieldRefs {
    readonly id: FieldRef<"api_logs", 'Int'>
    readonly endpoint: FieldRef<"api_logs", 'String'>
    readonly metodo: FieldRef<"api_logs", 'MetodoAPI'>
    readonly statusCode: FieldRef<"api_logs", 'Int'>
    readonly tiempoRespuesta: FieldRef<"api_logs", 'Decimal'>
    readonly fecha: FieldRef<"api_logs", 'DateTime'>
    readonly errorMensaje: FieldRef<"api_logs", 'String'>
    readonly usuarioId: FieldRef<"api_logs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * api_logs findUnique
   */
  export type api_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter, which api_logs to fetch.
     */
    where: api_logsWhereUniqueInput
  }

  /**
   * api_logs findUniqueOrThrow
   */
  export type api_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter, which api_logs to fetch.
     */
    where: api_logsWhereUniqueInput
  }

  /**
   * api_logs findFirst
   */
  export type api_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter, which api_logs to fetch.
     */
    where?: api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_logs to fetch.
     */
    orderBy?: api_logsOrderByWithRelationInput | api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_logs.
     */
    cursor?: api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_logs.
     */
    distinct?: Api_logsScalarFieldEnum | Api_logsScalarFieldEnum[]
  }

  /**
   * api_logs findFirstOrThrow
   */
  export type api_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter, which api_logs to fetch.
     */
    where?: api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_logs to fetch.
     */
    orderBy?: api_logsOrderByWithRelationInput | api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_logs.
     */
    cursor?: api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_logs.
     */
    distinct?: Api_logsScalarFieldEnum | Api_logsScalarFieldEnum[]
  }

  /**
   * api_logs findMany
   */
  export type api_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter, which api_logs to fetch.
     */
    where?: api_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_logs to fetch.
     */
    orderBy?: api_logsOrderByWithRelationInput | api_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_logs.
     */
    cursor?: api_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_logs.
     */
    skip?: number
    distinct?: Api_logsScalarFieldEnum | Api_logsScalarFieldEnum[]
  }

  /**
   * api_logs create
   */
  export type api_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a api_logs.
     */
    data: XOR<api_logsCreateInput, api_logsUncheckedCreateInput>
  }

  /**
   * api_logs createMany
   */
  export type api_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_logs.
     */
    data: api_logsCreateManyInput | api_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_logs createManyAndReturn
   */
  export type api_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * The data used to create many api_logs.
     */
    data: api_logsCreateManyInput | api_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * api_logs update
   */
  export type api_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a api_logs.
     */
    data: XOR<api_logsUpdateInput, api_logsUncheckedUpdateInput>
    /**
     * Choose, which api_logs to update.
     */
    where: api_logsWhereUniqueInput
  }

  /**
   * api_logs updateMany
   */
  export type api_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_logs.
     */
    data: XOR<api_logsUpdateManyMutationInput, api_logsUncheckedUpdateManyInput>
    /**
     * Filter which api_logs to update
     */
    where?: api_logsWhereInput
    /**
     * Limit how many api_logs to update.
     */
    limit?: number
  }

  /**
   * api_logs updateManyAndReturn
   */
  export type api_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * The data used to update api_logs.
     */
    data: XOR<api_logsUpdateManyMutationInput, api_logsUncheckedUpdateManyInput>
    /**
     * Filter which api_logs to update
     */
    where?: api_logsWhereInput
    /**
     * Limit how many api_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * api_logs upsert
   */
  export type api_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the api_logs to update in case it exists.
     */
    where: api_logsWhereUniqueInput
    /**
     * In case the api_logs found by the `where` argument doesn't exist, create a new api_logs with this data.
     */
    create: XOR<api_logsCreateInput, api_logsUncheckedCreateInput>
    /**
     * In case the api_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_logsUpdateInput, api_logsUncheckedUpdateInput>
  }

  /**
   * api_logs delete
   */
  export type api_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
    /**
     * Filter which api_logs to delete.
     */
    where: api_logsWhereUniqueInput
  }

  /**
   * api_logs deleteMany
   */
  export type api_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_logs to delete
     */
    where?: api_logsWhereInput
    /**
     * Limit how many api_logs to delete.
     */
    limit?: number
  }

  /**
   * api_logs without action
   */
  export type api_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_logs
     */
    select?: api_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_logs
     */
    omit?: api_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: api_logsInclude<ExtArgs> | null
  }


  /**
   * Model MonAudRend
   */

  export type AggregateMonAudRend = {
    _count: MonAudRendCountAggregateOutputType | null
    _avg: MonAudRendAvgAggregateOutputType | null
    _sum: MonAudRendSumAggregateOutputType | null
    _min: MonAudRendMinAggregateOutputType | null
    _max: MonAudRendMaxAggregateOutputType | null
  }

  export type MonAudRendAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type MonAudRendSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    valor: Decimal | null
  }

  export type MonAudRendMinAggregateOutputType = {
    id: number | null
    tipoEvento: $Enums.TipoEvento | null
    nombreEvento: string | null
    descripcion: string | null
    usuarioId: number | null
    fecha: Date | null
    ip_address: string | null
    nivel: string | null
    valor: Decimal | null
    stackTrace: string | null
  }

  export type MonAudRendMaxAggregateOutputType = {
    id: number | null
    tipoEvento: $Enums.TipoEvento | null
    nombreEvento: string | null
    descripcion: string | null
    usuarioId: number | null
    fecha: Date | null
    ip_address: string | null
    nivel: string | null
    valor: Decimal | null
    stackTrace: string | null
  }

  export type MonAudRendCountAggregateOutputType = {
    id: number
    tipoEvento: number
    nombreEvento: number
    descripcion: number
    usuarioId: number
    fecha: number
    ip_address: number
    nivel: number
    valor: number
    stackTrace: number
    _all: number
  }


  export type MonAudRendAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type MonAudRendSumAggregateInputType = {
    id?: true
    usuarioId?: true
    valor?: true
  }

  export type MonAudRendMinAggregateInputType = {
    id?: true
    tipoEvento?: true
    nombreEvento?: true
    descripcion?: true
    usuarioId?: true
    fecha?: true
    ip_address?: true
    nivel?: true
    valor?: true
    stackTrace?: true
  }

  export type MonAudRendMaxAggregateInputType = {
    id?: true
    tipoEvento?: true
    nombreEvento?: true
    descripcion?: true
    usuarioId?: true
    fecha?: true
    ip_address?: true
    nivel?: true
    valor?: true
    stackTrace?: true
  }

  export type MonAudRendCountAggregateInputType = {
    id?: true
    tipoEvento?: true
    nombreEvento?: true
    descripcion?: true
    usuarioId?: true
    fecha?: true
    ip_address?: true
    nivel?: true
    valor?: true
    stackTrace?: true
    _all?: true
  }

  export type MonAudRendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonAudRend to aggregate.
     */
    where?: MonAudRendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonAudRends to fetch.
     */
    orderBy?: MonAudRendOrderByWithRelationInput | MonAudRendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonAudRendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonAudRends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonAudRends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonAudRends
    **/
    _count?: true | MonAudRendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonAudRendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonAudRendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonAudRendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonAudRendMaxAggregateInputType
  }

  export type GetMonAudRendAggregateType<T extends MonAudRendAggregateArgs> = {
        [P in keyof T & keyof AggregateMonAudRend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonAudRend[P]>
      : GetScalarType<T[P], AggregateMonAudRend[P]>
  }




  export type MonAudRendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonAudRendWhereInput
    orderBy?: MonAudRendOrderByWithAggregationInput | MonAudRendOrderByWithAggregationInput[]
    by: MonAudRendScalarFieldEnum[] | MonAudRendScalarFieldEnum
    having?: MonAudRendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonAudRendCountAggregateInputType | true
    _avg?: MonAudRendAvgAggregateInputType
    _sum?: MonAudRendSumAggregateInputType
    _min?: MonAudRendMinAggregateInputType
    _max?: MonAudRendMaxAggregateInputType
  }

  export type MonAudRendGroupByOutputType = {
    id: number
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    usuarioId: number
    fecha: Date
    ip_address: string
    nivel: string
    valor: Decimal
    stackTrace: string
    _count: MonAudRendCountAggregateOutputType | null
    _avg: MonAudRendAvgAggregateOutputType | null
    _sum: MonAudRendSumAggregateOutputType | null
    _min: MonAudRendMinAggregateOutputType | null
    _max: MonAudRendMaxAggregateOutputType | null
  }

  type GetMonAudRendGroupByPayload<T extends MonAudRendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonAudRendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonAudRendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonAudRendGroupByOutputType[P]>
            : GetScalarType<T[P], MonAudRendGroupByOutputType[P]>
        }
      >
    >


  export type MonAudRendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoEvento?: boolean
    nombreEvento?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    fecha?: boolean
    ip_address?: boolean
    nivel?: boolean
    valor?: boolean
    stackTrace?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monAudRend"]>

  export type MonAudRendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoEvento?: boolean
    nombreEvento?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    fecha?: boolean
    ip_address?: boolean
    nivel?: boolean
    valor?: boolean
    stackTrace?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monAudRend"]>

  export type MonAudRendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoEvento?: boolean
    nombreEvento?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    fecha?: boolean
    ip_address?: boolean
    nivel?: boolean
    valor?: boolean
    stackTrace?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monAudRend"]>

  export type MonAudRendSelectScalar = {
    id?: boolean
    tipoEvento?: boolean
    nombreEvento?: boolean
    descripcion?: boolean
    usuarioId?: boolean
    fecha?: boolean
    ip_address?: boolean
    nivel?: boolean
    valor?: boolean
    stackTrace?: boolean
  }

  export type MonAudRendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoEvento" | "nombreEvento" | "descripcion" | "usuarioId" | "fecha" | "ip_address" | "nivel" | "valor" | "stackTrace", ExtArgs["result"]["monAudRend"]>
  export type MonAudRendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type MonAudRendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type MonAudRendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $MonAudRendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonAudRend"
    objects: {
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoEvento: $Enums.TipoEvento
      nombreEvento: string
      descripcion: string
      usuarioId: number
      fecha: Date
      ip_address: string
      nivel: string
      valor: Prisma.Decimal
      stackTrace: string
    }, ExtArgs["result"]["monAudRend"]>
    composites: {}
  }

  type MonAudRendGetPayload<S extends boolean | null | undefined | MonAudRendDefaultArgs> = $Result.GetResult<Prisma.$MonAudRendPayload, S>

  type MonAudRendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MonAudRendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MonAudRendCountAggregateInputType | true
    }

  export interface MonAudRendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonAudRend'], meta: { name: 'MonAudRend' } }
    /**
     * Find zero or one MonAudRend that matches the filter.
     * @param {MonAudRendFindUniqueArgs} args - Arguments to find a MonAudRend
     * @example
     * // Get one MonAudRend
     * const monAudRend = await prisma.monAudRend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonAudRendFindUniqueArgs>(args: SelectSubset<T, MonAudRendFindUniqueArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MonAudRend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MonAudRendFindUniqueOrThrowArgs} args - Arguments to find a MonAudRend
     * @example
     * // Get one MonAudRend
     * const monAudRend = await prisma.monAudRend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonAudRendFindUniqueOrThrowArgs>(args: SelectSubset<T, MonAudRendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonAudRend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendFindFirstArgs} args - Arguments to find a MonAudRend
     * @example
     * // Get one MonAudRend
     * const monAudRend = await prisma.monAudRend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonAudRendFindFirstArgs>(args?: SelectSubset<T, MonAudRendFindFirstArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MonAudRend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendFindFirstOrThrowArgs} args - Arguments to find a MonAudRend
     * @example
     * // Get one MonAudRend
     * const monAudRend = await prisma.monAudRend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonAudRendFindFirstOrThrowArgs>(args?: SelectSubset<T, MonAudRendFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MonAudRends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonAudRends
     * const monAudRends = await prisma.monAudRend.findMany()
     * 
     * // Get first 10 MonAudRends
     * const monAudRends = await prisma.monAudRend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monAudRendWithIdOnly = await prisma.monAudRend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonAudRendFindManyArgs>(args?: SelectSubset<T, MonAudRendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MonAudRend.
     * @param {MonAudRendCreateArgs} args - Arguments to create a MonAudRend.
     * @example
     * // Create one MonAudRend
     * const MonAudRend = await prisma.monAudRend.create({
     *   data: {
     *     // ... data to create a MonAudRend
     *   }
     * })
     * 
     */
    create<T extends MonAudRendCreateArgs>(args: SelectSubset<T, MonAudRendCreateArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MonAudRends.
     * @param {MonAudRendCreateManyArgs} args - Arguments to create many MonAudRends.
     * @example
     * // Create many MonAudRends
     * const monAudRend = await prisma.monAudRend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonAudRendCreateManyArgs>(args?: SelectSubset<T, MonAudRendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonAudRends and returns the data saved in the database.
     * @param {MonAudRendCreateManyAndReturnArgs} args - Arguments to create many MonAudRends.
     * @example
     * // Create many MonAudRends
     * const monAudRend = await prisma.monAudRend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonAudRends and only return the `id`
     * const monAudRendWithIdOnly = await prisma.monAudRend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonAudRendCreateManyAndReturnArgs>(args?: SelectSubset<T, MonAudRendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MonAudRend.
     * @param {MonAudRendDeleteArgs} args - Arguments to delete one MonAudRend.
     * @example
     * // Delete one MonAudRend
     * const MonAudRend = await prisma.monAudRend.delete({
     *   where: {
     *     // ... filter to delete one MonAudRend
     *   }
     * })
     * 
     */
    delete<T extends MonAudRendDeleteArgs>(args: SelectSubset<T, MonAudRendDeleteArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MonAudRend.
     * @param {MonAudRendUpdateArgs} args - Arguments to update one MonAudRend.
     * @example
     * // Update one MonAudRend
     * const monAudRend = await prisma.monAudRend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonAudRendUpdateArgs>(args: SelectSubset<T, MonAudRendUpdateArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MonAudRends.
     * @param {MonAudRendDeleteManyArgs} args - Arguments to filter MonAudRends to delete.
     * @example
     * // Delete a few MonAudRends
     * const { count } = await prisma.monAudRend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonAudRendDeleteManyArgs>(args?: SelectSubset<T, MonAudRendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonAudRends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonAudRends
     * const monAudRend = await prisma.monAudRend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonAudRendUpdateManyArgs>(args: SelectSubset<T, MonAudRendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonAudRends and returns the data updated in the database.
     * @param {MonAudRendUpdateManyAndReturnArgs} args - Arguments to update many MonAudRends.
     * @example
     * // Update many MonAudRends
     * const monAudRend = await prisma.monAudRend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MonAudRends and only return the `id`
     * const monAudRendWithIdOnly = await prisma.monAudRend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MonAudRendUpdateManyAndReturnArgs>(args: SelectSubset<T, MonAudRendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MonAudRend.
     * @param {MonAudRendUpsertArgs} args - Arguments to update or create a MonAudRend.
     * @example
     * // Update or create a MonAudRend
     * const monAudRend = await prisma.monAudRend.upsert({
     *   create: {
     *     // ... data to create a MonAudRend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonAudRend we want to update
     *   }
     * })
     */
    upsert<T extends MonAudRendUpsertArgs>(args: SelectSubset<T, MonAudRendUpsertArgs<ExtArgs>>): Prisma__MonAudRendClient<$Result.GetResult<Prisma.$MonAudRendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MonAudRends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendCountArgs} args - Arguments to filter MonAudRends to count.
     * @example
     * // Count the number of MonAudRends
     * const count = await prisma.monAudRend.count({
     *   where: {
     *     // ... the filter for the MonAudRends we want to count
     *   }
     * })
    **/
    count<T extends MonAudRendCountArgs>(
      args?: Subset<T, MonAudRendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonAudRendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonAudRend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonAudRendAggregateArgs>(args: Subset<T, MonAudRendAggregateArgs>): Prisma.PrismaPromise<GetMonAudRendAggregateType<T>>

    /**
     * Group by MonAudRend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonAudRendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonAudRendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonAudRendGroupByArgs['orderBy'] }
        : { orderBy?: MonAudRendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonAudRendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonAudRendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonAudRend model
   */
  readonly fields: MonAudRendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonAudRend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonAudRendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonAudRend model
   */
  interface MonAudRendFieldRefs {
    readonly id: FieldRef<"MonAudRend", 'Int'>
    readonly tipoEvento: FieldRef<"MonAudRend", 'TipoEvento'>
    readonly nombreEvento: FieldRef<"MonAudRend", 'String'>
    readonly descripcion: FieldRef<"MonAudRend", 'String'>
    readonly usuarioId: FieldRef<"MonAudRend", 'Int'>
    readonly fecha: FieldRef<"MonAudRend", 'DateTime'>
    readonly ip_address: FieldRef<"MonAudRend", 'String'>
    readonly nivel: FieldRef<"MonAudRend", 'String'>
    readonly valor: FieldRef<"MonAudRend", 'Decimal'>
    readonly stackTrace: FieldRef<"MonAudRend", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MonAudRend findUnique
   */
  export type MonAudRendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter, which MonAudRend to fetch.
     */
    where: MonAudRendWhereUniqueInput
  }

  /**
   * MonAudRend findUniqueOrThrow
   */
  export type MonAudRendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter, which MonAudRend to fetch.
     */
    where: MonAudRendWhereUniqueInput
  }

  /**
   * MonAudRend findFirst
   */
  export type MonAudRendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter, which MonAudRend to fetch.
     */
    where?: MonAudRendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonAudRends to fetch.
     */
    orderBy?: MonAudRendOrderByWithRelationInput | MonAudRendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonAudRends.
     */
    cursor?: MonAudRendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonAudRends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonAudRends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonAudRends.
     */
    distinct?: MonAudRendScalarFieldEnum | MonAudRendScalarFieldEnum[]
  }

  /**
   * MonAudRend findFirstOrThrow
   */
  export type MonAudRendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter, which MonAudRend to fetch.
     */
    where?: MonAudRendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonAudRends to fetch.
     */
    orderBy?: MonAudRendOrderByWithRelationInput | MonAudRendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonAudRends.
     */
    cursor?: MonAudRendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonAudRends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonAudRends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonAudRends.
     */
    distinct?: MonAudRendScalarFieldEnum | MonAudRendScalarFieldEnum[]
  }

  /**
   * MonAudRend findMany
   */
  export type MonAudRendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter, which MonAudRends to fetch.
     */
    where?: MonAudRendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonAudRends to fetch.
     */
    orderBy?: MonAudRendOrderByWithRelationInput | MonAudRendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonAudRends.
     */
    cursor?: MonAudRendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonAudRends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonAudRends.
     */
    skip?: number
    distinct?: MonAudRendScalarFieldEnum | MonAudRendScalarFieldEnum[]
  }

  /**
   * MonAudRend create
   */
  export type MonAudRendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * The data needed to create a MonAudRend.
     */
    data: XOR<MonAudRendCreateInput, MonAudRendUncheckedCreateInput>
  }

  /**
   * MonAudRend createMany
   */
  export type MonAudRendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonAudRends.
     */
    data: MonAudRendCreateManyInput | MonAudRendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonAudRend createManyAndReturn
   */
  export type MonAudRendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * The data used to create many MonAudRends.
     */
    data: MonAudRendCreateManyInput | MonAudRendCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonAudRend update
   */
  export type MonAudRendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * The data needed to update a MonAudRend.
     */
    data: XOR<MonAudRendUpdateInput, MonAudRendUncheckedUpdateInput>
    /**
     * Choose, which MonAudRend to update.
     */
    where: MonAudRendWhereUniqueInput
  }

  /**
   * MonAudRend updateMany
   */
  export type MonAudRendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonAudRends.
     */
    data: XOR<MonAudRendUpdateManyMutationInput, MonAudRendUncheckedUpdateManyInput>
    /**
     * Filter which MonAudRends to update
     */
    where?: MonAudRendWhereInput
    /**
     * Limit how many MonAudRends to update.
     */
    limit?: number
  }

  /**
   * MonAudRend updateManyAndReturn
   */
  export type MonAudRendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * The data used to update MonAudRends.
     */
    data: XOR<MonAudRendUpdateManyMutationInput, MonAudRendUncheckedUpdateManyInput>
    /**
     * Filter which MonAudRends to update
     */
    where?: MonAudRendWhereInput
    /**
     * Limit how many MonAudRends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonAudRend upsert
   */
  export type MonAudRendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * The filter to search for the MonAudRend to update in case it exists.
     */
    where: MonAudRendWhereUniqueInput
    /**
     * In case the MonAudRend found by the `where` argument doesn't exist, create a new MonAudRend with this data.
     */
    create: XOR<MonAudRendCreateInput, MonAudRendUncheckedCreateInput>
    /**
     * In case the MonAudRend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonAudRendUpdateInput, MonAudRendUncheckedUpdateInput>
  }

  /**
   * MonAudRend delete
   */
  export type MonAudRendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
    /**
     * Filter which MonAudRend to delete.
     */
    where: MonAudRendWhereUniqueInput
  }

  /**
   * MonAudRend deleteMany
   */
  export type MonAudRendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonAudRends to delete
     */
    where?: MonAudRendWhereInput
    /**
     * Limit how many MonAudRends to delete.
     */
    limit?: number
  }

  /**
   * MonAudRend without action
   */
  export type MonAudRendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonAudRend
     */
    select?: MonAudRendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MonAudRend
     */
    omit?: MonAudRendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonAudRendInclude<ExtArgs> | null
  }


  /**
   * Model auditoria
   */

  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuditoriaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuditoriaMinAggregateOutputType = {
    id: number | null
    evento: string | null
    usuarioId: number | null
    descripcion: string | null
    fecha: Date | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    id: number | null
    evento: string | null
    usuarioId: number | null
    descripcion: string | null
    fecha: Date | null
  }

  export type AuditoriaCountAggregateOutputType = {
    id: number
    evento: number
    usuarioId: number
    descripcion: number
    fecha: number
    _all: number
  }


  export type AuditoriaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuditoriaSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuditoriaMinAggregateInputType = {
    id?: true
    evento?: true
    usuarioId?: true
    descripcion?: true
    fecha?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    id?: true
    evento?: true
    usuarioId?: true
    descripcion?: true
    fecha?: true
  }

  export type AuditoriaCountAggregateInputType = {
    id?: true
    evento?: true
    usuarioId?: true
    descripcion?: true
    fecha?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditoria to aggregate.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type auditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithAggregationInput | auditoriaOrderByWithAggregationInput[]
    by: AuditoriaScalarFieldEnum[] | AuditoriaScalarFieldEnum
    having?: auditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _avg?: AuditoriaAvgAggregateInputType
    _sum?: AuditoriaSumAggregateInputType
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }

  export type AuditoriaGroupByOutputType = {
    id: number
    evento: string
    usuarioId: number
    descripcion: string
    fecha: Date
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends auditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type auditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evento?: boolean
    usuarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evento?: boolean
    usuarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evento?: boolean
    usuarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectScalar = {
    id?: boolean
    evento?: boolean
    usuarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
  }

  export type auditoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "evento" | "usuarioId" | "descripcion" | "fecha", ExtArgs["result"]["auditoria"]>
  export type auditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type auditoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $auditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditoria"
    objects: {
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      evento: string
      usuarioId: number
      descripcion: string
      fecha: Date
    }, ExtArgs["result"]["auditoria"]>
    composites: {}
  }

  type auditoriaGetPayload<S extends boolean | null | undefined | auditoriaDefaultArgs> = $Result.GetResult<Prisma.$auditoriaPayload, S>

  type auditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditoriaCountAggregateInputType | true
    }

  export interface auditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditoria'], meta: { name: 'auditoria' } }
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {auditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditoriaFindUniqueArgs>(args: SelectSubset<T, auditoriaFindUniqueArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, auditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditoriaFindFirstArgs>(args?: SelectSubset<T, auditoriaFindFirstArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, auditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditoriaFindManyArgs>(args?: SelectSubset<T, auditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditoria.
     * @param {auditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
     */
    create<T extends auditoriaCreateArgs>(args: SelectSubset<T, auditoriaCreateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditorias.
     * @param {auditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditoriaCreateManyArgs>(args?: SelectSubset<T, auditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditorias and returns the data saved in the database.
     * @param {auditoriaCreateManyAndReturnArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, auditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditoria.
     * @param {auditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
     */
    delete<T extends auditoriaDeleteArgs>(args: SelectSubset<T, auditoriaDeleteArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditoria.
     * @param {auditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditoriaUpdateArgs>(args: SelectSubset<T, auditoriaUpdateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditorias.
     * @param {auditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditoriaDeleteManyArgs>(args?: SelectSubset<T, auditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditoriaUpdateManyArgs>(args: SelectSubset<T, auditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias and returns the data updated in the database.
     * @param {auditoriaUpdateManyAndReturnArgs} args - Arguments to update many Auditorias.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, auditoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditoria.
     * @param {auditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
     */
    upsert<T extends auditoriaUpsertArgs>(args: SelectSubset<T, auditoriaUpsertArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends auditoriaCountArgs>(
      args?: Subset<T, auditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): Prisma.PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditoriaGroupByArgs['orderBy'] }
        : { orderBy?: auditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditoria model
   */
  readonly fields: auditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditoria model
   */
  interface auditoriaFieldRefs {
    readonly id: FieldRef<"auditoria", 'Int'>
    readonly evento: FieldRef<"auditoria", 'String'>
    readonly usuarioId: FieldRef<"auditoria", 'Int'>
    readonly descripcion: FieldRef<"auditoria", 'String'>
    readonly fecha: FieldRef<"auditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auditoria findUnique
   */
  export type auditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findUniqueOrThrow
   */
  export type auditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findFirst
   */
  export type auditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findFirstOrThrow
   */
  export type auditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findMany
   */
  export type auditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditorias to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria create
   */
  export type auditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a auditoria.
     */
    data: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
  }

  /**
   * auditoria createMany
   */
  export type auditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditoria createManyAndReturn
   */
  export type auditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria update
   */
  export type auditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a auditoria.
     */
    data: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
    /**
     * Choose, which auditoria to update.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria updateMany
   */
  export type auditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
  }

  /**
   * auditoria updateManyAndReturn
   */
  export type auditoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria upsert
   */
  export type auditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the auditoria to update in case it exists.
     */
    where: auditoriaWhereUniqueInput
    /**
     * In case the auditoria found by the `where` argument doesn't exist, create a new auditoria with this data.
     */
    create: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
    /**
     * In case the auditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
  }

  /**
   * auditoria delete
   */
  export type auditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter which auditoria to delete.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria deleteMany
   */
  export type auditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditorias to delete
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to delete.
     */
    limit?: number
  }

  /**
   * auditoria without action
   */
  export type auditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    idUsuario: 'idUsuario',
    username: 'username',
    correo: 'correo',
    password: 'password',
    nombreCompleto: 'nombreCompleto',
    telefono: 'telefono',
    direccion: 'direccion',
    fotoPerfil: 'fotoPerfil',
    nombreEmpresa: 'nombreEmpresa',
    nit: 'nit',
    estado: 'estado',
    rol: 'rol',
    rolEquipo: 'rolEquipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    tipoUsuario: 'tipoUsuario'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const AuteRestScalarFieldEnum: {
    idSeguridad: 'idSeguridad',
    idUsuario: 'idUsuario',
    googleId: 'googleId',
    token: 'token',
    fechaSolicitud: 'fechaSolicitud',
    fechaExpiracion: 'fechaExpiracion',
    usado: 'usado',
    confirmado: 'confirmado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuteRestScalarFieldEnum = (typeof AuteRestScalarFieldEnum)[keyof typeof AuteRestScalarFieldEnum]


  export const NotificacionesScalarFieldEnum: {
    idNotificacion: 'idNotificacion',
    idUsuario: 'idUsuario',
    tipo: 'tipo',
    titulo: 'titulo',
    mensaje: 'mensaje',
    fechaEnvio: 'fechaEnvio',
    leida: 'leida'
  };

  export type NotificacionesScalarFieldEnum = (typeof NotificacionesScalarFieldEnum)[keyof typeof NotificacionesScalarFieldEnum]


  export const ProductosScalarFieldEnum: {
    id: 'id',
    codigoBarras: 'codigoBarras',
    codigoQR: 'codigoQR',
    nombre: 'nombre',
    descripcion: 'descripcion',
    categoriaId: 'categoriaId',
    cantidad: 'cantidad',
    precio: 'precio',
    fechaAdquisicion: 'fechaAdquisicion',
    fechaVencimiento: 'fechaVencimiento',
    usuarioId: 'usuarioId',
    estado: 'estado',
    imagen: 'imagen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    eliminadoEn: 'eliminadoEn'
  };

  export type ProductosScalarFieldEnum = (typeof ProductosScalarFieldEnum)[keyof typeof ProductosScalarFieldEnum]


  export const HistoVentaScalarFieldEnum: {
    idVenta: 'idVenta',
    idProducto: 'idProducto',
    cantidadVendida: 'cantidadVendida',
    fechaVenta: 'fechaVenta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HistoVentaScalarFieldEnum = (typeof HistoVentaScalarFieldEnum)[keyof typeof HistoVentaScalarFieldEnum]


  export const RecorStockScalarFieldEnum: {
    idRecordatorio: 'idRecordatorio',
    idProducto: 'idProducto',
    cantidadMinima: 'cantidadMinima',
    fechaRecordatorio: 'fechaRecordatorio',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecorStockScalarFieldEnum = (typeof RecorStockScalarFieldEnum)[keyof typeof RecorStockScalarFieldEnum]


  export const ComentariosScalarFieldEnum: {
    idComentario: 'idComentario',
    idUsuario: 'idUsuario',
    comentario: 'comentario',
    fechaComentario: 'fechaComentario',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComentariosScalarFieldEnum = (typeof ComentariosScalarFieldEnum)[keyof typeof ComentariosScalarFieldEnum]


  export const SoporteScalarFieldEnum: {
    idSoporte: 'idSoporte',
    idUsuario: 'idUsuario',
    asunto: 'asunto',
    descripcion: 'descripcion',
    estado: 'estado',
    respuesta: 'respuesta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SoporteScalarFieldEnum = (typeof SoporteScalarFieldEnum)[keyof typeof SoporteScalarFieldEnum]


  export const AjustInvenScalarFieldEnum: {
    idAjuste: 'idAjuste',
    idProducto: 'idProducto',
    idUsuario: 'idUsuario',
    cantidadAnterior: 'cantidadAnterior',
    cantidadNueva: 'cantidadNueva',
    motivo: 'motivo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AjustInvenScalarFieldEnum = (typeof AjustInvenScalarFieldEnum)[keyof typeof AjustInvenScalarFieldEnum]


  export const AlertVenScalarFieldEnum: {
    idAlerta: 'idAlerta',
    idProducto: 'idProducto',
    fechaAlerta: 'fechaAlerta',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertVenScalarFieldEnum = (typeof AlertVenScalarFieldEnum)[keyof typeof AlertVenScalarFieldEnum]


  export const AnalisisImagenesScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    esAlimento: 'esAlimento',
    consulta: 'consulta',
    respuesta: 'respuesta',
    fechaAnalisis: 'fechaAnalisis'
  };

  export type AnalisisImagenesScalarFieldEnum = (typeof AnalisisImagenesScalarFieldEnum)[keyof typeof AnalisisImagenesScalarFieldEnum]


  export const ColaboracionesScalarFieldEnum: {
    id: 'id',
    productoId: 'productoId',
    marca: 'marca',
    tarifa: 'tarifa',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin'
  };

  export type ColaboracionesScalarFieldEnum = (typeof ColaboracionesScalarFieldEnum)[keyof typeof ColaboracionesScalarFieldEnum]


  export const HistInvScalarFieldEnum: {
    id: 'id',
    productoId: 'productoId',
    usuarioId: 'usuarioId',
    accion: 'accion',
    cantidad_anterior: 'cantidad_anterior',
    cantidad_nueva: 'cantidad_nueva',
    precio_anterior: 'precio_anterior',
    precio_nuevo: 'precio_nuevo',
    fechaCambio: 'fechaCambio'
  };

  export type HistInvScalarFieldEnum = (typeof HistInvScalarFieldEnum)[keyof typeof HistInvScalarFieldEnum]


  export const Api_logsScalarFieldEnum: {
    id: 'id',
    endpoint: 'endpoint',
    metodo: 'metodo',
    statusCode: 'statusCode',
    tiempoRespuesta: 'tiempoRespuesta',
    fecha: 'fecha',
    errorMensaje: 'errorMensaje',
    usuarioId: 'usuarioId'
  };

  export type Api_logsScalarFieldEnum = (typeof Api_logsScalarFieldEnum)[keyof typeof Api_logsScalarFieldEnum]


  export const MonAudRendScalarFieldEnum: {
    id: 'id',
    tipoEvento: 'tipoEvento',
    nombreEvento: 'nombreEvento',
    descripcion: 'descripcion',
    usuarioId: 'usuarioId',
    fecha: 'fecha',
    ip_address: 'ip_address',
    nivel: 'nivel',
    valor: 'valor',
    stackTrace: 'stackTrace'
  };

  export type MonAudRendScalarFieldEnum = (typeof MonAudRendScalarFieldEnum)[keyof typeof MonAudRendScalarFieldEnum]


  export const AuditoriaScalarFieldEnum: {
    id: 'id',
    evento: 'evento',
    usuarioId: 'usuarioId',
    descripcion: 'descripcion',
    fecha: 'fecha'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'rolEquipo'
   */
  export type EnumrolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rolEquipo'>
    


  /**
   * Reference to a field of type 'rolEquipo[]'
   */
  export type ListEnumrolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rolEquipo[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipoUsuario'
   */
  export type EnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario'>
    


  /**
   * Reference to a field of type 'TipoUsuario[]'
   */
  export type ListEnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TipoNotificacion'
   */
  export type EnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion'>
    


  /**
   * Reference to a field of type 'TipoNotificacion[]'
   */
  export type ListEnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EstadoRecordatorio'
   */
  export type EnumEstadoRecordatorioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoRecordatorio'>
    


  /**
   * Reference to a field of type 'EstadoRecordatorio[]'
   */
  export type ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoRecordatorio[]'>
    


  /**
   * Reference to a field of type 'EstadoComentario'
   */
  export type EnumEstadoComentarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoComentario'>
    


  /**
   * Reference to a field of type 'EstadoComentario[]'
   */
  export type ListEnumEstadoComentarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoComentario[]'>
    


  /**
   * Reference to a field of type 'EstadoSoporte'
   */
  export type EnumEstadoSoporteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSoporte'>
    


  /**
   * Reference to a field of type 'EstadoSoporte[]'
   */
  export type ListEnumEstadoSoporteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSoporte[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AccionHistorial'
   */
  export type EnumAccionHistorialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionHistorial'>
    


  /**
   * Reference to a field of type 'AccionHistorial[]'
   */
  export type ListEnumAccionHistorialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionHistorial[]'>
    


  /**
   * Reference to a field of type 'MetodoAPI'
   */
  export type EnumMetodoAPIFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoAPI'>
    


  /**
   * Reference to a field of type 'MetodoAPI[]'
   */
  export type ListEnumMetodoAPIFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoAPI[]'>
    


  /**
   * Reference to a field of type 'TipoEvento'
   */
  export type EnumTipoEventoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEvento'>
    


  /**
   * Reference to a field of type 'TipoEvento[]'
   */
  export type ListEnumTipoEventoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEvento[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    idUsuario?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    correo?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    nombreCompleto?: StringFilter<"users"> | string
    telefono?: StringFilter<"users"> | string
    direccion?: StringFilter<"users"> | string
    fotoPerfil?: StringFilter<"users"> | string
    nombreEmpresa?: StringNullableFilter<"users"> | string | null
    nit?: StringNullableFilter<"users"> | string | null
    estado?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    rolEquipo?: EnumrolEquipoNullableFilter<"users"> | $Enums.rolEquipo | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFilter<"users"> | $Enums.TipoUsuario
    MonAudRend?: MonAudRendListRelationFilter
    ajustInven?: AjustInvenListRelationFilter
    analisisImagenes?: AnalisisImagenesListRelationFilter
    api_logs?: Api_logsListRelationFilter
    auditoria?: AuditoriaListRelationFilter
    auteRest?: XOR<AuteRestNullableScalarRelationFilter, auteRestWhereInput> | null
    comentarios?: ComentariosListRelationFilter
    histInv?: HistInvListRelationFilter
    notificaciones?: NotificacionesListRelationFilter
    productos?: ProductosListRelationFilter
    soporte?: SoporteListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    estado?: SortOrder
    rol?: SortOrder
    rolEquipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    MonAudRend?: MonAudRendOrderByRelationAggregateInput
    ajustInven?: ajustInvenOrderByRelationAggregateInput
    analisisImagenes?: analisisImagenesOrderByRelationAggregateInput
    api_logs?: api_logsOrderByRelationAggregateInput
    auditoria?: auditoriaOrderByRelationAggregateInput
    auteRest?: auteRestOrderByWithRelationInput
    comentarios?: comentariosOrderByRelationAggregateInput
    histInv?: histInvOrderByRelationAggregateInput
    notificaciones?: notificacionesOrderByRelationAggregateInput
    productos?: productosOrderByRelationAggregateInput
    soporte?: soporteOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    idUsuario?: number
    username?: string
    correo?: string
    nit?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    nombreCompleto?: StringFilter<"users"> | string
    telefono?: StringFilter<"users"> | string
    direccion?: StringFilter<"users"> | string
    fotoPerfil?: StringFilter<"users"> | string
    nombreEmpresa?: StringNullableFilter<"users"> | string | null
    estado?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    rolEquipo?: EnumrolEquipoNullableFilter<"users"> | $Enums.rolEquipo | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFilter<"users"> | $Enums.TipoUsuario
    MonAudRend?: MonAudRendListRelationFilter
    ajustInven?: AjustInvenListRelationFilter
    analisisImagenes?: AnalisisImagenesListRelationFilter
    api_logs?: Api_logsListRelationFilter
    auditoria?: AuditoriaListRelationFilter
    auteRest?: XOR<AuteRestNullableScalarRelationFilter, auteRestWhereInput> | null
    comentarios?: ComentariosListRelationFilter
    histInv?: HistInvListRelationFilter
    notificaciones?: NotificacionesListRelationFilter
    productos?: ProductosListRelationFilter
    soporte?: SoporteListRelationFilter
  }, "idUsuario" | "username" | "correo" | "nit">

  export type usersOrderByWithAggregationInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    estado?: SortOrder
    rol?: SortOrder
    rolEquipo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    idUsuario?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    correo?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    nombreCompleto?: StringWithAggregatesFilter<"users"> | string
    telefono?: StringWithAggregatesFilter<"users"> | string
    direccion?: StringWithAggregatesFilter<"users"> | string
    fotoPerfil?: StringWithAggregatesFilter<"users"> | string
    nombreEmpresa?: StringNullableWithAggregatesFilter<"users"> | string | null
    nit?: StringNullableWithAggregatesFilter<"users"> | string | null
    estado?: StringWithAggregatesFilter<"users"> | string
    rol?: StringWithAggregatesFilter<"users"> | string
    rolEquipo?: EnumrolEquipoNullableWithAggregatesFilter<"users"> | $Enums.rolEquipo | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    tipoUsuario?: EnumTipoUsuarioWithAggregatesFilter<"users"> | $Enums.TipoUsuario
  }

  export type auteRestWhereInput = {
    AND?: auteRestWhereInput | auteRestWhereInput[]
    OR?: auteRestWhereInput[]
    NOT?: auteRestWhereInput | auteRestWhereInput[]
    idSeguridad?: IntFilter<"auteRest"> | number
    idUsuario?: IntFilter<"auteRest"> | number
    googleId?: StringFilter<"auteRest"> | string
    token?: StringFilter<"auteRest"> | string
    fechaSolicitud?: DateTimeFilter<"auteRest"> | Date | string
    fechaExpiracion?: DateTimeFilter<"auteRest"> | Date | string
    usado?: BoolFilter<"auteRest"> | boolean
    confirmado?: BoolFilter<"auteRest"> | boolean
    createdAt?: DateTimeFilter<"auteRest"> | Date | string
    updatedAt?: DateTimeFilter<"auteRest"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type auteRestOrderByWithRelationInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    googleId?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    confirmado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type auteRestWhereUniqueInput = Prisma.AtLeast<{
    idSeguridad?: number
    idUsuario?: number
    googleId?: string
    AND?: auteRestWhereInput | auteRestWhereInput[]
    OR?: auteRestWhereInput[]
    NOT?: auteRestWhereInput | auteRestWhereInput[]
    token?: StringFilter<"auteRest"> | string
    fechaSolicitud?: DateTimeFilter<"auteRest"> | Date | string
    fechaExpiracion?: DateTimeFilter<"auteRest"> | Date | string
    usado?: BoolFilter<"auteRest"> | boolean
    confirmado?: BoolFilter<"auteRest"> | boolean
    createdAt?: DateTimeFilter<"auteRest"> | Date | string
    updatedAt?: DateTimeFilter<"auteRest"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idSeguridad" | "idUsuario" | "googleId">

  export type auteRestOrderByWithAggregationInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    googleId?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    confirmado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: auteRestCountOrderByAggregateInput
    _avg?: auteRestAvgOrderByAggregateInput
    _max?: auteRestMaxOrderByAggregateInput
    _min?: auteRestMinOrderByAggregateInput
    _sum?: auteRestSumOrderByAggregateInput
  }

  export type auteRestScalarWhereWithAggregatesInput = {
    AND?: auteRestScalarWhereWithAggregatesInput | auteRestScalarWhereWithAggregatesInput[]
    OR?: auteRestScalarWhereWithAggregatesInput[]
    NOT?: auteRestScalarWhereWithAggregatesInput | auteRestScalarWhereWithAggregatesInput[]
    idSeguridad?: IntWithAggregatesFilter<"auteRest"> | number
    idUsuario?: IntWithAggregatesFilter<"auteRest"> | number
    googleId?: StringWithAggregatesFilter<"auteRest"> | string
    token?: StringWithAggregatesFilter<"auteRest"> | string
    fechaSolicitud?: DateTimeWithAggregatesFilter<"auteRest"> | Date | string
    fechaExpiracion?: DateTimeWithAggregatesFilter<"auteRest"> | Date | string
    usado?: BoolWithAggregatesFilter<"auteRest"> | boolean
    confirmado?: BoolWithAggregatesFilter<"auteRest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"auteRest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"auteRest"> | Date | string
  }

  export type notificacionesWhereInput = {
    AND?: notificacionesWhereInput | notificacionesWhereInput[]
    OR?: notificacionesWhereInput[]
    NOT?: notificacionesWhereInput | notificacionesWhereInput[]
    idNotificacion?: IntFilter<"notificaciones"> | number
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificacionesOrderByWithRelationInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type notificacionesWhereUniqueInput = Prisma.AtLeast<{
    idNotificacion?: number
    AND?: notificacionesWhereInput | notificacionesWhereInput[]
    OR?: notificacionesWhereInput[]
    NOT?: notificacionesWhereInput | notificacionesWhereInput[]
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idNotificacion">

  export type notificacionesOrderByWithAggregationInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
    _count?: notificacionesCountOrderByAggregateInput
    _avg?: notificacionesAvgOrderByAggregateInput
    _max?: notificacionesMaxOrderByAggregateInput
    _min?: notificacionesMinOrderByAggregateInput
    _sum?: notificacionesSumOrderByAggregateInput
  }

  export type notificacionesScalarWhereWithAggregatesInput = {
    AND?: notificacionesScalarWhereWithAggregatesInput | notificacionesScalarWhereWithAggregatesInput[]
    OR?: notificacionesScalarWhereWithAggregatesInput[]
    NOT?: notificacionesScalarWhereWithAggregatesInput | notificacionesScalarWhereWithAggregatesInput[]
    idNotificacion?: IntWithAggregatesFilter<"notificaciones"> | number
    idUsuario?: IntWithAggregatesFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionWithAggregatesFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringWithAggregatesFilter<"notificaciones"> | string
    mensaje?: StringWithAggregatesFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeWithAggregatesFilter<"notificaciones"> | Date | string
    leida?: BoolWithAggregatesFilter<"notificaciones"> | boolean
  }

  export type productosWhereInput = {
    AND?: productosWhereInput | productosWhereInput[]
    OR?: productosWhereInput[]
    NOT?: productosWhereInput | productosWhereInput[]
    id?: IntFilter<"productos"> | number
    codigoBarras?: StringFilter<"productos"> | string
    codigoQR?: StringFilter<"productos"> | string
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    categoriaId?: IntFilter<"productos"> | number
    cantidad?: IntFilter<"productos"> | number
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: StringFilter<"productos"> | string
    imagen?: StringFilter<"productos"> | string
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
    ajustInven?: AjustInvenListRelationFilter
    alertVen?: AlertVenListRelationFilter
    colaboraciones?: ColaboracionesListRelationFilter
    histInv?: HistInvListRelationFilter
    histoVenta?: HistoVentaListRelationFilter
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
    recorStock?: RecorStockListRelationFilter
  }

  export type productosOrderByWithRelationInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrderInput | SortOrder
    ajustInven?: ajustInvenOrderByRelationAggregateInput
    alertVen?: alertVenOrderByRelationAggregateInput
    colaboraciones?: colaboracionesOrderByRelationAggregateInput
    histInv?: histInvOrderByRelationAggregateInput
    histoVenta?: histoVentaOrderByRelationAggregateInput
    usuario?: usersOrderByWithRelationInput
    recorStock?: recorStockOrderByRelationAggregateInput
  }

  export type productosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoBarras?: string
    codigoQR?: string
    AND?: productosWhereInput | productosWhereInput[]
    OR?: productosWhereInput[]
    NOT?: productosWhereInput | productosWhereInput[]
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    categoriaId?: IntFilter<"productos"> | number
    cantidad?: IntFilter<"productos"> | number
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: StringFilter<"productos"> | string
    imagen?: StringFilter<"productos"> | string
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
    ajustInven?: AjustInvenListRelationFilter
    alertVen?: AlertVenListRelationFilter
    colaboraciones?: ColaboracionesListRelationFilter
    histInv?: HistInvListRelationFilter
    histoVenta?: HistoVentaListRelationFilter
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
    recorStock?: RecorStockListRelationFilter
  }, "id" | "codigoBarras" | "codigoQR">

  export type productosOrderByWithAggregationInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrderInput | SortOrder
    _count?: productosCountOrderByAggregateInput
    _avg?: productosAvgOrderByAggregateInput
    _max?: productosMaxOrderByAggregateInput
    _min?: productosMinOrderByAggregateInput
    _sum?: productosSumOrderByAggregateInput
  }

  export type productosScalarWhereWithAggregatesInput = {
    AND?: productosScalarWhereWithAggregatesInput | productosScalarWhereWithAggregatesInput[]
    OR?: productosScalarWhereWithAggregatesInput[]
    NOT?: productosScalarWhereWithAggregatesInput | productosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"productos"> | number
    codigoBarras?: StringWithAggregatesFilter<"productos"> | string
    codigoQR?: StringWithAggregatesFilter<"productos"> | string
    nombre?: StringWithAggregatesFilter<"productos"> | string
    descripcion?: StringWithAggregatesFilter<"productos"> | string
    categoriaId?: IntWithAggregatesFilter<"productos"> | number
    cantidad?: IntWithAggregatesFilter<"productos"> | number
    precio?: DecimalWithAggregatesFilter<"productos"> | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    usuarioId?: IntWithAggregatesFilter<"productos"> | number
    estado?: StringWithAggregatesFilter<"productos"> | string
    imagen?: StringWithAggregatesFilter<"productos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableWithAggregatesFilter<"productos"> | Date | string | null
  }

  export type histoVentaWhereInput = {
    AND?: histoVentaWhereInput | histoVentaWhereInput[]
    OR?: histoVentaWhereInput[]
    NOT?: histoVentaWhereInput | histoVentaWhereInput[]
    idVenta?: IntFilter<"histoVenta"> | number
    idProducto?: IntFilter<"histoVenta"> | number
    cantidadVendida?: IntFilter<"histoVenta"> | number
    fechaVenta?: DateTimeFilter<"histoVenta"> | Date | string
    createdAt?: DateTimeFilter<"histoVenta"> | Date | string
    updatedAt?: DateTimeFilter<"histoVenta"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type histoVentaOrderByWithRelationInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
    fechaVenta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    producto?: productosOrderByWithRelationInput
  }

  export type histoVentaWhereUniqueInput = Prisma.AtLeast<{
    idVenta?: number
    AND?: histoVentaWhereInput | histoVentaWhereInput[]
    OR?: histoVentaWhereInput[]
    NOT?: histoVentaWhereInput | histoVentaWhereInput[]
    idProducto?: IntFilter<"histoVenta"> | number
    cantidadVendida?: IntFilter<"histoVenta"> | number
    fechaVenta?: DateTimeFilter<"histoVenta"> | Date | string
    createdAt?: DateTimeFilter<"histoVenta"> | Date | string
    updatedAt?: DateTimeFilter<"histoVenta"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "idVenta">

  export type histoVentaOrderByWithAggregationInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
    fechaVenta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: histoVentaCountOrderByAggregateInput
    _avg?: histoVentaAvgOrderByAggregateInput
    _max?: histoVentaMaxOrderByAggregateInput
    _min?: histoVentaMinOrderByAggregateInput
    _sum?: histoVentaSumOrderByAggregateInput
  }

  export type histoVentaScalarWhereWithAggregatesInput = {
    AND?: histoVentaScalarWhereWithAggregatesInput | histoVentaScalarWhereWithAggregatesInput[]
    OR?: histoVentaScalarWhereWithAggregatesInput[]
    NOT?: histoVentaScalarWhereWithAggregatesInput | histoVentaScalarWhereWithAggregatesInput[]
    idVenta?: IntWithAggregatesFilter<"histoVenta"> | number
    idProducto?: IntWithAggregatesFilter<"histoVenta"> | number
    cantidadVendida?: IntWithAggregatesFilter<"histoVenta"> | number
    fechaVenta?: DateTimeWithAggregatesFilter<"histoVenta"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"histoVenta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"histoVenta"> | Date | string
  }

  export type recorStockWhereInput = {
    AND?: recorStockWhereInput | recorStockWhereInput[]
    OR?: recorStockWhereInput[]
    NOT?: recorStockWhereInput | recorStockWhereInput[]
    idRecordatorio?: IntFilter<"recorStock"> | number
    idProducto?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type recorStockOrderByWithRelationInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    producto?: productosOrderByWithRelationInput
  }

  export type recorStockWhereUniqueInput = Prisma.AtLeast<{
    idRecordatorio?: number
    AND?: recorStockWhereInput | recorStockWhereInput[]
    OR?: recorStockWhereInput[]
    NOT?: recorStockWhereInput | recorStockWhereInput[]
    idProducto?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "idRecordatorio">

  export type recorStockOrderByWithAggregationInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: recorStockCountOrderByAggregateInput
    _avg?: recorStockAvgOrderByAggregateInput
    _max?: recorStockMaxOrderByAggregateInput
    _min?: recorStockMinOrderByAggregateInput
    _sum?: recorStockSumOrderByAggregateInput
  }

  export type recorStockScalarWhereWithAggregatesInput = {
    AND?: recorStockScalarWhereWithAggregatesInput | recorStockScalarWhereWithAggregatesInput[]
    OR?: recorStockScalarWhereWithAggregatesInput[]
    NOT?: recorStockScalarWhereWithAggregatesInput | recorStockScalarWhereWithAggregatesInput[]
    idRecordatorio?: IntWithAggregatesFilter<"recorStock"> | number
    idProducto?: IntWithAggregatesFilter<"recorStock"> | number
    cantidadMinima?: IntWithAggregatesFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioWithAggregatesFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
  }

  export type comentariosWhereInput = {
    AND?: comentariosWhereInput | comentariosWhereInput[]
    OR?: comentariosWhereInput[]
    NOT?: comentariosWhereInput | comentariosWhereInput[]
    idComentario?: IntFilter<"comentarios"> | number
    idUsuario?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type comentariosOrderByWithRelationInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type comentariosWhereUniqueInput = Prisma.AtLeast<{
    idComentario?: number
    AND?: comentariosWhereInput | comentariosWhereInput[]
    OR?: comentariosWhereInput[]
    NOT?: comentariosWhereInput | comentariosWhereInput[]
    idUsuario?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idComentario">

  export type comentariosOrderByWithAggregationInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: comentariosCountOrderByAggregateInput
    _avg?: comentariosAvgOrderByAggregateInput
    _max?: comentariosMaxOrderByAggregateInput
    _min?: comentariosMinOrderByAggregateInput
    _sum?: comentariosSumOrderByAggregateInput
  }

  export type comentariosScalarWhereWithAggregatesInput = {
    AND?: comentariosScalarWhereWithAggregatesInput | comentariosScalarWhereWithAggregatesInput[]
    OR?: comentariosScalarWhereWithAggregatesInput[]
    NOT?: comentariosScalarWhereWithAggregatesInput | comentariosScalarWhereWithAggregatesInput[]
    idComentario?: IntWithAggregatesFilter<"comentarios"> | number
    idUsuario?: IntWithAggregatesFilter<"comentarios"> | number
    comentario?: StringWithAggregatesFilter<"comentarios"> | string
    fechaComentario?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioWithAggregatesFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
  }

  export type soporteWhereInput = {
    AND?: soporteWhereInput | soporteWhereInput[]
    OR?: soporteWhereInput[]
    NOT?: soporteWhereInput | soporteWhereInput[]
    idSoporte?: IntFilter<"soporte"> | number
    idUsuario?: IntFilter<"soporte"> | number
    asunto?: StringFilter<"soporte"> | string
    descripcion?: StringFilter<"soporte"> | string
    estado?: EnumEstadoSoporteFilter<"soporte"> | $Enums.EstadoSoporte
    respuesta?: StringFilter<"soporte"> | string
    createdAt?: DateTimeFilter<"soporte"> | Date | string
    updatedAt?: DateTimeFilter<"soporte"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type soporteOrderByWithRelationInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
    asunto?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type soporteWhereUniqueInput = Prisma.AtLeast<{
    idSoporte?: number
    AND?: soporteWhereInput | soporteWhereInput[]
    OR?: soporteWhereInput[]
    NOT?: soporteWhereInput | soporteWhereInput[]
    idUsuario?: IntFilter<"soporte"> | number
    asunto?: StringFilter<"soporte"> | string
    descripcion?: StringFilter<"soporte"> | string
    estado?: EnumEstadoSoporteFilter<"soporte"> | $Enums.EstadoSoporte
    respuesta?: StringFilter<"soporte"> | string
    createdAt?: DateTimeFilter<"soporte"> | Date | string
    updatedAt?: DateTimeFilter<"soporte"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idSoporte">

  export type soporteOrderByWithAggregationInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
    asunto?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: soporteCountOrderByAggregateInput
    _avg?: soporteAvgOrderByAggregateInput
    _max?: soporteMaxOrderByAggregateInput
    _min?: soporteMinOrderByAggregateInput
    _sum?: soporteSumOrderByAggregateInput
  }

  export type soporteScalarWhereWithAggregatesInput = {
    AND?: soporteScalarWhereWithAggregatesInput | soporteScalarWhereWithAggregatesInput[]
    OR?: soporteScalarWhereWithAggregatesInput[]
    NOT?: soporteScalarWhereWithAggregatesInput | soporteScalarWhereWithAggregatesInput[]
    idSoporte?: IntWithAggregatesFilter<"soporte"> | number
    idUsuario?: IntWithAggregatesFilter<"soporte"> | number
    asunto?: StringWithAggregatesFilter<"soporte"> | string
    descripcion?: StringWithAggregatesFilter<"soporte"> | string
    estado?: EnumEstadoSoporteWithAggregatesFilter<"soporte"> | $Enums.EstadoSoporte
    respuesta?: StringWithAggregatesFilter<"soporte"> | string
    createdAt?: DateTimeWithAggregatesFilter<"soporte"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"soporte"> | Date | string
  }

  export type ajustInvenWhereInput = {
    AND?: ajustInvenWhereInput | ajustInvenWhereInput[]
    OR?: ajustInvenWhereInput[]
    NOT?: ajustInvenWhereInput | ajustInvenWhereInput[]
    idAjuste?: IntFilter<"ajustInven"> | number
    idProducto?: IntFilter<"ajustInven"> | number
    idUsuario?: IntFilter<"ajustInven"> | number
    cantidadAnterior?: IntFilter<"ajustInven"> | number
    cantidadNueva?: IntFilter<"ajustInven"> | number
    motivo?: StringFilter<"ajustInven"> | string
    createdAt?: DateTimeFilter<"ajustInven"> | Date | string
    updatedAt?: DateTimeFilter<"ajustInven"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type ajustInvenOrderByWithRelationInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
    motivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    producto?: productosOrderByWithRelationInput
    usuario?: usersOrderByWithRelationInput
  }

  export type ajustInvenWhereUniqueInput = Prisma.AtLeast<{
    idAjuste?: number
    AND?: ajustInvenWhereInput | ajustInvenWhereInput[]
    OR?: ajustInvenWhereInput[]
    NOT?: ajustInvenWhereInput | ajustInvenWhereInput[]
    idProducto?: IntFilter<"ajustInven"> | number
    idUsuario?: IntFilter<"ajustInven"> | number
    cantidadAnterior?: IntFilter<"ajustInven"> | number
    cantidadNueva?: IntFilter<"ajustInven"> | number
    motivo?: StringFilter<"ajustInven"> | string
    createdAt?: DateTimeFilter<"ajustInven"> | Date | string
    updatedAt?: DateTimeFilter<"ajustInven"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idAjuste">

  export type ajustInvenOrderByWithAggregationInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
    motivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ajustInvenCountOrderByAggregateInput
    _avg?: ajustInvenAvgOrderByAggregateInput
    _max?: ajustInvenMaxOrderByAggregateInput
    _min?: ajustInvenMinOrderByAggregateInput
    _sum?: ajustInvenSumOrderByAggregateInput
  }

  export type ajustInvenScalarWhereWithAggregatesInput = {
    AND?: ajustInvenScalarWhereWithAggregatesInput | ajustInvenScalarWhereWithAggregatesInput[]
    OR?: ajustInvenScalarWhereWithAggregatesInput[]
    NOT?: ajustInvenScalarWhereWithAggregatesInput | ajustInvenScalarWhereWithAggregatesInput[]
    idAjuste?: IntWithAggregatesFilter<"ajustInven"> | number
    idProducto?: IntWithAggregatesFilter<"ajustInven"> | number
    idUsuario?: IntWithAggregatesFilter<"ajustInven"> | number
    cantidadAnterior?: IntWithAggregatesFilter<"ajustInven"> | number
    cantidadNueva?: IntWithAggregatesFilter<"ajustInven"> | number
    motivo?: StringWithAggregatesFilter<"ajustInven"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ajustInven"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ajustInven"> | Date | string
  }

  export type alertVenWhereInput = {
    AND?: alertVenWhereInput | alertVenWhereInput[]
    OR?: alertVenWhereInput[]
    NOT?: alertVenWhereInput | alertVenWhereInput[]
    idAlerta?: IntFilter<"alertVen"> | number
    idProducto?: IntFilter<"alertVen"> | number
    fechaAlerta?: DateTimeFilter<"alertVen"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"alertVen"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"alertVen"> | Date | string
    updatedAt?: DateTimeFilter<"alertVen"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type alertVenOrderByWithRelationInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
    fechaAlerta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    producto?: productosOrderByWithRelationInput
  }

  export type alertVenWhereUniqueInput = Prisma.AtLeast<{
    idAlerta?: number
    AND?: alertVenWhereInput | alertVenWhereInput[]
    OR?: alertVenWhereInput[]
    NOT?: alertVenWhereInput | alertVenWhereInput[]
    idProducto?: IntFilter<"alertVen"> | number
    fechaAlerta?: DateTimeFilter<"alertVen"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"alertVen"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"alertVen"> | Date | string
    updatedAt?: DateTimeFilter<"alertVen"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "idAlerta">

  export type alertVenOrderByWithAggregationInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
    fechaAlerta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: alertVenCountOrderByAggregateInput
    _avg?: alertVenAvgOrderByAggregateInput
    _max?: alertVenMaxOrderByAggregateInput
    _min?: alertVenMinOrderByAggregateInput
    _sum?: alertVenSumOrderByAggregateInput
  }

  export type alertVenScalarWhereWithAggregatesInput = {
    AND?: alertVenScalarWhereWithAggregatesInput | alertVenScalarWhereWithAggregatesInput[]
    OR?: alertVenScalarWhereWithAggregatesInput[]
    NOT?: alertVenScalarWhereWithAggregatesInput | alertVenScalarWhereWithAggregatesInput[]
    idAlerta?: IntWithAggregatesFilter<"alertVen"> | number
    idProducto?: IntWithAggregatesFilter<"alertVen"> | number
    fechaAlerta?: DateTimeWithAggregatesFilter<"alertVen"> | Date | string
    estado?: EnumEstadoRecordatorioWithAggregatesFilter<"alertVen"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeWithAggregatesFilter<"alertVen"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"alertVen"> | Date | string
  }

  export type analisisImagenesWhereInput = {
    AND?: analisisImagenesWhereInput | analisisImagenesWhereInput[]
    OR?: analisisImagenesWhereInput[]
    NOT?: analisisImagenesWhereInput | analisisImagenesWhereInput[]
    id?: IntFilter<"analisisImagenes"> | number
    usuarioId?: IntFilter<"analisisImagenes"> | number
    esAlimento?: BoolFilter<"analisisImagenes"> | boolean
    consulta?: StringFilter<"analisisImagenes"> | string
    respuesta?: JsonFilter<"analisisImagenes">
    fechaAnalisis?: DateTimeFilter<"analisisImagenes"> | Date | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type analisisImagenesOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    fechaAnalisis?: SortOrder
    usuario?: usersOrderByWithRelationInput
  }

  export type analisisImagenesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: analisisImagenesWhereInput | analisisImagenesWhereInput[]
    OR?: analisisImagenesWhereInput[]
    NOT?: analisisImagenesWhereInput | analisisImagenesWhereInput[]
    usuarioId?: IntFilter<"analisisImagenes"> | number
    esAlimento?: BoolFilter<"analisisImagenes"> | boolean
    consulta?: StringFilter<"analisisImagenes"> | string
    respuesta?: JsonFilter<"analisisImagenes">
    fechaAnalisis?: DateTimeFilter<"analisisImagenes"> | Date | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type analisisImagenesOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    fechaAnalisis?: SortOrder
    _count?: analisisImagenesCountOrderByAggregateInput
    _avg?: analisisImagenesAvgOrderByAggregateInput
    _max?: analisisImagenesMaxOrderByAggregateInput
    _min?: analisisImagenesMinOrderByAggregateInput
    _sum?: analisisImagenesSumOrderByAggregateInput
  }

  export type analisisImagenesScalarWhereWithAggregatesInput = {
    AND?: analisisImagenesScalarWhereWithAggregatesInput | analisisImagenesScalarWhereWithAggregatesInput[]
    OR?: analisisImagenesScalarWhereWithAggregatesInput[]
    NOT?: analisisImagenesScalarWhereWithAggregatesInput | analisisImagenesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"analisisImagenes"> | number
    usuarioId?: IntWithAggregatesFilter<"analisisImagenes"> | number
    esAlimento?: BoolWithAggregatesFilter<"analisisImagenes"> | boolean
    consulta?: StringWithAggregatesFilter<"analisisImagenes"> | string
    respuesta?: JsonWithAggregatesFilter<"analisisImagenes">
    fechaAnalisis?: DateTimeWithAggregatesFilter<"analisisImagenes"> | Date | string
  }

  export type colaboracionesWhereInput = {
    AND?: colaboracionesWhereInput | colaboracionesWhereInput[]
    OR?: colaboracionesWhereInput[]
    NOT?: colaboracionesWhereInput | colaboracionesWhereInput[]
    id?: IntFilter<"colaboraciones"> | number
    productoId?: IntFilter<"colaboraciones"> | number
    marca?: StringFilter<"colaboraciones"> | string
    tarifa?: DecimalFilter<"colaboraciones"> | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFilter<"colaboraciones"> | Date | string
    fechaFin?: DateTimeFilter<"colaboraciones"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type colaboracionesOrderByWithRelationInput = {
    id?: SortOrder
    productoId?: SortOrder
    marca?: SortOrder
    tarifa?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    producto?: productosOrderByWithRelationInput
  }

  export type colaboracionesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: colaboracionesWhereInput | colaboracionesWhereInput[]
    OR?: colaboracionesWhereInput[]
    NOT?: colaboracionesWhereInput | colaboracionesWhereInput[]
    productoId?: IntFilter<"colaboraciones"> | number
    marca?: StringFilter<"colaboraciones"> | string
    tarifa?: DecimalFilter<"colaboraciones"> | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFilter<"colaboraciones"> | Date | string
    fechaFin?: DateTimeFilter<"colaboraciones"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "id">

  export type colaboracionesOrderByWithAggregationInput = {
    id?: SortOrder
    productoId?: SortOrder
    marca?: SortOrder
    tarifa?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    _count?: colaboracionesCountOrderByAggregateInput
    _avg?: colaboracionesAvgOrderByAggregateInput
    _max?: colaboracionesMaxOrderByAggregateInput
    _min?: colaboracionesMinOrderByAggregateInput
    _sum?: colaboracionesSumOrderByAggregateInput
  }

  export type colaboracionesScalarWhereWithAggregatesInput = {
    AND?: colaboracionesScalarWhereWithAggregatesInput | colaboracionesScalarWhereWithAggregatesInput[]
    OR?: colaboracionesScalarWhereWithAggregatesInput[]
    NOT?: colaboracionesScalarWhereWithAggregatesInput | colaboracionesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"colaboraciones"> | number
    productoId?: IntWithAggregatesFilter<"colaboraciones"> | number
    marca?: StringWithAggregatesFilter<"colaboraciones"> | string
    tarifa?: DecimalWithAggregatesFilter<"colaboraciones"> | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeWithAggregatesFilter<"colaboraciones"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"colaboraciones"> | Date | string
  }

  export type histInvWhereInput = {
    AND?: histInvWhereInput | histInvWhereInput[]
    OR?: histInvWhereInput[]
    NOT?: histInvWhereInput | histInvWhereInput[]
    id?: IntFilter<"histInv"> | number
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type histInvOrderByWithRelationInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
    producto?: productosOrderByWithRelationInput
    usuario?: usersOrderByWithRelationInput
  }

  export type histInvWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: histInvWhereInput | histInvWhereInput[]
    OR?: histInvWhereInput[]
    NOT?: histInvWhereInput | histInvWhereInput[]
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type histInvOrderByWithAggregationInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
    _count?: histInvCountOrderByAggregateInput
    _avg?: histInvAvgOrderByAggregateInput
    _max?: histInvMaxOrderByAggregateInput
    _min?: histInvMinOrderByAggregateInput
    _sum?: histInvSumOrderByAggregateInput
  }

  export type histInvScalarWhereWithAggregatesInput = {
    AND?: histInvScalarWhereWithAggregatesInput | histInvScalarWhereWithAggregatesInput[]
    OR?: histInvScalarWhereWithAggregatesInput[]
    NOT?: histInvScalarWhereWithAggregatesInput | histInvScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"histInv"> | number
    productoId?: IntWithAggregatesFilter<"histInv"> | number
    usuarioId?: IntWithAggregatesFilter<"histInv"> | number
    accion?: EnumAccionHistorialWithAggregatesFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntWithAggregatesFilter<"histInv"> | number
    cantidad_nueva?: IntWithAggregatesFilter<"histInv"> | number
    precio_anterior?: DecimalWithAggregatesFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalWithAggregatesFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeWithAggregatesFilter<"histInv"> | Date | string
  }

  export type api_logsWhereInput = {
    AND?: api_logsWhereInput | api_logsWhereInput[]
    OR?: api_logsWhereInput[]
    NOT?: api_logsWhereInput | api_logsWhereInput[]
    id?: IntFilter<"api_logs"> | number
    endpoint?: StringFilter<"api_logs"> | string
    metodo?: EnumMetodoAPIFilter<"api_logs"> | $Enums.MetodoAPI
    statusCode?: IntFilter<"api_logs"> | number
    tiempoRespuesta?: DecimalFilter<"api_logs"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"api_logs"> | Date | string
    errorMensaje?: StringFilter<"api_logs"> | string
    usuarioId?: IntFilter<"api_logs"> | number
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type api_logsOrderByWithRelationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    metodo?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    fecha?: SortOrder
    errorMensaje?: SortOrder
    usuarioId?: SortOrder
    usuario?: usersOrderByWithRelationInput
  }

  export type api_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: api_logsWhereInput | api_logsWhereInput[]
    OR?: api_logsWhereInput[]
    NOT?: api_logsWhereInput | api_logsWhereInput[]
    endpoint?: StringFilter<"api_logs"> | string
    metodo?: EnumMetodoAPIFilter<"api_logs"> | $Enums.MetodoAPI
    statusCode?: IntFilter<"api_logs"> | number
    tiempoRespuesta?: DecimalFilter<"api_logs"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"api_logs"> | Date | string
    errorMensaje?: StringFilter<"api_logs"> | string
    usuarioId?: IntFilter<"api_logs"> | number
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type api_logsOrderByWithAggregationInput = {
    id?: SortOrder
    endpoint?: SortOrder
    metodo?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    fecha?: SortOrder
    errorMensaje?: SortOrder
    usuarioId?: SortOrder
    _count?: api_logsCountOrderByAggregateInput
    _avg?: api_logsAvgOrderByAggregateInput
    _max?: api_logsMaxOrderByAggregateInput
    _min?: api_logsMinOrderByAggregateInput
    _sum?: api_logsSumOrderByAggregateInput
  }

  export type api_logsScalarWhereWithAggregatesInput = {
    AND?: api_logsScalarWhereWithAggregatesInput | api_logsScalarWhereWithAggregatesInput[]
    OR?: api_logsScalarWhereWithAggregatesInput[]
    NOT?: api_logsScalarWhereWithAggregatesInput | api_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"api_logs"> | number
    endpoint?: StringWithAggregatesFilter<"api_logs"> | string
    metodo?: EnumMetodoAPIWithAggregatesFilter<"api_logs"> | $Enums.MetodoAPI
    statusCode?: IntWithAggregatesFilter<"api_logs"> | number
    tiempoRespuesta?: DecimalWithAggregatesFilter<"api_logs"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeWithAggregatesFilter<"api_logs"> | Date | string
    errorMensaje?: StringWithAggregatesFilter<"api_logs"> | string
    usuarioId?: IntWithAggregatesFilter<"api_logs"> | number
  }

  export type MonAudRendWhereInput = {
    AND?: MonAudRendWhereInput | MonAudRendWhereInput[]
    OR?: MonAudRendWhereInput[]
    NOT?: MonAudRendWhereInput | MonAudRendWhereInput[]
    id?: IntFilter<"MonAudRend"> | number
    tipoEvento?: EnumTipoEventoFilter<"MonAudRend"> | $Enums.TipoEvento
    nombreEvento?: StringFilter<"MonAudRend"> | string
    descripcion?: StringFilter<"MonAudRend"> | string
    usuarioId?: IntFilter<"MonAudRend"> | number
    fecha?: DateTimeFilter<"MonAudRend"> | Date | string
    ip_address?: StringFilter<"MonAudRend"> | string
    nivel?: StringFilter<"MonAudRend"> | string
    valor?: DecimalFilter<"MonAudRend"> | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFilter<"MonAudRend"> | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type MonAudRendOrderByWithRelationInput = {
    id?: SortOrder
    tipoEvento?: SortOrder
    nombreEvento?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    fecha?: SortOrder
    ip_address?: SortOrder
    nivel?: SortOrder
    valor?: SortOrder
    stackTrace?: SortOrder
    usuario?: usersOrderByWithRelationInput
  }

  export type MonAudRendWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MonAudRendWhereInput | MonAudRendWhereInput[]
    OR?: MonAudRendWhereInput[]
    NOT?: MonAudRendWhereInput | MonAudRendWhereInput[]
    tipoEvento?: EnumTipoEventoFilter<"MonAudRend"> | $Enums.TipoEvento
    nombreEvento?: StringFilter<"MonAudRend"> | string
    descripcion?: StringFilter<"MonAudRend"> | string
    usuarioId?: IntFilter<"MonAudRend"> | number
    fecha?: DateTimeFilter<"MonAudRend"> | Date | string
    ip_address?: StringFilter<"MonAudRend"> | string
    nivel?: StringFilter<"MonAudRend"> | string
    valor?: DecimalFilter<"MonAudRend"> | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFilter<"MonAudRend"> | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type MonAudRendOrderByWithAggregationInput = {
    id?: SortOrder
    tipoEvento?: SortOrder
    nombreEvento?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    fecha?: SortOrder
    ip_address?: SortOrder
    nivel?: SortOrder
    valor?: SortOrder
    stackTrace?: SortOrder
    _count?: MonAudRendCountOrderByAggregateInput
    _avg?: MonAudRendAvgOrderByAggregateInput
    _max?: MonAudRendMaxOrderByAggregateInput
    _min?: MonAudRendMinOrderByAggregateInput
    _sum?: MonAudRendSumOrderByAggregateInput
  }

  export type MonAudRendScalarWhereWithAggregatesInput = {
    AND?: MonAudRendScalarWhereWithAggregatesInput | MonAudRendScalarWhereWithAggregatesInput[]
    OR?: MonAudRendScalarWhereWithAggregatesInput[]
    NOT?: MonAudRendScalarWhereWithAggregatesInput | MonAudRendScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MonAudRend"> | number
    tipoEvento?: EnumTipoEventoWithAggregatesFilter<"MonAudRend"> | $Enums.TipoEvento
    nombreEvento?: StringWithAggregatesFilter<"MonAudRend"> | string
    descripcion?: StringWithAggregatesFilter<"MonAudRend"> | string
    usuarioId?: IntWithAggregatesFilter<"MonAudRend"> | number
    fecha?: DateTimeWithAggregatesFilter<"MonAudRend"> | Date | string
    ip_address?: StringWithAggregatesFilter<"MonAudRend"> | string
    nivel?: StringWithAggregatesFilter<"MonAudRend"> | string
    valor?: DecimalWithAggregatesFilter<"MonAudRend"> | Decimal | DecimalJsLike | number | string
    stackTrace?: StringWithAggregatesFilter<"MonAudRend"> | string
  }

  export type auditoriaWhereInput = {
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    id?: IntFilter<"auditoria"> | number
    evento?: StringFilter<"auditoria"> | string
    usuarioId?: IntFilter<"auditoria"> | number
    descripcion?: StringFilter<"auditoria"> | string
    fecha?: DateTimeFilter<"auditoria"> | Date | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type auditoriaOrderByWithRelationInput = {
    id?: SortOrder
    evento?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    usuario?: usersOrderByWithRelationInput
  }

  export type auditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    evento?: StringFilter<"auditoria"> | string
    usuarioId?: IntFilter<"auditoria"> | number
    descripcion?: StringFilter<"auditoria"> | string
    fecha?: DateTimeFilter<"auditoria"> | Date | string
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type auditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    evento?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    _count?: auditoriaCountOrderByAggregateInput
    _avg?: auditoriaAvgOrderByAggregateInput
    _max?: auditoriaMaxOrderByAggregateInput
    _min?: auditoriaMinOrderByAggregateInput
    _sum?: auditoriaSumOrderByAggregateInput
  }

  export type auditoriaScalarWhereWithAggregatesInput = {
    AND?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    OR?: auditoriaScalarWhereWithAggregatesInput[]
    NOT?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auditoria"> | number
    evento?: StringWithAggregatesFilter<"auditoria"> | string
    usuarioId?: IntWithAggregatesFilter<"auditoria"> | number
    descripcion?: StringWithAggregatesFilter<"auditoria"> | string
    fecha?: DateTimeWithAggregatesFilter<"auditoria"> | Date | string
  }

  export type usersCreateInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
  }

  export type usersUncheckedUpdateManyInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
  }

  export type auteRestCreateInput = {
    googleId: string
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado: boolean
    confirmado: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAuteRestInput
  }

  export type auteRestUncheckedCreateInput = {
    idSeguridad?: number
    idUsuario: number
    googleId: string
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado: boolean
    confirmado: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type auteRestUpdateInput = {
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAuteRestNestedInput
  }

  export type auteRestUncheckedUpdateInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auteRestCreateManyInput = {
    idSeguridad?: number
    idUsuario: number
    googleId: string
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado: boolean
    confirmado: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type auteRestUpdateManyMutationInput = {
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auteRestUncheckedUpdateManyInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificacionesCreateInput = {
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
    user: usersCreateNestedOneWithoutNotificacionesInput
  }

  export type notificacionesUncheckedCreateInput = {
    idNotificacion?: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
  }

  export type notificacionesUpdateInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type notificacionesUncheckedUpdateInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesCreateManyInput = {
    idNotificacion?: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
  }

  export type notificacionesUpdateManyMutationInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateManyInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productosCreateInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosUpdateInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosCreateManyInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
  }

  export type productosUpdateManyMutationInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type histoVentaCreateInput = {
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutHistoVentaInput
  }

  export type histoVentaUncheckedCreateInput = {
    idVenta?: number
    idProducto: number
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histoVentaUpdateInput = {
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutHistoVentaNestedInput
  }

  export type histoVentaUncheckedUpdateInput = {
    idVenta?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histoVentaCreateManyInput = {
    idVenta?: number
    idProducto: number
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histoVentaUpdateManyMutationInput = {
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histoVentaUncheckedUpdateManyInput = {
    idVenta?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockCreateInput = {
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutRecorStockInput
  }

  export type recorStockUncheckedCreateInput = {
    idRecordatorio?: number
    idProducto: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUpdateInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutRecorStockNestedInput
  }

  export type recorStockUncheckedUpdateInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockCreateManyInput = {
    idRecordatorio?: number
    idProducto: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUpdateManyMutationInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateManyInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosCreateInput = {
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateInput = {
    idComentario?: number
    idUsuario: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosCreateManyInput = {
    idComentario?: number
    idUsuario: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soporteCreateInput = {
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSoporteInput
  }

  export type soporteUncheckedCreateInput = {
    idSoporte?: number
    idUsuario: number
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type soporteUpdateInput = {
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSoporteNestedInput
  }

  export type soporteUncheckedUpdateInput = {
    idSoporte?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soporteCreateManyInput = {
    idSoporte?: number
    idUsuario: number
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type soporteUpdateManyMutationInput = {
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soporteUncheckedUpdateManyInput = {
    idSoporte?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenCreateInput = {
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutAjustInvenInput
    usuario: usersCreateNestedOneWithoutAjustInvenInput
  }

  export type ajustInvenUncheckedCreateInput = {
    idAjuste?: number
    idProducto: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ajustInvenUpdateInput = {
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutAjustInvenNestedInput
    usuario?: usersUpdateOneRequiredWithoutAjustInvenNestedInput
  }

  export type ajustInvenUncheckedUpdateInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenCreateManyInput = {
    idAjuste?: number
    idProducto: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ajustInvenUpdateManyMutationInput = {
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenUncheckedUpdateManyInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenCreateInput = {
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutAlertVenInput
  }

  export type alertVenUncheckedCreateInput = {
    idAlerta?: number
    idProducto: number
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type alertVenUpdateInput = {
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutAlertVenNestedInput
  }

  export type alertVenUncheckedUpdateInput = {
    idAlerta?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenCreateManyInput = {
    idAlerta?: number
    idProducto: number
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type alertVenUpdateManyMutationInput = {
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenUncheckedUpdateManyInput = {
    idAlerta?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesCreateInput = {
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
    usuario: usersCreateNestedOneWithoutAnalisisImagenesInput
  }

  export type analisisImagenesUncheckedCreateInput = {
    id?: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
  }

  export type analisisImagenesUpdateInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usersUpdateOneRequiredWithoutAnalisisImagenesNestedInput
  }

  export type analisisImagenesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesCreateManyInput = {
    id?: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
  }

  export type analisisImagenesUpdateManyMutationInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesCreateInput = {
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
    producto: productosCreateNestedOneWithoutColaboracionesInput
  }

  export type colaboracionesUncheckedCreateInput = {
    id?: number
    productoId: number
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type colaboracionesUpdateInput = {
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutColaboracionesNestedInput
  }

  export type colaboracionesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesCreateManyInput = {
    id?: number
    productoId: number
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type colaboracionesUpdateManyMutationInput = {
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvCreateInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    producto: productosCreateNestedOneWithoutHistInvInput
    usuario: usersCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateInput = {
    id?: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvUpdateInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutHistInvNestedInput
    usuario?: usersUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvCreateManyInput = {
    id?: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvUpdateManyMutationInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_logsCreateInput = {
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
    usuario: usersCreateNestedOneWithoutApi_logsInput
  }

  export type api_logsUncheckedCreateInput = {
    id?: number
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
    usuarioId: number
  }

  export type api_logsUpdateInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
    usuario?: usersUpdateOneRequiredWithoutApi_logsNestedInput
  }

  export type api_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type api_logsCreateManyInput = {
    id?: number
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
    usuarioId: number
  }

  export type api_logsUpdateManyMutationInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
  }

  export type api_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type MonAudRendCreateInput = {
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
    usuario: usersCreateNestedOneWithoutMonAudRendInput
  }

  export type MonAudRendUncheckedCreateInput = {
    id?: number
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    usuarioId: number
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
  }

  export type MonAudRendUpdateInput = {
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
    usuario?: usersUpdateOneRequiredWithoutMonAudRendNestedInput
  }

  export type MonAudRendUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type MonAudRendCreateManyInput = {
    id?: number
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    usuarioId: number
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
  }

  export type MonAudRendUpdateManyMutationInput = {
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type MonAudRendUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type auditoriaCreateInput = {
    evento: string
    descripcion: string
    fecha: Date | string
    usuario: usersCreateNestedOneWithoutAuditoriaInput
  }

  export type auditoriaUncheckedCreateInput = {
    id?: number
    evento: string
    usuarioId: number
    descripcion: string
    fecha: Date | string
  }

  export type auditoriaUpdateInput = {
    evento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usersUpdateOneRequiredWithoutAuditoriaNestedInput
  }

  export type auditoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    evento?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaCreateManyInput = {
    id?: number
    evento: string
    usuarioId: number
    descripcion: string
    fecha: Date | string
  }

  export type auditoriaUpdateManyMutationInput = {
    evento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    evento?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumrolEquipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableFilter<$PrismaModel> | $Enums.rolEquipo | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumTipoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioFilter<$PrismaModel> | $Enums.TipoUsuario
  }

  export type MonAudRendListRelationFilter = {
    every?: MonAudRendWhereInput
    some?: MonAudRendWhereInput
    none?: MonAudRendWhereInput
  }

  export type AjustInvenListRelationFilter = {
    every?: ajustInvenWhereInput
    some?: ajustInvenWhereInput
    none?: ajustInvenWhereInput
  }

  export type AnalisisImagenesListRelationFilter = {
    every?: analisisImagenesWhereInput
    some?: analisisImagenesWhereInput
    none?: analisisImagenesWhereInput
  }

  export type Api_logsListRelationFilter = {
    every?: api_logsWhereInput
    some?: api_logsWhereInput
    none?: api_logsWhereInput
  }

  export type AuditoriaListRelationFilter = {
    every?: auditoriaWhereInput
    some?: auditoriaWhereInput
    none?: auditoriaWhereInput
  }

  export type AuteRestNullableScalarRelationFilter = {
    is?: auteRestWhereInput | null
    isNot?: auteRestWhereInput | null
  }

  export type ComentariosListRelationFilter = {
    every?: comentariosWhereInput
    some?: comentariosWhereInput
    none?: comentariosWhereInput
  }

  export type HistInvListRelationFilter = {
    every?: histInvWhereInput
    some?: histInvWhereInput
    none?: histInvWhereInput
  }

  export type NotificacionesListRelationFilter = {
    every?: notificacionesWhereInput
    some?: notificacionesWhereInput
    none?: notificacionesWhereInput
  }

  export type ProductosListRelationFilter = {
    every?: productosWhereInput
    some?: productosWhereInput
    none?: productosWhereInput
  }

  export type SoporteListRelationFilter = {
    every?: soporteWhereInput
    some?: soporteWhereInput
    none?: soporteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MonAudRendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ajustInvenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type analisisImagenesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type api_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comentariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type histInvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type soporteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    rolEquipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    idUsuario?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    rolEquipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    rolEquipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    tipoUsuario?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    idUsuario?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumrolEquipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.rolEquipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
    _max?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTipoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type auteRestCountOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    googleId?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    confirmado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type auteRestAvgOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
  }

  export type auteRestMaxOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    googleId?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    confirmado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type auteRestMinOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    googleId?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    confirmado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type auteRestSumOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type notificacionesCountOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesAvgOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
  }

  export type notificacionesMaxOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesMinOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesSumOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
  }

  export type EnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AlertVenListRelationFilter = {
    every?: alertVenWhereInput
    some?: alertVenWhereInput
    none?: alertVenWhereInput
  }

  export type ColaboracionesListRelationFilter = {
    every?: colaboracionesWhereInput
    some?: colaboracionesWhereInput
    none?: colaboracionesWhereInput
  }

  export type HistoVentaListRelationFilter = {
    every?: histoVentaWhereInput
    some?: histoVentaWhereInput
    none?: histoVentaWhereInput
  }

  export type RecorStockListRelationFilter = {
    every?: recorStockWhereInput
    some?: recorStockWhereInput
    none?: recorStockWhereInput
  }

  export type alertVenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type colaboracionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type histoVentaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recorStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productosCountOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosAvgOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    usuarioId?: SortOrder
  }

  export type productosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosMinOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosSumOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    usuarioId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductosScalarRelationFilter = {
    is?: productosWhereInput
    isNot?: productosWhereInput
  }

  export type histoVentaCountOrderByAggregateInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
    fechaVenta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type histoVentaAvgOrderByAggregateInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
  }

  export type histoVentaMaxOrderByAggregateInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
    fechaVenta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type histoVentaMinOrderByAggregateInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
    fechaVenta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type histoVentaSumOrderByAggregateInput = {
    idVenta?: SortOrder
    idProducto?: SortOrder
    cantidadVendida?: SortOrder
  }

  export type EnumEstadoRecordatorioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioFilter<$PrismaModel> | $Enums.EstadoRecordatorio
  }

  export type recorStockCountOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockAvgOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
  }

  export type recorStockMaxOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockMinOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockSumOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    idProducto?: SortOrder
    cantidadMinima?: SortOrder
  }

  export type EnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoRecordatorio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
    _max?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
  }

  export type EnumEstadoComentarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioFilter<$PrismaModel> | $Enums.EstadoComentario
  }

  export type comentariosCountOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosAvgOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
  }

  export type comentariosMaxOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosMinOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosSumOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
  }

  export type EnumEstadoComentarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoComentario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoComentarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoComentarioFilter<$PrismaModel>
  }

  export type EnumEstadoSoporteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSoporte | EnumEstadoSoporteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSoporteFilter<$PrismaModel> | $Enums.EstadoSoporte
  }

  export type soporteCountOrderByAggregateInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
    asunto?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type soporteAvgOrderByAggregateInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
  }

  export type soporteMaxOrderByAggregateInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
    asunto?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type soporteMinOrderByAggregateInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
    asunto?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    respuesta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type soporteSumOrderByAggregateInput = {
    idSoporte?: SortOrder
    idUsuario?: SortOrder
  }

  export type EnumEstadoSoporteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSoporte | EnumEstadoSoporteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSoporteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSoporte
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSoporteFilter<$PrismaModel>
    _max?: NestedEnumEstadoSoporteFilter<$PrismaModel>
  }

  export type ajustInvenCountOrderByAggregateInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
    motivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ajustInvenAvgOrderByAggregateInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
  }

  export type ajustInvenMaxOrderByAggregateInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
    motivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ajustInvenMinOrderByAggregateInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
    motivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ajustInvenSumOrderByAggregateInput = {
    idAjuste?: SortOrder
    idProducto?: SortOrder
    idUsuario?: SortOrder
    cantidadAnterior?: SortOrder
    cantidadNueva?: SortOrder
  }

  export type alertVenCountOrderByAggregateInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
    fechaAlerta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type alertVenAvgOrderByAggregateInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
  }

  export type alertVenMaxOrderByAggregateInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
    fechaAlerta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type alertVenMinOrderByAggregateInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
    fechaAlerta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type alertVenSumOrderByAggregateInput = {
    idAlerta?: SortOrder
    idProducto?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type analisisImagenesCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    fechaAnalisis?: SortOrder
  }

  export type analisisImagenesAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type analisisImagenesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    fechaAnalisis?: SortOrder
  }

  export type analisisImagenesMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    fechaAnalisis?: SortOrder
  }

  export type analisisImagenesSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type colaboracionesCountOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    marca?: SortOrder
    tarifa?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
  }

  export type colaboracionesAvgOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    tarifa?: SortOrder
  }

  export type colaboracionesMaxOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    marca?: SortOrder
    tarifa?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
  }

  export type colaboracionesMinOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    marca?: SortOrder
    tarifa?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
  }

  export type colaboracionesSumOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    tarifa?: SortOrder
  }

  export type EnumAccionHistorialFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialFilter<$PrismaModel> | $Enums.AccionHistorial
  }

  export type histInvCountOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvAvgOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
  }

  export type histInvMaxOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvMinOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvSumOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
  }

  export type EnumAccionHistorialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel> | $Enums.AccionHistorial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionHistorialFilter<$PrismaModel>
    _max?: NestedEnumAccionHistorialFilter<$PrismaModel>
  }

  export type EnumMetodoAPIFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoAPI | EnumMetodoAPIFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoAPIFilter<$PrismaModel> | $Enums.MetodoAPI
  }

  export type api_logsCountOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    metodo?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    fecha?: SortOrder
    errorMensaje?: SortOrder
    usuarioId?: SortOrder
  }

  export type api_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    usuarioId?: SortOrder
  }

  export type api_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    metodo?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    fecha?: SortOrder
    errorMensaje?: SortOrder
    usuarioId?: SortOrder
  }

  export type api_logsMinOrderByAggregateInput = {
    id?: SortOrder
    endpoint?: SortOrder
    metodo?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    fecha?: SortOrder
    errorMensaje?: SortOrder
    usuarioId?: SortOrder
  }

  export type api_logsSumOrderByAggregateInput = {
    id?: SortOrder
    statusCode?: SortOrder
    tiempoRespuesta?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumMetodoAPIWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoAPI | EnumMetodoAPIFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoAPIWithAggregatesFilter<$PrismaModel> | $Enums.MetodoAPI
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoAPIFilter<$PrismaModel>
    _max?: NestedEnumMetodoAPIFilter<$PrismaModel>
  }

  export type EnumTipoEventoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoFilter<$PrismaModel> | $Enums.TipoEvento
  }

  export type MonAudRendCountOrderByAggregateInput = {
    id?: SortOrder
    tipoEvento?: SortOrder
    nombreEvento?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    fecha?: SortOrder
    ip_address?: SortOrder
    nivel?: SortOrder
    valor?: SortOrder
    stackTrace?: SortOrder
  }

  export type MonAudRendAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type MonAudRendMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoEvento?: SortOrder
    nombreEvento?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    fecha?: SortOrder
    ip_address?: SortOrder
    nivel?: SortOrder
    valor?: SortOrder
    stackTrace?: SortOrder
  }

  export type MonAudRendMinOrderByAggregateInput = {
    id?: SortOrder
    tipoEvento?: SortOrder
    nombreEvento?: SortOrder
    descripcion?: SortOrder
    usuarioId?: SortOrder
    fecha?: SortOrder
    ip_address?: SortOrder
    nivel?: SortOrder
    valor?: SortOrder
    stackTrace?: SortOrder
  }

  export type MonAudRendSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    valor?: SortOrder
  }

  export type EnumTipoEventoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel> | $Enums.TipoEvento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEventoFilter<$PrismaModel>
    _max?: NestedEnumTipoEventoFilter<$PrismaModel>
  }

  export type auditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    evento?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type auditoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type auditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    evento?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type auditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    evento?: SortOrder
    usuarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type auditoriaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type MonAudRendCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput> | MonAudRendCreateWithoutUsuarioInput[] | MonAudRendUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MonAudRendCreateOrConnectWithoutUsuarioInput | MonAudRendCreateOrConnectWithoutUsuarioInput[]
    createMany?: MonAudRendCreateManyUsuarioInputEnvelope
    connect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
  }

  export type ajustInvenCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput> | ajustInvenCreateWithoutUsuarioInput[] | ajustInvenUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutUsuarioInput | ajustInvenCreateOrConnectWithoutUsuarioInput[]
    createMany?: ajustInvenCreateManyUsuarioInputEnvelope
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
  }

  export type analisisImagenesCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput> | analisisImagenesCreateWithoutUsuarioInput[] | analisisImagenesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: analisisImagenesCreateOrConnectWithoutUsuarioInput | analisisImagenesCreateOrConnectWithoutUsuarioInput[]
    createMany?: analisisImagenesCreateManyUsuarioInputEnvelope
    connect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
  }

  export type api_logsCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput> | api_logsCreateWithoutUsuarioInput[] | api_logsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: api_logsCreateOrConnectWithoutUsuarioInput | api_logsCreateOrConnectWithoutUsuarioInput[]
    createMany?: api_logsCreateManyUsuarioInputEnvelope
    connect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
  }

  export type auditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type auteRestCreateNestedOneWithoutUserInput = {
    create?: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
    connectOrCreate?: auteRestCreateOrConnectWithoutUserInput
    connect?: auteRestWhereUniqueInput
  }

  export type comentariosCreateNestedManyWithoutUserInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type histInvCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type notificacionesCreateNestedManyWithoutUserInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
  }

  export type productosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
  }

  export type soporteCreateNestedManyWithoutUserInput = {
    create?: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput> | soporteCreateWithoutUserInput[] | soporteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: soporteCreateOrConnectWithoutUserInput | soporteCreateOrConnectWithoutUserInput[]
    createMany?: soporteCreateManyUserInputEnvelope
    connect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
  }

  export type MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput> | MonAudRendCreateWithoutUsuarioInput[] | MonAudRendUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MonAudRendCreateOrConnectWithoutUsuarioInput | MonAudRendCreateOrConnectWithoutUsuarioInput[]
    createMany?: MonAudRendCreateManyUsuarioInputEnvelope
    connect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
  }

  export type ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput> | ajustInvenCreateWithoutUsuarioInput[] | ajustInvenUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutUsuarioInput | ajustInvenCreateOrConnectWithoutUsuarioInput[]
    createMany?: ajustInvenCreateManyUsuarioInputEnvelope
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
  }

  export type analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput> | analisisImagenesCreateWithoutUsuarioInput[] | analisisImagenesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: analisisImagenesCreateOrConnectWithoutUsuarioInput | analisisImagenesCreateOrConnectWithoutUsuarioInput[]
    createMany?: analisisImagenesCreateManyUsuarioInputEnvelope
    connect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
  }

  export type api_logsUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput> | api_logsCreateWithoutUsuarioInput[] | api_logsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: api_logsCreateOrConnectWithoutUsuarioInput | api_logsCreateOrConnectWithoutUsuarioInput[]
    createMany?: api_logsCreateManyUsuarioInputEnvelope
    connect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
  }

  export type auditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type auteRestUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
    connectOrCreate?: auteRestCreateOrConnectWithoutUserInput
    connect?: auteRestWhereUniqueInput
  }

  export type comentariosUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type histInvUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type notificacionesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
  }

  export type productosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
  }

  export type soporteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput> | soporteCreateWithoutUserInput[] | soporteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: soporteCreateOrConnectWithoutUserInput | soporteCreateOrConnectWithoutUserInput[]
    createMany?: soporteCreateManyUserInputEnvelope
    connect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumrolEquipoFieldUpdateOperationsInput = {
    set?: $Enums.rolEquipo | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumTipoUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.TipoUsuario
  }

  export type MonAudRendUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput> | MonAudRendCreateWithoutUsuarioInput[] | MonAudRendUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MonAudRendCreateOrConnectWithoutUsuarioInput | MonAudRendCreateOrConnectWithoutUsuarioInput[]
    upsert?: MonAudRendUpsertWithWhereUniqueWithoutUsuarioInput | MonAudRendUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MonAudRendCreateManyUsuarioInputEnvelope
    set?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    disconnect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    delete?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    connect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    update?: MonAudRendUpdateWithWhereUniqueWithoutUsuarioInput | MonAudRendUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MonAudRendUpdateManyWithWhereWithoutUsuarioInput | MonAudRendUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MonAudRendScalarWhereInput | MonAudRendScalarWhereInput[]
  }

  export type ajustInvenUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput> | ajustInvenCreateWithoutUsuarioInput[] | ajustInvenUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutUsuarioInput | ajustInvenCreateOrConnectWithoutUsuarioInput[]
    upsert?: ajustInvenUpsertWithWhereUniqueWithoutUsuarioInput | ajustInvenUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ajustInvenCreateManyUsuarioInputEnvelope
    set?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    disconnect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    delete?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    update?: ajustInvenUpdateWithWhereUniqueWithoutUsuarioInput | ajustInvenUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ajustInvenUpdateManyWithWhereWithoutUsuarioInput | ajustInvenUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
  }

  export type analisisImagenesUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput> | analisisImagenesCreateWithoutUsuarioInput[] | analisisImagenesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: analisisImagenesCreateOrConnectWithoutUsuarioInput | analisisImagenesCreateOrConnectWithoutUsuarioInput[]
    upsert?: analisisImagenesUpsertWithWhereUniqueWithoutUsuarioInput | analisisImagenesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: analisisImagenesCreateManyUsuarioInputEnvelope
    set?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    disconnect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    delete?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    connect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    update?: analisisImagenesUpdateWithWhereUniqueWithoutUsuarioInput | analisisImagenesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: analisisImagenesUpdateManyWithWhereWithoutUsuarioInput | analisisImagenesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: analisisImagenesScalarWhereInput | analisisImagenesScalarWhereInput[]
  }

  export type api_logsUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput> | api_logsCreateWithoutUsuarioInput[] | api_logsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: api_logsCreateOrConnectWithoutUsuarioInput | api_logsCreateOrConnectWithoutUsuarioInput[]
    upsert?: api_logsUpsertWithWhereUniqueWithoutUsuarioInput | api_logsUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: api_logsCreateManyUsuarioInputEnvelope
    set?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    disconnect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    delete?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    connect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    update?: api_logsUpdateWithWhereUniqueWithoutUsuarioInput | api_logsUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: api_logsUpdateManyWithWhereWithoutUsuarioInput | api_logsUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: api_logsScalarWhereInput | api_logsScalarWhereInput[]
  }

  export type auditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuarioInput | auditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuarioInput | auditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuarioInput | auditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type auteRestUpdateOneWithoutUserNestedInput = {
    create?: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
    connectOrCreate?: auteRestCreateOrConnectWithoutUserInput
    upsert?: auteRestUpsertWithoutUserInput
    disconnect?: auteRestWhereInput | boolean
    delete?: auteRestWhereInput | boolean
    connect?: auteRestWhereUniqueInput
    update?: XOR<XOR<auteRestUpdateToOneWithWhereWithoutUserInput, auteRestUpdateWithoutUserInput>, auteRestUncheckedUpdateWithoutUserInput>
  }

  export type comentariosUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutUserInput | comentariosUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutUserInput | comentariosUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutUserInput | comentariosUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type histInvUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutUsuarioInput | histInvUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutUsuarioInput | histInvUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutUsuarioInput | histInvUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type notificacionesUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    upsert?: notificacionesUpsertWithWhereUniqueWithoutUserInput | notificacionesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    set?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    disconnect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    delete?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    update?: notificacionesUpdateWithWhereUniqueWithoutUserInput | notificacionesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificacionesUpdateManyWithWhereWithoutUserInput | notificacionesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
  }

  export type productosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    upsert?: productosUpsertWithWhereUniqueWithoutUsuarioInput | productosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    set?: productosWhereUniqueInput | productosWhereUniqueInput[]
    disconnect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    delete?: productosWhereUniqueInput | productosWhereUniqueInput[]
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    update?: productosUpdateWithWhereUniqueWithoutUsuarioInput | productosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: productosUpdateManyWithWhereWithoutUsuarioInput | productosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: productosScalarWhereInput | productosScalarWhereInput[]
  }

  export type soporteUpdateManyWithoutUserNestedInput = {
    create?: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput> | soporteCreateWithoutUserInput[] | soporteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: soporteCreateOrConnectWithoutUserInput | soporteCreateOrConnectWithoutUserInput[]
    upsert?: soporteUpsertWithWhereUniqueWithoutUserInput | soporteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: soporteCreateManyUserInputEnvelope
    set?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    disconnect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    delete?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    connect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    update?: soporteUpdateWithWhereUniqueWithoutUserInput | soporteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: soporteUpdateManyWithWhereWithoutUserInput | soporteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: soporteScalarWhereInput | soporteScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput> | MonAudRendCreateWithoutUsuarioInput[] | MonAudRendUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MonAudRendCreateOrConnectWithoutUsuarioInput | MonAudRendCreateOrConnectWithoutUsuarioInput[]
    upsert?: MonAudRendUpsertWithWhereUniqueWithoutUsuarioInput | MonAudRendUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MonAudRendCreateManyUsuarioInputEnvelope
    set?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    disconnect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    delete?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    connect?: MonAudRendWhereUniqueInput | MonAudRendWhereUniqueInput[]
    update?: MonAudRendUpdateWithWhereUniqueWithoutUsuarioInput | MonAudRendUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MonAudRendUpdateManyWithWhereWithoutUsuarioInput | MonAudRendUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MonAudRendScalarWhereInput | MonAudRendScalarWhereInput[]
  }

  export type ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput> | ajustInvenCreateWithoutUsuarioInput[] | ajustInvenUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutUsuarioInput | ajustInvenCreateOrConnectWithoutUsuarioInput[]
    upsert?: ajustInvenUpsertWithWhereUniqueWithoutUsuarioInput | ajustInvenUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ajustInvenCreateManyUsuarioInputEnvelope
    set?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    disconnect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    delete?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    update?: ajustInvenUpdateWithWhereUniqueWithoutUsuarioInput | ajustInvenUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ajustInvenUpdateManyWithWhereWithoutUsuarioInput | ajustInvenUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
  }

  export type analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput> | analisisImagenesCreateWithoutUsuarioInput[] | analisisImagenesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: analisisImagenesCreateOrConnectWithoutUsuarioInput | analisisImagenesCreateOrConnectWithoutUsuarioInput[]
    upsert?: analisisImagenesUpsertWithWhereUniqueWithoutUsuarioInput | analisisImagenesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: analisisImagenesCreateManyUsuarioInputEnvelope
    set?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    disconnect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    delete?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    connect?: analisisImagenesWhereUniqueInput | analisisImagenesWhereUniqueInput[]
    update?: analisisImagenesUpdateWithWhereUniqueWithoutUsuarioInput | analisisImagenesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: analisisImagenesUpdateManyWithWhereWithoutUsuarioInput | analisisImagenesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: analisisImagenesScalarWhereInput | analisisImagenesScalarWhereInput[]
  }

  export type api_logsUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput> | api_logsCreateWithoutUsuarioInput[] | api_logsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: api_logsCreateOrConnectWithoutUsuarioInput | api_logsCreateOrConnectWithoutUsuarioInput[]
    upsert?: api_logsUpsertWithWhereUniqueWithoutUsuarioInput | api_logsUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: api_logsCreateManyUsuarioInputEnvelope
    set?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    disconnect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    delete?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    connect?: api_logsWhereUniqueInput | api_logsWhereUniqueInput[]
    update?: api_logsUpdateWithWhereUniqueWithoutUsuarioInput | api_logsUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: api_logsUpdateManyWithWhereWithoutUsuarioInput | api_logsUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: api_logsScalarWhereInput | api_logsScalarWhereInput[]
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput> | auditoriaCreateWithoutUsuarioInput[] | auditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuarioInput | auditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuarioInput | auditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: auditoriaCreateManyUsuarioInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuarioInput | auditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuarioInput | auditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type auteRestUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
    connectOrCreate?: auteRestCreateOrConnectWithoutUserInput
    upsert?: auteRestUpsertWithoutUserInput
    disconnect?: auteRestWhereInput | boolean
    delete?: auteRestWhereInput | boolean
    connect?: auteRestWhereUniqueInput
    update?: XOR<XOR<auteRestUpdateToOneWithWhereWithoutUserInput, auteRestUpdateWithoutUserInput>, auteRestUncheckedUpdateWithoutUserInput>
  }

  export type comentariosUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutUserInput | comentariosUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutUserInput | comentariosUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutUserInput | comentariosUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type histInvUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutUsuarioInput | histInvUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutUsuarioInput | histInvUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutUsuarioInput | histInvUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type notificacionesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    upsert?: notificacionesUpsertWithWhereUniqueWithoutUserInput | notificacionesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    set?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    disconnect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    delete?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    update?: notificacionesUpdateWithWhereUniqueWithoutUserInput | notificacionesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificacionesUpdateManyWithWhereWithoutUserInput | notificacionesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
  }

  export type productosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    upsert?: productosUpsertWithWhereUniqueWithoutUsuarioInput | productosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    set?: productosWhereUniqueInput | productosWhereUniqueInput[]
    disconnect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    delete?: productosWhereUniqueInput | productosWhereUniqueInput[]
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    update?: productosUpdateWithWhereUniqueWithoutUsuarioInput | productosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: productosUpdateManyWithWhereWithoutUsuarioInput | productosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: productosScalarWhereInput | productosScalarWhereInput[]
  }

  export type soporteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput> | soporteCreateWithoutUserInput[] | soporteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: soporteCreateOrConnectWithoutUserInput | soporteCreateOrConnectWithoutUserInput[]
    upsert?: soporteUpsertWithWhereUniqueWithoutUserInput | soporteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: soporteCreateManyUserInputEnvelope
    set?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    disconnect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    delete?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    connect?: soporteWhereUniqueInput | soporteWhereUniqueInput[]
    update?: soporteUpdateWithWhereUniqueWithoutUserInput | soporteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: soporteUpdateManyWithWhereWithoutUserInput | soporteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: soporteScalarWhereInput | soporteScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutAuteRestInput = {
    create?: XOR<usersCreateWithoutAuteRestInput, usersUncheckedCreateWithoutAuteRestInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuteRestInput
    connect?: usersWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneRequiredWithoutAuteRestNestedInput = {
    create?: XOR<usersCreateWithoutAuteRestInput, usersUncheckedCreateWithoutAuteRestInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuteRestInput
    upsert?: usersUpsertWithoutAuteRestInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuteRestInput, usersUpdateWithoutAuteRestInput>, usersUncheckedUpdateWithoutAuteRestInput>
  }

  export type usersCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificacionesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumTipoNotificacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoNotificacion
  }

  export type usersUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificacionesInput
    upsert?: usersUpsertWithoutNotificacionesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificacionesInput, usersUpdateWithoutNotificacionesInput>, usersUncheckedUpdateWithoutNotificacionesInput>
  }

  export type ajustInvenCreateNestedManyWithoutProductoInput = {
    create?: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput> | ajustInvenCreateWithoutProductoInput[] | ajustInvenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutProductoInput | ajustInvenCreateOrConnectWithoutProductoInput[]
    createMany?: ajustInvenCreateManyProductoInputEnvelope
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
  }

  export type alertVenCreateNestedManyWithoutProductoInput = {
    create?: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput> | alertVenCreateWithoutProductoInput[] | alertVenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: alertVenCreateOrConnectWithoutProductoInput | alertVenCreateOrConnectWithoutProductoInput[]
    createMany?: alertVenCreateManyProductoInputEnvelope
    connect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
  }

  export type colaboracionesCreateNestedManyWithoutProductoInput = {
    create?: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput> | colaboracionesCreateWithoutProductoInput[] | colaboracionesUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: colaboracionesCreateOrConnectWithoutProductoInput | colaboracionesCreateOrConnectWithoutProductoInput[]
    createMany?: colaboracionesCreateManyProductoInputEnvelope
    connect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
  }

  export type histInvCreateNestedManyWithoutProductoInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type histoVentaCreateNestedManyWithoutProductoInput = {
    create?: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput> | histoVentaCreateWithoutProductoInput[] | histoVentaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histoVentaCreateOrConnectWithoutProductoInput | histoVentaCreateOrConnectWithoutProductoInput[]
    createMany?: histoVentaCreateManyProductoInputEnvelope
    connect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutProductosInput = {
    create?: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductosInput
    connect?: usersWhereUniqueInput
  }

  export type recorStockCreateNestedManyWithoutProductoInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
  }

  export type ajustInvenUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput> | ajustInvenCreateWithoutProductoInput[] | ajustInvenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutProductoInput | ajustInvenCreateOrConnectWithoutProductoInput[]
    createMany?: ajustInvenCreateManyProductoInputEnvelope
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
  }

  export type alertVenUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput> | alertVenCreateWithoutProductoInput[] | alertVenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: alertVenCreateOrConnectWithoutProductoInput | alertVenCreateOrConnectWithoutProductoInput[]
    createMany?: alertVenCreateManyProductoInputEnvelope
    connect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
  }

  export type colaboracionesUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput> | colaboracionesCreateWithoutProductoInput[] | colaboracionesUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: colaboracionesCreateOrConnectWithoutProductoInput | colaboracionesCreateOrConnectWithoutProductoInput[]
    createMany?: colaboracionesCreateManyProductoInputEnvelope
    connect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
  }

  export type histInvUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type histoVentaUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput> | histoVentaCreateWithoutProductoInput[] | histoVentaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histoVentaCreateOrConnectWithoutProductoInput | histoVentaCreateOrConnectWithoutProductoInput[]
    createMany?: histoVentaCreateManyProductoInputEnvelope
    connect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
  }

  export type recorStockUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ajustInvenUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput> | ajustInvenCreateWithoutProductoInput[] | ajustInvenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutProductoInput | ajustInvenCreateOrConnectWithoutProductoInput[]
    upsert?: ajustInvenUpsertWithWhereUniqueWithoutProductoInput | ajustInvenUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ajustInvenCreateManyProductoInputEnvelope
    set?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    disconnect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    delete?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    update?: ajustInvenUpdateWithWhereUniqueWithoutProductoInput | ajustInvenUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ajustInvenUpdateManyWithWhereWithoutProductoInput | ajustInvenUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
  }

  export type alertVenUpdateManyWithoutProductoNestedInput = {
    create?: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput> | alertVenCreateWithoutProductoInput[] | alertVenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: alertVenCreateOrConnectWithoutProductoInput | alertVenCreateOrConnectWithoutProductoInput[]
    upsert?: alertVenUpsertWithWhereUniqueWithoutProductoInput | alertVenUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: alertVenCreateManyProductoInputEnvelope
    set?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    disconnect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    delete?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    connect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    update?: alertVenUpdateWithWhereUniqueWithoutProductoInput | alertVenUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: alertVenUpdateManyWithWhereWithoutProductoInput | alertVenUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: alertVenScalarWhereInput | alertVenScalarWhereInput[]
  }

  export type colaboracionesUpdateManyWithoutProductoNestedInput = {
    create?: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput> | colaboracionesCreateWithoutProductoInput[] | colaboracionesUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: colaboracionesCreateOrConnectWithoutProductoInput | colaboracionesCreateOrConnectWithoutProductoInput[]
    upsert?: colaboracionesUpsertWithWhereUniqueWithoutProductoInput | colaboracionesUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: colaboracionesCreateManyProductoInputEnvelope
    set?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    disconnect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    delete?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    connect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    update?: colaboracionesUpdateWithWhereUniqueWithoutProductoInput | colaboracionesUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: colaboracionesUpdateManyWithWhereWithoutProductoInput | colaboracionesUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: colaboracionesScalarWhereInput | colaboracionesScalarWhereInput[]
  }

  export type histInvUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutProductoInput | histInvUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutProductoInput | histInvUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutProductoInput | histInvUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type histoVentaUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput> | histoVentaCreateWithoutProductoInput[] | histoVentaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histoVentaCreateOrConnectWithoutProductoInput | histoVentaCreateOrConnectWithoutProductoInput[]
    upsert?: histoVentaUpsertWithWhereUniqueWithoutProductoInput | histoVentaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histoVentaCreateManyProductoInputEnvelope
    set?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    disconnect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    delete?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    connect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    update?: histoVentaUpdateWithWhereUniqueWithoutProductoInput | histoVentaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histoVentaUpdateManyWithWhereWithoutProductoInput | histoVentaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histoVentaScalarWhereInput | histoVentaScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductosInput
    upsert?: usersUpsertWithoutProductosInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProductosInput, usersUpdateWithoutProductosInput>, usersUncheckedUpdateWithoutProductosInput>
  }

  export type recorStockUpdateManyWithoutProductoNestedInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    upsert?: recorStockUpsertWithWhereUniqueWithoutProductoInput | recorStockUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    set?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    disconnect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    delete?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    update?: recorStockUpdateWithWhereUniqueWithoutProductoInput | recorStockUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: recorStockUpdateManyWithWhereWithoutProductoInput | recorStockUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
  }

  export type ajustInvenUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput> | ajustInvenCreateWithoutProductoInput[] | ajustInvenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: ajustInvenCreateOrConnectWithoutProductoInput | ajustInvenCreateOrConnectWithoutProductoInput[]
    upsert?: ajustInvenUpsertWithWhereUniqueWithoutProductoInput | ajustInvenUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: ajustInvenCreateManyProductoInputEnvelope
    set?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    disconnect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    delete?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    connect?: ajustInvenWhereUniqueInput | ajustInvenWhereUniqueInput[]
    update?: ajustInvenUpdateWithWhereUniqueWithoutProductoInput | ajustInvenUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: ajustInvenUpdateManyWithWhereWithoutProductoInput | ajustInvenUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
  }

  export type alertVenUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput> | alertVenCreateWithoutProductoInput[] | alertVenUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: alertVenCreateOrConnectWithoutProductoInput | alertVenCreateOrConnectWithoutProductoInput[]
    upsert?: alertVenUpsertWithWhereUniqueWithoutProductoInput | alertVenUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: alertVenCreateManyProductoInputEnvelope
    set?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    disconnect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    delete?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    connect?: alertVenWhereUniqueInput | alertVenWhereUniqueInput[]
    update?: alertVenUpdateWithWhereUniqueWithoutProductoInput | alertVenUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: alertVenUpdateManyWithWhereWithoutProductoInput | alertVenUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: alertVenScalarWhereInput | alertVenScalarWhereInput[]
  }

  export type colaboracionesUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput> | colaboracionesCreateWithoutProductoInput[] | colaboracionesUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: colaboracionesCreateOrConnectWithoutProductoInput | colaboracionesCreateOrConnectWithoutProductoInput[]
    upsert?: colaboracionesUpsertWithWhereUniqueWithoutProductoInput | colaboracionesUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: colaboracionesCreateManyProductoInputEnvelope
    set?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    disconnect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    delete?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    connect?: colaboracionesWhereUniqueInput | colaboracionesWhereUniqueInput[]
    update?: colaboracionesUpdateWithWhereUniqueWithoutProductoInput | colaboracionesUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: colaboracionesUpdateManyWithWhereWithoutProductoInput | colaboracionesUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: colaboracionesScalarWhereInput | colaboracionesScalarWhereInput[]
  }

  export type histInvUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutProductoInput | histInvUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutProductoInput | histInvUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutProductoInput | histInvUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type histoVentaUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput> | histoVentaCreateWithoutProductoInput[] | histoVentaUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histoVentaCreateOrConnectWithoutProductoInput | histoVentaCreateOrConnectWithoutProductoInput[]
    upsert?: histoVentaUpsertWithWhereUniqueWithoutProductoInput | histoVentaUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histoVentaCreateManyProductoInputEnvelope
    set?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    disconnect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    delete?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    connect?: histoVentaWhereUniqueInput | histoVentaWhereUniqueInput[]
    update?: histoVentaUpdateWithWhereUniqueWithoutProductoInput | histoVentaUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histoVentaUpdateManyWithWhereWithoutProductoInput | histoVentaUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histoVentaScalarWhereInput | histoVentaScalarWhereInput[]
  }

  export type recorStockUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    upsert?: recorStockUpsertWithWhereUniqueWithoutProductoInput | recorStockUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    set?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    disconnect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    delete?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    update?: recorStockUpdateWithWhereUniqueWithoutProductoInput | recorStockUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: recorStockUpdateManyWithWhereWithoutProductoInput | recorStockUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
  }

  export type productosCreateNestedOneWithoutHistoVentaInput = {
    create?: XOR<productosCreateWithoutHistoVentaInput, productosUncheckedCreateWithoutHistoVentaInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistoVentaInput
    connect?: productosWhereUniqueInput
  }

  export type productosUpdateOneRequiredWithoutHistoVentaNestedInput = {
    create?: XOR<productosCreateWithoutHistoVentaInput, productosUncheckedCreateWithoutHistoVentaInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistoVentaInput
    upsert?: productosUpsertWithoutHistoVentaInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutHistoVentaInput, productosUpdateWithoutHistoVentaInput>, productosUncheckedUpdateWithoutHistoVentaInput>
  }

  export type productosCreateNestedOneWithoutRecorStockInput = {
    create?: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    connectOrCreate?: productosCreateOrConnectWithoutRecorStockInput
    connect?: productosWhereUniqueInput
  }

  export type EnumEstadoRecordatorioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoRecordatorio
  }

  export type productosUpdateOneRequiredWithoutRecorStockNestedInput = {
    create?: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    connectOrCreate?: productosCreateOrConnectWithoutRecorStockInput
    upsert?: productosUpsertWithoutRecorStockInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutRecorStockInput, productosUpdateWithoutRecorStockInput>, productosUncheckedUpdateWithoutRecorStockInput>
  }

  export type usersCreateNestedOneWithoutComentariosInput = {
    create?: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usersCreateOrConnectWithoutComentariosInput
    connect?: usersWhereUniqueInput
  }

  export type EnumEstadoComentarioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoComentario
  }

  export type usersUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usersCreateOrConnectWithoutComentariosInput
    upsert?: usersUpsertWithoutComentariosInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutComentariosInput, usersUpdateWithoutComentariosInput>, usersUncheckedUpdateWithoutComentariosInput>
  }

  export type usersCreateNestedOneWithoutSoporteInput = {
    create?: XOR<usersCreateWithoutSoporteInput, usersUncheckedCreateWithoutSoporteInput>
    connectOrCreate?: usersCreateOrConnectWithoutSoporteInput
    connect?: usersWhereUniqueInput
  }

  export type EnumEstadoSoporteFieldUpdateOperationsInput = {
    set?: $Enums.EstadoSoporte
  }

  export type usersUpdateOneRequiredWithoutSoporteNestedInput = {
    create?: XOR<usersCreateWithoutSoporteInput, usersUncheckedCreateWithoutSoporteInput>
    connectOrCreate?: usersCreateOrConnectWithoutSoporteInput
    upsert?: usersUpsertWithoutSoporteInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSoporteInput, usersUpdateWithoutSoporteInput>, usersUncheckedUpdateWithoutSoporteInput>
  }

  export type productosCreateNestedOneWithoutAjustInvenInput = {
    create?: XOR<productosCreateWithoutAjustInvenInput, productosUncheckedCreateWithoutAjustInvenInput>
    connectOrCreate?: productosCreateOrConnectWithoutAjustInvenInput
    connect?: productosWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAjustInvenInput = {
    create?: XOR<usersCreateWithoutAjustInvenInput, usersUncheckedCreateWithoutAjustInvenInput>
    connectOrCreate?: usersCreateOrConnectWithoutAjustInvenInput
    connect?: usersWhereUniqueInput
  }

  export type productosUpdateOneRequiredWithoutAjustInvenNestedInput = {
    create?: XOR<productosCreateWithoutAjustInvenInput, productosUncheckedCreateWithoutAjustInvenInput>
    connectOrCreate?: productosCreateOrConnectWithoutAjustInvenInput
    upsert?: productosUpsertWithoutAjustInvenInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutAjustInvenInput, productosUpdateWithoutAjustInvenInput>, productosUncheckedUpdateWithoutAjustInvenInput>
  }

  export type usersUpdateOneRequiredWithoutAjustInvenNestedInput = {
    create?: XOR<usersCreateWithoutAjustInvenInput, usersUncheckedCreateWithoutAjustInvenInput>
    connectOrCreate?: usersCreateOrConnectWithoutAjustInvenInput
    upsert?: usersUpsertWithoutAjustInvenInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAjustInvenInput, usersUpdateWithoutAjustInvenInput>, usersUncheckedUpdateWithoutAjustInvenInput>
  }

  export type productosCreateNestedOneWithoutAlertVenInput = {
    create?: XOR<productosCreateWithoutAlertVenInput, productosUncheckedCreateWithoutAlertVenInput>
    connectOrCreate?: productosCreateOrConnectWithoutAlertVenInput
    connect?: productosWhereUniqueInput
  }

  export type productosUpdateOneRequiredWithoutAlertVenNestedInput = {
    create?: XOR<productosCreateWithoutAlertVenInput, productosUncheckedCreateWithoutAlertVenInput>
    connectOrCreate?: productosCreateOrConnectWithoutAlertVenInput
    upsert?: productosUpsertWithoutAlertVenInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutAlertVenInput, productosUpdateWithoutAlertVenInput>, productosUncheckedUpdateWithoutAlertVenInput>
  }

  export type usersCreateNestedOneWithoutAnalisisImagenesInput = {
    create?: XOR<usersCreateWithoutAnalisisImagenesInput, usersUncheckedCreateWithoutAnalisisImagenesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalisisImagenesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAnalisisImagenesNestedInput = {
    create?: XOR<usersCreateWithoutAnalisisImagenesInput, usersUncheckedCreateWithoutAnalisisImagenesInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnalisisImagenesInput
    upsert?: usersUpsertWithoutAnalisisImagenesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAnalisisImagenesInput, usersUpdateWithoutAnalisisImagenesInput>, usersUncheckedUpdateWithoutAnalisisImagenesInput>
  }

  export type productosCreateNestedOneWithoutColaboracionesInput = {
    create?: XOR<productosCreateWithoutColaboracionesInput, productosUncheckedCreateWithoutColaboracionesInput>
    connectOrCreate?: productosCreateOrConnectWithoutColaboracionesInput
    connect?: productosWhereUniqueInput
  }

  export type productosUpdateOneRequiredWithoutColaboracionesNestedInput = {
    create?: XOR<productosCreateWithoutColaboracionesInput, productosUncheckedCreateWithoutColaboracionesInput>
    connectOrCreate?: productosCreateOrConnectWithoutColaboracionesInput
    upsert?: productosUpsertWithoutColaboracionesInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutColaboracionesInput, productosUpdateWithoutColaboracionesInput>, productosUncheckedUpdateWithoutColaboracionesInput>
  }

  export type productosCreateNestedOneWithoutHistInvInput = {
    create?: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistInvInput
    connect?: productosWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutHistInvInput = {
    create?: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistInvInput
    connect?: usersWhereUniqueInput
  }

  export type EnumAccionHistorialFieldUpdateOperationsInput = {
    set?: $Enums.AccionHistorial
  }

  export type productosUpdateOneRequiredWithoutHistInvNestedInput = {
    create?: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistInvInput
    upsert?: productosUpsertWithoutHistInvInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutHistInvInput, productosUpdateWithoutHistInvInput>, productosUncheckedUpdateWithoutHistInvInput>
  }

  export type usersUpdateOneRequiredWithoutHistInvNestedInput = {
    create?: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistInvInput
    upsert?: usersUpsertWithoutHistInvInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutHistInvInput, usersUpdateWithoutHistInvInput>, usersUncheckedUpdateWithoutHistInvInput>
  }

  export type usersCreateNestedOneWithoutApi_logsInput = {
    create?: XOR<usersCreateWithoutApi_logsInput, usersUncheckedCreateWithoutApi_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutApi_logsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumMetodoAPIFieldUpdateOperationsInput = {
    set?: $Enums.MetodoAPI
  }

  export type usersUpdateOneRequiredWithoutApi_logsNestedInput = {
    create?: XOR<usersCreateWithoutApi_logsInput, usersUncheckedCreateWithoutApi_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutApi_logsInput
    upsert?: usersUpsertWithoutApi_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutApi_logsInput, usersUpdateWithoutApi_logsInput>, usersUncheckedUpdateWithoutApi_logsInput>
  }

  export type usersCreateNestedOneWithoutMonAudRendInput = {
    create?: XOR<usersCreateWithoutMonAudRendInput, usersUncheckedCreateWithoutMonAudRendInput>
    connectOrCreate?: usersCreateOrConnectWithoutMonAudRendInput
    connect?: usersWhereUniqueInput
  }

  export type EnumTipoEventoFieldUpdateOperationsInput = {
    set?: $Enums.TipoEvento
  }

  export type usersUpdateOneRequiredWithoutMonAudRendNestedInput = {
    create?: XOR<usersCreateWithoutMonAudRendInput, usersUncheckedCreateWithoutMonAudRendInput>
    connectOrCreate?: usersCreateOrConnectWithoutMonAudRendInput
    upsert?: usersUpsertWithoutMonAudRendInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMonAudRendInput, usersUpdateWithoutMonAudRendInput>, usersUncheckedUpdateWithoutMonAudRendInput>
  }

  export type usersCreateNestedOneWithoutAuditoriaInput = {
    create?: XOR<usersCreateWithoutAuditoriaInput, usersUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditoriaInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAuditoriaNestedInput = {
    create?: XOR<usersCreateWithoutAuditoriaInput, usersUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditoriaInput
    upsert?: usersUpsertWithoutAuditoriaInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuditoriaInput, usersUpdateWithoutAuditoriaInput>, usersUncheckedUpdateWithoutAuditoriaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumrolEquipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableFilter<$PrismaModel> | $Enums.rolEquipo | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTipoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioFilter<$PrismaModel> | $Enums.TipoUsuario
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.rolEquipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
    _max?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEstadoRecordatorioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioFilter<$PrismaModel> | $Enums.EstadoRecordatorio
  }

  export type NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoRecordatorio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
    _max?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
  }

  export type NestedEnumEstadoComentarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioFilter<$PrismaModel> | $Enums.EstadoComentario
  }

  export type NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoComentario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoComentarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoComentarioFilter<$PrismaModel>
  }

  export type NestedEnumEstadoSoporteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSoporte | EnumEstadoSoporteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSoporteFilter<$PrismaModel> | $Enums.EstadoSoporte
  }

  export type NestedEnumEstadoSoporteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSoporte | EnumEstadoSoporteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSoporte[] | ListEnumEstadoSoporteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSoporteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSoporte
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSoporteFilter<$PrismaModel>
    _max?: NestedEnumEstadoSoporteFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAccionHistorialFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialFilter<$PrismaModel> | $Enums.AccionHistorial
  }

  export type NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel> | $Enums.AccionHistorial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionHistorialFilter<$PrismaModel>
    _max?: NestedEnumAccionHistorialFilter<$PrismaModel>
  }

  export type NestedEnumMetodoAPIFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoAPI | EnumMetodoAPIFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoAPIFilter<$PrismaModel> | $Enums.MetodoAPI
  }

  export type NestedEnumMetodoAPIWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoAPI | EnumMetodoAPIFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoAPI[] | ListEnumMetodoAPIFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoAPIWithAggregatesFilter<$PrismaModel> | $Enums.MetodoAPI
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoAPIFilter<$PrismaModel>
    _max?: NestedEnumMetodoAPIFilter<$PrismaModel>
  }

  export type NestedEnumTipoEventoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoFilter<$PrismaModel> | $Enums.TipoEvento
  }

  export type NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel> | $Enums.TipoEvento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEventoFilter<$PrismaModel>
    _max?: NestedEnumTipoEventoFilter<$PrismaModel>
  }

  export type MonAudRendCreateWithoutUsuarioInput = {
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
  }

  export type MonAudRendUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
  }

  export type MonAudRendCreateOrConnectWithoutUsuarioInput = {
    where: MonAudRendWhereUniqueInput
    create: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput>
  }

  export type MonAudRendCreateManyUsuarioInputEnvelope = {
    data: MonAudRendCreateManyUsuarioInput | MonAudRendCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ajustInvenCreateWithoutUsuarioInput = {
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutAjustInvenInput
  }

  export type ajustInvenUncheckedCreateWithoutUsuarioInput = {
    idAjuste?: number
    idProducto: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ajustInvenCreateOrConnectWithoutUsuarioInput = {
    where: ajustInvenWhereUniqueInput
    create: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput>
  }

  export type ajustInvenCreateManyUsuarioInputEnvelope = {
    data: ajustInvenCreateManyUsuarioInput | ajustInvenCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type analisisImagenesCreateWithoutUsuarioInput = {
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
  }

  export type analisisImagenesUncheckedCreateWithoutUsuarioInput = {
    id?: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
  }

  export type analisisImagenesCreateOrConnectWithoutUsuarioInput = {
    where: analisisImagenesWhereUniqueInput
    create: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput>
  }

  export type analisisImagenesCreateManyUsuarioInputEnvelope = {
    data: analisisImagenesCreateManyUsuarioInput | analisisImagenesCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type api_logsCreateWithoutUsuarioInput = {
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
  }

  export type api_logsUncheckedCreateWithoutUsuarioInput = {
    id?: number
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
  }

  export type api_logsCreateOrConnectWithoutUsuarioInput = {
    where: api_logsWhereUniqueInput
    create: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput>
  }

  export type api_logsCreateManyUsuarioInputEnvelope = {
    data: api_logsCreateManyUsuarioInput | api_logsCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type auditoriaCreateWithoutUsuarioInput = {
    evento: string
    descripcion: string
    fecha: Date | string
  }

  export type auditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    evento: string
    descripcion: string
    fecha: Date | string
  }

  export type auditoriaCreateOrConnectWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    create: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type auditoriaCreateManyUsuarioInputEnvelope = {
    data: auditoriaCreateManyUsuarioInput | auditoriaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type auteRestCreateWithoutUserInput = {
    googleId: string
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado: boolean
    confirmado: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type auteRestUncheckedCreateWithoutUserInput = {
    idSeguridad?: number
    googleId: string
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado: boolean
    confirmado: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type auteRestCreateOrConnectWithoutUserInput = {
    where: auteRestWhereUniqueInput
    create: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
  }

  export type comentariosCreateWithoutUserInput = {
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosUncheckedCreateWithoutUserInput = {
    idComentario?: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosCreateOrConnectWithoutUserInput = {
    where: comentariosWhereUniqueInput
    create: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput>
  }

  export type comentariosCreateManyUserInputEnvelope = {
    data: comentariosCreateManyUserInput | comentariosCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type histInvCreateWithoutUsuarioInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    producto: productosCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateWithoutUsuarioInput = {
    id?: number
    productoId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvCreateOrConnectWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    create: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput>
  }

  export type histInvCreateManyUsuarioInputEnvelope = {
    data: histInvCreateManyUsuarioInput | histInvCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type notificacionesCreateWithoutUserInput = {
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
  }

  export type notificacionesUncheckedCreateWithoutUserInput = {
    idNotificacion?: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
  }

  export type notificacionesCreateOrConnectWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    create: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput>
  }

  export type notificacionesCreateManyUserInputEnvelope = {
    data: notificacionesCreateManyUserInput | notificacionesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type productosCreateWithoutUsuarioInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutUsuarioInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput>
  }

  export type productosCreateManyUsuarioInputEnvelope = {
    data: productosCreateManyUsuarioInput | productosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type soporteCreateWithoutUserInput = {
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type soporteUncheckedCreateWithoutUserInput = {
    idSoporte?: number
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type soporteCreateOrConnectWithoutUserInput = {
    where: soporteWhereUniqueInput
    create: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput>
  }

  export type soporteCreateManyUserInputEnvelope = {
    data: soporteCreateManyUserInput | soporteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MonAudRendUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: MonAudRendWhereUniqueInput
    update: XOR<MonAudRendUpdateWithoutUsuarioInput, MonAudRendUncheckedUpdateWithoutUsuarioInput>
    create: XOR<MonAudRendCreateWithoutUsuarioInput, MonAudRendUncheckedCreateWithoutUsuarioInput>
  }

  export type MonAudRendUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: MonAudRendWhereUniqueInput
    data: XOR<MonAudRendUpdateWithoutUsuarioInput, MonAudRendUncheckedUpdateWithoutUsuarioInput>
  }

  export type MonAudRendUpdateManyWithWhereWithoutUsuarioInput = {
    where: MonAudRendScalarWhereInput
    data: XOR<MonAudRendUpdateManyMutationInput, MonAudRendUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type MonAudRendScalarWhereInput = {
    AND?: MonAudRendScalarWhereInput | MonAudRendScalarWhereInput[]
    OR?: MonAudRendScalarWhereInput[]
    NOT?: MonAudRendScalarWhereInput | MonAudRendScalarWhereInput[]
    id?: IntFilter<"MonAudRend"> | number
    tipoEvento?: EnumTipoEventoFilter<"MonAudRend"> | $Enums.TipoEvento
    nombreEvento?: StringFilter<"MonAudRend"> | string
    descripcion?: StringFilter<"MonAudRend"> | string
    usuarioId?: IntFilter<"MonAudRend"> | number
    fecha?: DateTimeFilter<"MonAudRend"> | Date | string
    ip_address?: StringFilter<"MonAudRend"> | string
    nivel?: StringFilter<"MonAudRend"> | string
    valor?: DecimalFilter<"MonAudRend"> | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFilter<"MonAudRend"> | string
  }

  export type ajustInvenUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ajustInvenWhereUniqueInput
    update: XOR<ajustInvenUpdateWithoutUsuarioInput, ajustInvenUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ajustInvenCreateWithoutUsuarioInput, ajustInvenUncheckedCreateWithoutUsuarioInput>
  }

  export type ajustInvenUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ajustInvenWhereUniqueInput
    data: XOR<ajustInvenUpdateWithoutUsuarioInput, ajustInvenUncheckedUpdateWithoutUsuarioInput>
  }

  export type ajustInvenUpdateManyWithWhereWithoutUsuarioInput = {
    where: ajustInvenScalarWhereInput
    data: XOR<ajustInvenUpdateManyMutationInput, ajustInvenUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ajustInvenScalarWhereInput = {
    AND?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
    OR?: ajustInvenScalarWhereInput[]
    NOT?: ajustInvenScalarWhereInput | ajustInvenScalarWhereInput[]
    idAjuste?: IntFilter<"ajustInven"> | number
    idProducto?: IntFilter<"ajustInven"> | number
    idUsuario?: IntFilter<"ajustInven"> | number
    cantidadAnterior?: IntFilter<"ajustInven"> | number
    cantidadNueva?: IntFilter<"ajustInven"> | number
    motivo?: StringFilter<"ajustInven"> | string
    createdAt?: DateTimeFilter<"ajustInven"> | Date | string
    updatedAt?: DateTimeFilter<"ajustInven"> | Date | string
  }

  export type analisisImagenesUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: analisisImagenesWhereUniqueInput
    update: XOR<analisisImagenesUpdateWithoutUsuarioInput, analisisImagenesUncheckedUpdateWithoutUsuarioInput>
    create: XOR<analisisImagenesCreateWithoutUsuarioInput, analisisImagenesUncheckedCreateWithoutUsuarioInput>
  }

  export type analisisImagenesUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: analisisImagenesWhereUniqueInput
    data: XOR<analisisImagenesUpdateWithoutUsuarioInput, analisisImagenesUncheckedUpdateWithoutUsuarioInput>
  }

  export type analisisImagenesUpdateManyWithWhereWithoutUsuarioInput = {
    where: analisisImagenesScalarWhereInput
    data: XOR<analisisImagenesUpdateManyMutationInput, analisisImagenesUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type analisisImagenesScalarWhereInput = {
    AND?: analisisImagenesScalarWhereInput | analisisImagenesScalarWhereInput[]
    OR?: analisisImagenesScalarWhereInput[]
    NOT?: analisisImagenesScalarWhereInput | analisisImagenesScalarWhereInput[]
    id?: IntFilter<"analisisImagenes"> | number
    usuarioId?: IntFilter<"analisisImagenes"> | number
    esAlimento?: BoolFilter<"analisisImagenes"> | boolean
    consulta?: StringFilter<"analisisImagenes"> | string
    respuesta?: JsonFilter<"analisisImagenes">
    fechaAnalisis?: DateTimeFilter<"analisisImagenes"> | Date | string
  }

  export type api_logsUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: api_logsWhereUniqueInput
    update: XOR<api_logsUpdateWithoutUsuarioInput, api_logsUncheckedUpdateWithoutUsuarioInput>
    create: XOR<api_logsCreateWithoutUsuarioInput, api_logsUncheckedCreateWithoutUsuarioInput>
  }

  export type api_logsUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: api_logsWhereUniqueInput
    data: XOR<api_logsUpdateWithoutUsuarioInput, api_logsUncheckedUpdateWithoutUsuarioInput>
  }

  export type api_logsUpdateManyWithWhereWithoutUsuarioInput = {
    where: api_logsScalarWhereInput
    data: XOR<api_logsUpdateManyMutationInput, api_logsUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type api_logsScalarWhereInput = {
    AND?: api_logsScalarWhereInput | api_logsScalarWhereInput[]
    OR?: api_logsScalarWhereInput[]
    NOT?: api_logsScalarWhereInput | api_logsScalarWhereInput[]
    id?: IntFilter<"api_logs"> | number
    endpoint?: StringFilter<"api_logs"> | string
    metodo?: EnumMetodoAPIFilter<"api_logs"> | $Enums.MetodoAPI
    statusCode?: IntFilter<"api_logs"> | number
    tiempoRespuesta?: DecimalFilter<"api_logs"> | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFilter<"api_logs"> | Date | string
    errorMensaje?: StringFilter<"api_logs"> | string
    usuarioId?: IntFilter<"api_logs"> | number
  }

  export type auditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    update: XOR<auditoriaUpdateWithoutUsuarioInput, auditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<auditoriaCreateWithoutUsuarioInput, auditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type auditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: auditoriaWhereUniqueInput
    data: XOR<auditoriaUpdateWithoutUsuarioInput, auditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type auditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: auditoriaScalarWhereInput
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type auditoriaScalarWhereInput = {
    AND?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    OR?: auditoriaScalarWhereInput[]
    NOT?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    id?: IntFilter<"auditoria"> | number
    evento?: StringFilter<"auditoria"> | string
    usuarioId?: IntFilter<"auditoria"> | number
    descripcion?: StringFilter<"auditoria"> | string
    fecha?: DateTimeFilter<"auditoria"> | Date | string
  }

  export type auteRestUpsertWithoutUserInput = {
    update: XOR<auteRestUpdateWithoutUserInput, auteRestUncheckedUpdateWithoutUserInput>
    create: XOR<auteRestCreateWithoutUserInput, auteRestUncheckedCreateWithoutUserInput>
    where?: auteRestWhereInput
  }

  export type auteRestUpdateToOneWithWhereWithoutUserInput = {
    where?: auteRestWhereInput
    data: XOR<auteRestUpdateWithoutUserInput, auteRestUncheckedUpdateWithoutUserInput>
  }

  export type auteRestUpdateWithoutUserInput = {
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auteRestUncheckedUpdateWithoutUserInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    googleId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUpsertWithWhereUniqueWithoutUserInput = {
    where: comentariosWhereUniqueInput
    update: XOR<comentariosUpdateWithoutUserInput, comentariosUncheckedUpdateWithoutUserInput>
    create: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput>
  }

  export type comentariosUpdateWithWhereUniqueWithoutUserInput = {
    where: comentariosWhereUniqueInput
    data: XOR<comentariosUpdateWithoutUserInput, comentariosUncheckedUpdateWithoutUserInput>
  }

  export type comentariosUpdateManyWithWhereWithoutUserInput = {
    where: comentariosScalarWhereInput
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyWithoutUserInput>
  }

  export type comentariosScalarWhereInput = {
    AND?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
    OR?: comentariosScalarWhereInput[]
    NOT?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
    idComentario?: IntFilter<"comentarios"> | number
    idUsuario?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
  }

  export type histInvUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    update: XOR<histInvUpdateWithoutUsuarioInput, histInvUncheckedUpdateWithoutUsuarioInput>
    create: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput>
  }

  export type histInvUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    data: XOR<histInvUpdateWithoutUsuarioInput, histInvUncheckedUpdateWithoutUsuarioInput>
  }

  export type histInvUpdateManyWithWhereWithoutUsuarioInput = {
    where: histInvScalarWhereInput
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type histInvScalarWhereInput = {
    AND?: histInvScalarWhereInput | histInvScalarWhereInput[]
    OR?: histInvScalarWhereInput[]
    NOT?: histInvScalarWhereInput | histInvScalarWhereInput[]
    id?: IntFilter<"histInv"> | number
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
  }

  export type notificacionesUpsertWithWhereUniqueWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    update: XOR<notificacionesUpdateWithoutUserInput, notificacionesUncheckedUpdateWithoutUserInput>
    create: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput>
  }

  export type notificacionesUpdateWithWhereUniqueWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    data: XOR<notificacionesUpdateWithoutUserInput, notificacionesUncheckedUpdateWithoutUserInput>
  }

  export type notificacionesUpdateManyWithWhereWithoutUserInput = {
    where: notificacionesScalarWhereInput
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyWithoutUserInput>
  }

  export type notificacionesScalarWhereInput = {
    AND?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
    OR?: notificacionesScalarWhereInput[]
    NOT?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
    idNotificacion?: IntFilter<"notificaciones"> | number
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
  }

  export type productosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    update: XOR<productosUpdateWithoutUsuarioInput, productosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput>
  }

  export type productosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    data: XOR<productosUpdateWithoutUsuarioInput, productosUncheckedUpdateWithoutUsuarioInput>
  }

  export type productosUpdateManyWithWhereWithoutUsuarioInput = {
    where: productosScalarWhereInput
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type productosScalarWhereInput = {
    AND?: productosScalarWhereInput | productosScalarWhereInput[]
    OR?: productosScalarWhereInput[]
    NOT?: productosScalarWhereInput | productosScalarWhereInput[]
    id?: IntFilter<"productos"> | number
    codigoBarras?: StringFilter<"productos"> | string
    codigoQR?: StringFilter<"productos"> | string
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    categoriaId?: IntFilter<"productos"> | number
    cantidad?: IntFilter<"productos"> | number
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: StringFilter<"productos"> | string
    imagen?: StringFilter<"productos"> | string
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
  }

  export type soporteUpsertWithWhereUniqueWithoutUserInput = {
    where: soporteWhereUniqueInput
    update: XOR<soporteUpdateWithoutUserInput, soporteUncheckedUpdateWithoutUserInput>
    create: XOR<soporteCreateWithoutUserInput, soporteUncheckedCreateWithoutUserInput>
  }

  export type soporteUpdateWithWhereUniqueWithoutUserInput = {
    where: soporteWhereUniqueInput
    data: XOR<soporteUpdateWithoutUserInput, soporteUncheckedUpdateWithoutUserInput>
  }

  export type soporteUpdateManyWithWhereWithoutUserInput = {
    where: soporteScalarWhereInput
    data: XOR<soporteUpdateManyMutationInput, soporteUncheckedUpdateManyWithoutUserInput>
  }

  export type soporteScalarWhereInput = {
    AND?: soporteScalarWhereInput | soporteScalarWhereInput[]
    OR?: soporteScalarWhereInput[]
    NOT?: soporteScalarWhereInput | soporteScalarWhereInput[]
    idSoporte?: IntFilter<"soporte"> | number
    idUsuario?: IntFilter<"soporte"> | number
    asunto?: StringFilter<"soporte"> | string
    descripcion?: StringFilter<"soporte"> | string
    estado?: EnumEstadoSoporteFilter<"soporte"> | $Enums.EstadoSoporte
    respuesta?: StringFilter<"soporte"> | string
    createdAt?: DateTimeFilter<"soporte"> | Date | string
    updatedAt?: DateTimeFilter<"soporte"> | Date | string
  }

  export type usersCreateWithoutAuteRestInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAuteRestInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAuteRestInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuteRestInput, usersUncheckedCreateWithoutAuteRestInput>
  }

  export type usersUpsertWithoutAuteRestInput = {
    update: XOR<usersUpdateWithoutAuteRestInput, usersUncheckedUpdateWithoutAuteRestInput>
    create: XOR<usersCreateWithoutAuteRestInput, usersUncheckedCreateWithoutAuteRestInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuteRestInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuteRestInput, usersUncheckedUpdateWithoutAuteRestInput>
  }

  export type usersUpdateWithoutAuteRestInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAuteRestInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutNotificacionesInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNotificacionesInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNotificacionesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
  }

  export type usersUpsertWithoutNotificacionesInput = {
    update: XOR<usersUpdateWithoutNotificacionesInput, usersUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificacionesInput, usersUncheckedUpdateWithoutNotificacionesInput>
  }

  export type usersUpdateWithoutNotificacionesInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificacionesInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ajustInvenCreateWithoutProductoInput = {
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: usersCreateNestedOneWithoutAjustInvenInput
  }

  export type ajustInvenUncheckedCreateWithoutProductoInput = {
    idAjuste?: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ajustInvenCreateOrConnectWithoutProductoInput = {
    where: ajustInvenWhereUniqueInput
    create: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput>
  }

  export type ajustInvenCreateManyProductoInputEnvelope = {
    data: ajustInvenCreateManyProductoInput | ajustInvenCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type alertVenCreateWithoutProductoInput = {
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type alertVenUncheckedCreateWithoutProductoInput = {
    idAlerta?: number
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type alertVenCreateOrConnectWithoutProductoInput = {
    where: alertVenWhereUniqueInput
    create: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput>
  }

  export type alertVenCreateManyProductoInputEnvelope = {
    data: alertVenCreateManyProductoInput | alertVenCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type colaboracionesCreateWithoutProductoInput = {
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type colaboracionesUncheckedCreateWithoutProductoInput = {
    id?: number
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type colaboracionesCreateOrConnectWithoutProductoInput = {
    where: colaboracionesWhereUniqueInput
    create: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput>
  }

  export type colaboracionesCreateManyProductoInputEnvelope = {
    data: colaboracionesCreateManyProductoInput | colaboracionesCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type histInvCreateWithoutProductoInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    usuario: usersCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateWithoutProductoInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvCreateOrConnectWithoutProductoInput = {
    where: histInvWhereUniqueInput
    create: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput>
  }

  export type histInvCreateManyProductoInputEnvelope = {
    data: histInvCreateManyProductoInput | histInvCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type histoVentaCreateWithoutProductoInput = {
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histoVentaUncheckedCreateWithoutProductoInput = {
    idVenta?: number
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histoVentaCreateOrConnectWithoutProductoInput = {
    where: histoVentaWhereUniqueInput
    create: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput>
  }

  export type histoVentaCreateManyProductoInputEnvelope = {
    data: histoVentaCreateManyProductoInput | histoVentaCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutProductosInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutProductosInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutProductosInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
  }

  export type recorStockCreateWithoutProductoInput = {
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUncheckedCreateWithoutProductoInput = {
    idRecordatorio?: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockCreateOrConnectWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    create: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput>
  }

  export type recorStockCreateManyProductoInputEnvelope = {
    data: recorStockCreateManyProductoInput | recorStockCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type ajustInvenUpsertWithWhereUniqueWithoutProductoInput = {
    where: ajustInvenWhereUniqueInput
    update: XOR<ajustInvenUpdateWithoutProductoInput, ajustInvenUncheckedUpdateWithoutProductoInput>
    create: XOR<ajustInvenCreateWithoutProductoInput, ajustInvenUncheckedCreateWithoutProductoInput>
  }

  export type ajustInvenUpdateWithWhereUniqueWithoutProductoInput = {
    where: ajustInvenWhereUniqueInput
    data: XOR<ajustInvenUpdateWithoutProductoInput, ajustInvenUncheckedUpdateWithoutProductoInput>
  }

  export type ajustInvenUpdateManyWithWhereWithoutProductoInput = {
    where: ajustInvenScalarWhereInput
    data: XOR<ajustInvenUpdateManyMutationInput, ajustInvenUncheckedUpdateManyWithoutProductoInput>
  }

  export type alertVenUpsertWithWhereUniqueWithoutProductoInput = {
    where: alertVenWhereUniqueInput
    update: XOR<alertVenUpdateWithoutProductoInput, alertVenUncheckedUpdateWithoutProductoInput>
    create: XOR<alertVenCreateWithoutProductoInput, alertVenUncheckedCreateWithoutProductoInput>
  }

  export type alertVenUpdateWithWhereUniqueWithoutProductoInput = {
    where: alertVenWhereUniqueInput
    data: XOR<alertVenUpdateWithoutProductoInput, alertVenUncheckedUpdateWithoutProductoInput>
  }

  export type alertVenUpdateManyWithWhereWithoutProductoInput = {
    where: alertVenScalarWhereInput
    data: XOR<alertVenUpdateManyMutationInput, alertVenUncheckedUpdateManyWithoutProductoInput>
  }

  export type alertVenScalarWhereInput = {
    AND?: alertVenScalarWhereInput | alertVenScalarWhereInput[]
    OR?: alertVenScalarWhereInput[]
    NOT?: alertVenScalarWhereInput | alertVenScalarWhereInput[]
    idAlerta?: IntFilter<"alertVen"> | number
    idProducto?: IntFilter<"alertVen"> | number
    fechaAlerta?: DateTimeFilter<"alertVen"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"alertVen"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"alertVen"> | Date | string
    updatedAt?: DateTimeFilter<"alertVen"> | Date | string
  }

  export type colaboracionesUpsertWithWhereUniqueWithoutProductoInput = {
    where: colaboracionesWhereUniqueInput
    update: XOR<colaboracionesUpdateWithoutProductoInput, colaboracionesUncheckedUpdateWithoutProductoInput>
    create: XOR<colaboracionesCreateWithoutProductoInput, colaboracionesUncheckedCreateWithoutProductoInput>
  }

  export type colaboracionesUpdateWithWhereUniqueWithoutProductoInput = {
    where: colaboracionesWhereUniqueInput
    data: XOR<colaboracionesUpdateWithoutProductoInput, colaboracionesUncheckedUpdateWithoutProductoInput>
  }

  export type colaboracionesUpdateManyWithWhereWithoutProductoInput = {
    where: colaboracionesScalarWhereInput
    data: XOR<colaboracionesUpdateManyMutationInput, colaboracionesUncheckedUpdateManyWithoutProductoInput>
  }

  export type colaboracionesScalarWhereInput = {
    AND?: colaboracionesScalarWhereInput | colaboracionesScalarWhereInput[]
    OR?: colaboracionesScalarWhereInput[]
    NOT?: colaboracionesScalarWhereInput | colaboracionesScalarWhereInput[]
    id?: IntFilter<"colaboraciones"> | number
    productoId?: IntFilter<"colaboraciones"> | number
    marca?: StringFilter<"colaboraciones"> | string
    tarifa?: DecimalFilter<"colaboraciones"> | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFilter<"colaboraciones"> | Date | string
    fechaFin?: DateTimeFilter<"colaboraciones"> | Date | string
  }

  export type histInvUpsertWithWhereUniqueWithoutProductoInput = {
    where: histInvWhereUniqueInput
    update: XOR<histInvUpdateWithoutProductoInput, histInvUncheckedUpdateWithoutProductoInput>
    create: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput>
  }

  export type histInvUpdateWithWhereUniqueWithoutProductoInput = {
    where: histInvWhereUniqueInput
    data: XOR<histInvUpdateWithoutProductoInput, histInvUncheckedUpdateWithoutProductoInput>
  }

  export type histInvUpdateManyWithWhereWithoutProductoInput = {
    where: histInvScalarWhereInput
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyWithoutProductoInput>
  }

  export type histoVentaUpsertWithWhereUniqueWithoutProductoInput = {
    where: histoVentaWhereUniqueInput
    update: XOR<histoVentaUpdateWithoutProductoInput, histoVentaUncheckedUpdateWithoutProductoInput>
    create: XOR<histoVentaCreateWithoutProductoInput, histoVentaUncheckedCreateWithoutProductoInput>
  }

  export type histoVentaUpdateWithWhereUniqueWithoutProductoInput = {
    where: histoVentaWhereUniqueInput
    data: XOR<histoVentaUpdateWithoutProductoInput, histoVentaUncheckedUpdateWithoutProductoInput>
  }

  export type histoVentaUpdateManyWithWhereWithoutProductoInput = {
    where: histoVentaScalarWhereInput
    data: XOR<histoVentaUpdateManyMutationInput, histoVentaUncheckedUpdateManyWithoutProductoInput>
  }

  export type histoVentaScalarWhereInput = {
    AND?: histoVentaScalarWhereInput | histoVentaScalarWhereInput[]
    OR?: histoVentaScalarWhereInput[]
    NOT?: histoVentaScalarWhereInput | histoVentaScalarWhereInput[]
    idVenta?: IntFilter<"histoVenta"> | number
    idProducto?: IntFilter<"histoVenta"> | number
    cantidadVendida?: IntFilter<"histoVenta"> | number
    fechaVenta?: DateTimeFilter<"histoVenta"> | Date | string
    createdAt?: DateTimeFilter<"histoVenta"> | Date | string
    updatedAt?: DateTimeFilter<"histoVenta"> | Date | string
  }

  export type usersUpsertWithoutProductosInput = {
    update: XOR<usersUpdateWithoutProductosInput, usersUncheckedUpdateWithoutProductosInput>
    create: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProductosInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProductosInput, usersUncheckedUpdateWithoutProductosInput>
  }

  export type usersUpdateWithoutProductosInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutProductosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type recorStockUpsertWithWhereUniqueWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    update: XOR<recorStockUpdateWithoutProductoInput, recorStockUncheckedUpdateWithoutProductoInput>
    create: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput>
  }

  export type recorStockUpdateWithWhereUniqueWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    data: XOR<recorStockUpdateWithoutProductoInput, recorStockUncheckedUpdateWithoutProductoInput>
  }

  export type recorStockUpdateManyWithWhereWithoutProductoInput = {
    where: recorStockScalarWhereInput
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyWithoutProductoInput>
  }

  export type recorStockScalarWhereInput = {
    AND?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
    OR?: recorStockScalarWhereInput[]
    NOT?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
    idRecordatorio?: IntFilter<"recorStock"> | number
    idProducto?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
  }

  export type productosCreateWithoutHistoVentaInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutHistoVentaInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutHistoVentaInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutHistoVentaInput, productosUncheckedCreateWithoutHistoVentaInput>
  }

  export type productosUpsertWithoutHistoVentaInput = {
    update: XOR<productosUpdateWithoutHistoVentaInput, productosUncheckedUpdateWithoutHistoVentaInput>
    create: XOR<productosCreateWithoutHistoVentaInput, productosUncheckedCreateWithoutHistoVentaInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutHistoVentaInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutHistoVentaInput, productosUncheckedUpdateWithoutHistoVentaInput>
  }

  export type productosUpdateWithoutHistoVentaInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutHistoVentaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosCreateWithoutRecorStockInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
  }

  export type productosUncheckedCreateWithoutRecorStockInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutRecorStockInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
  }

  export type productosUpsertWithoutRecorStockInput = {
    update: XOR<productosUpdateWithoutRecorStockInput, productosUncheckedUpdateWithoutRecorStockInput>
    create: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutRecorStockInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutRecorStockInput, productosUncheckedUpdateWithoutRecorStockInput>
  }

  export type productosUpdateWithoutRecorStockInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
  }

  export type productosUncheckedUpdateWithoutRecorStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersCreateWithoutComentariosInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutComentariosInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutComentariosInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
  }

  export type usersUpsertWithoutComentariosInput = {
    update: XOR<usersUpdateWithoutComentariosInput, usersUncheckedUpdateWithoutComentariosInput>
    create: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutComentariosInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutComentariosInput, usersUncheckedUpdateWithoutComentariosInput>
  }

  export type usersUpdateWithoutComentariosInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutComentariosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutSoporteInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
  }

  export type usersUncheckedCreateWithoutSoporteInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usersCreateOrConnectWithoutSoporteInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSoporteInput, usersUncheckedCreateWithoutSoporteInput>
  }

  export type usersUpsertWithoutSoporteInput = {
    update: XOR<usersUpdateWithoutSoporteInput, usersUncheckedUpdateWithoutSoporteInput>
    create: XOR<usersCreateWithoutSoporteInput, usersUncheckedCreateWithoutSoporteInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSoporteInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSoporteInput, usersUncheckedUpdateWithoutSoporteInput>
  }

  export type usersUpdateWithoutSoporteInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
  }

  export type usersUncheckedUpdateWithoutSoporteInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type productosCreateWithoutAjustInvenInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutAjustInvenInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutAjustInvenInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutAjustInvenInput, productosUncheckedCreateWithoutAjustInvenInput>
  }

  export type usersCreateWithoutAjustInvenInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAjustInvenInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAjustInvenInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAjustInvenInput, usersUncheckedCreateWithoutAjustInvenInput>
  }

  export type productosUpsertWithoutAjustInvenInput = {
    update: XOR<productosUpdateWithoutAjustInvenInput, productosUncheckedUpdateWithoutAjustInvenInput>
    create: XOR<productosCreateWithoutAjustInvenInput, productosUncheckedCreateWithoutAjustInvenInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutAjustInvenInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutAjustInvenInput, productosUncheckedUpdateWithoutAjustInvenInput>
  }

  export type productosUpdateWithoutAjustInvenInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutAjustInvenInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersUpsertWithoutAjustInvenInput = {
    update: XOR<usersUpdateWithoutAjustInvenInput, usersUncheckedUpdateWithoutAjustInvenInput>
    create: XOR<usersCreateWithoutAjustInvenInput, usersUncheckedCreateWithoutAjustInvenInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAjustInvenInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAjustInvenInput, usersUncheckedUpdateWithoutAjustInvenInput>
  }

  export type usersUpdateWithoutAjustInvenInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAjustInvenInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productosCreateWithoutAlertVenInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutAlertVenInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutAlertVenInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutAlertVenInput, productosUncheckedCreateWithoutAlertVenInput>
  }

  export type productosUpsertWithoutAlertVenInput = {
    update: XOR<productosUpdateWithoutAlertVenInput, productosUncheckedUpdateWithoutAlertVenInput>
    create: XOR<productosCreateWithoutAlertVenInput, productosUncheckedCreateWithoutAlertVenInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutAlertVenInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutAlertVenInput, productosUncheckedUpdateWithoutAlertVenInput>
  }

  export type productosUpdateWithoutAlertVenInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutAlertVenInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersCreateWithoutAnalisisImagenesInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAnalisisImagenesInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAnalisisImagenesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAnalisisImagenesInput, usersUncheckedCreateWithoutAnalisisImagenesInput>
  }

  export type usersUpsertWithoutAnalisisImagenesInput = {
    update: XOR<usersUpdateWithoutAnalisisImagenesInput, usersUncheckedUpdateWithoutAnalisisImagenesInput>
    create: XOR<usersCreateWithoutAnalisisImagenesInput, usersUncheckedCreateWithoutAnalisisImagenesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAnalisisImagenesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAnalisisImagenesInput, usersUncheckedUpdateWithoutAnalisisImagenesInput>
  }

  export type usersUpdateWithoutAnalisisImagenesInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAnalisisImagenesInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productosCreateWithoutColaboracionesInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    histInv?: histInvCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutColaboracionesInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutColaboracionesInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutColaboracionesInput, productosUncheckedCreateWithoutColaboracionesInput>
  }

  export type productosUpsertWithoutColaboracionesInput = {
    update: XOR<productosUpdateWithoutColaboracionesInput, productosUncheckedUpdateWithoutColaboracionesInput>
    create: XOR<productosCreateWithoutColaboracionesInput, productosUncheckedCreateWithoutColaboracionesInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutColaboracionesInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutColaboracionesInput, productosUncheckedUpdateWithoutColaboracionesInput>
  }

  export type productosUpdateWithoutColaboracionesInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutColaboracionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosCreateWithoutHistInvInput = {
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenCreateNestedManyWithoutProductoInput
    alertVen?: alertVenCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutHistInvInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutProductoInput
    alertVen?: alertVenUncheckedCreateNestedManyWithoutProductoInput
    colaboraciones?: colaboracionesUncheckedCreateNestedManyWithoutProductoInput
    histoVenta?: histoVentaUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutHistInvInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
  }

  export type usersCreateWithoutHistInvInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutHistInvInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutHistInvInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
  }

  export type productosUpsertWithoutHistInvInput = {
    update: XOR<productosUpdateWithoutHistInvInput, productosUncheckedUpdateWithoutHistInvInput>
    create: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutHistInvInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutHistInvInput, productosUncheckedUpdateWithoutHistInvInput>
  }

  export type productosUpdateWithoutHistInvInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutHistInvInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersUpsertWithoutHistInvInput = {
    update: XOR<usersUpdateWithoutHistInvInput, usersUncheckedUpdateWithoutHistInvInput>
    create: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutHistInvInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutHistInvInput, usersUncheckedUpdateWithoutHistInvInput>
  }

  export type usersUpdateWithoutHistInvInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutHistInvInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutApi_logsInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutApi_logsInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutApi_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutApi_logsInput, usersUncheckedCreateWithoutApi_logsInput>
  }

  export type usersUpsertWithoutApi_logsInput = {
    update: XOR<usersUpdateWithoutApi_logsInput, usersUncheckedUpdateWithoutApi_logsInput>
    create: XOR<usersCreateWithoutApi_logsInput, usersUncheckedCreateWithoutApi_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutApi_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutApi_logsInput, usersUncheckedUpdateWithoutApi_logsInput>
  }

  export type usersUpdateWithoutApi_logsInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutApi_logsInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutMonAudRendInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutMonAudRendInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutMonAudRendInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMonAudRendInput, usersUncheckedCreateWithoutMonAudRendInput>
  }

  export type usersUpsertWithoutMonAudRendInput = {
    update: XOR<usersUpdateWithoutMonAudRendInput, usersUncheckedUpdateWithoutMonAudRendInput>
    create: XOR<usersCreateWithoutMonAudRendInput, usersUncheckedCreateWithoutMonAudRendInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMonAudRendInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMonAudRendInput, usersUncheckedUpdateWithoutMonAudRendInput>
  }

  export type usersUpdateWithoutMonAudRendInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutMonAudRendInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAuditoriaInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestCreateNestedOneWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    soporte?: soporteCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAuditoriaInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    rolEquipo?: $Enums.rolEquipo | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tipoUsuario: $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedCreateNestedManyWithoutUsuarioInput
    ajustInven?: ajustInvenUncheckedCreateNestedManyWithoutUsuarioInput
    analisisImagenes?: analisisImagenesUncheckedCreateNestedManyWithoutUsuarioInput
    api_logs?: api_logsUncheckedCreateNestedManyWithoutUsuarioInput
    auteRest?: auteRestUncheckedCreateNestedOneWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    soporte?: soporteUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAuditoriaInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuditoriaInput, usersUncheckedCreateWithoutAuditoriaInput>
  }

  export type usersUpsertWithoutAuditoriaInput = {
    update: XOR<usersUpdateWithoutAuditoriaInput, usersUncheckedUpdateWithoutAuditoriaInput>
    create: XOR<usersCreateWithoutAuditoriaInput, usersUncheckedCreateWithoutAuditoriaInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuditoriaInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuditoriaInput, usersUncheckedUpdateWithoutAuditoriaInput>
  }

  export type usersUpdateWithoutAuditoriaInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAuditoriaInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: StringFieldUpdateOperationsInput | string
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    MonAudRend?: MonAudRendUncheckedUpdateManyWithoutUsuarioNestedInput
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutUsuarioNestedInput
    analisisImagenes?: analisisImagenesUncheckedUpdateManyWithoutUsuarioNestedInput
    api_logs?: api_logsUncheckedUpdateManyWithoutUsuarioNestedInput
    auteRest?: auteRestUncheckedUpdateOneWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    soporte?: soporteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MonAudRendCreateManyUsuarioInput = {
    id?: number
    tipoEvento: $Enums.TipoEvento
    nombreEvento: string
    descripcion: string
    fecha: Date | string
    ip_address: string
    nivel: string
    valor: Decimal | DecimalJsLike | number | string
    stackTrace: string
  }

  export type ajustInvenCreateManyUsuarioInput = {
    idAjuste?: number
    idProducto: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type analisisImagenesCreateManyUsuarioInput = {
    id?: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    fechaAnalisis: Date | string
  }

  export type api_logsCreateManyUsuarioInput = {
    id?: number
    endpoint: string
    metodo: $Enums.MetodoAPI
    statusCode: number
    tiempoRespuesta: Decimal | DecimalJsLike | number | string
    fecha: Date | string
    errorMensaje: string
  }

  export type auditoriaCreateManyUsuarioInput = {
    id?: number
    evento: string
    descripcion: string
    fecha: Date | string
  }

  export type comentariosCreateManyUserInput = {
    idComentario?: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histInvCreateManyUsuarioInput = {
    id?: number
    productoId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type notificacionesCreateManyUserInput = {
    idNotificacion?: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date | string
    leida: boolean
  }

  export type productosCreateManyUsuarioInput = {
    id?: number
    codigoBarras: string
    codigoQR: string
    nombre: string
    descripcion: string
    categoriaId: number
    cantidad: number
    precio: Decimal | DecimalJsLike | number | string
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: string
    imagen: string
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
  }

  export type soporteCreateManyUserInput = {
    idSoporte?: number
    asunto: string
    descripcion: string
    estado: $Enums.EstadoSoporte
    respuesta: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MonAudRendUpdateWithoutUsuarioInput = {
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type MonAudRendUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type MonAudRendUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoEvento?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    nombreEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    ip_address?: StringFieldUpdateOperationsInput | string
    nivel?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stackTrace?: StringFieldUpdateOperationsInput | string
  }

  export type ajustInvenUpdateWithoutUsuarioInput = {
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutAjustInvenNestedInput
  }

  export type ajustInvenUncheckedUpdateWithoutUsuarioInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenUncheckedUpdateManyWithoutUsuarioInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesUpdateWithoutUsuarioInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type analisisImagenesUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_logsUpdateWithoutUsuarioInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
  }

  export type api_logsUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
  }

  export type api_logsUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    metodo?: EnumMetodoAPIFieldUpdateOperationsInput | $Enums.MetodoAPI
    statusCode?: IntFieldUpdateOperationsInput | number
    tiempoRespuesta?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMensaje?: StringFieldUpdateOperationsInput | string
  }

  export type auditoriaUpdateWithoutUsuarioInput = {
    evento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    evento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    evento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUpdateWithoutUserInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateWithoutUserInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyWithoutUserInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUpdateWithoutUsuarioInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificacionesUpdateWithoutUserInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateWithoutUserInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateManyWithoutUserInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productosUpdateWithoutUsuarioInput = {
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUpdateManyWithoutProductoNestedInput
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ajustInven?: ajustInvenUncheckedUpdateManyWithoutProductoNestedInput
    alertVen?: alertVenUncheckedUpdateManyWithoutProductoNestedInput
    colaboraciones?: colaboracionesUncheckedUpdateManyWithoutProductoNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    histoVenta?: histoVentaUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: StringFieldUpdateOperationsInput | string
    codigoQR?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    categoriaId?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    imagen?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type soporteUpdateWithoutUserInput = {
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soporteUncheckedUpdateWithoutUserInput = {
    idSoporte?: IntFieldUpdateOperationsInput | number
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type soporteUncheckedUpdateManyWithoutUserInput = {
    idSoporte?: IntFieldUpdateOperationsInput | number
    asunto?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoSoporteFieldUpdateOperationsInput | $Enums.EstadoSoporte
    respuesta?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenCreateManyProductoInput = {
    idAjuste?: number
    idUsuario: number
    cantidadAnterior: number
    cantidadNueva: number
    motivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type alertVenCreateManyProductoInput = {
    idAlerta?: number
    fechaAlerta: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type colaboracionesCreateManyProductoInput = {
    id?: number
    marca: string
    tarifa: Decimal | DecimalJsLike | number | string
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type histInvCreateManyProductoInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histoVentaCreateManyProductoInput = {
    idVenta?: number
    cantidadVendida: number
    fechaVenta: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockCreateManyProductoInput = {
    idRecordatorio?: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ajustInvenUpdateWithoutProductoInput = {
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usersUpdateOneRequiredWithoutAjustInvenNestedInput
  }

  export type ajustInvenUncheckedUpdateWithoutProductoInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ajustInvenUncheckedUpdateManyWithoutProductoInput = {
    idAjuste?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    cantidadAnterior?: IntFieldUpdateOperationsInput | number
    cantidadNueva?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenUpdateWithoutProductoInput = {
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenUncheckedUpdateWithoutProductoInput = {
    idAlerta?: IntFieldUpdateOperationsInput | number
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertVenUncheckedUpdateManyWithoutProductoInput = {
    idAlerta?: IntFieldUpdateOperationsInput | number
    fechaAlerta?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesUpdateWithoutProductoInput = {
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type colaboracionesUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    marca?: StringFieldUpdateOperationsInput | string
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUpdateWithoutProductoInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usersUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histoVentaUpdateWithoutProductoInput = {
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histoVentaUncheckedUpdateWithoutProductoInput = {
    idVenta?: IntFieldUpdateOperationsInput | number
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histoVentaUncheckedUpdateManyWithoutProductoInput = {
    idVenta?: IntFieldUpdateOperationsInput | number
    cantidadVendida?: IntFieldUpdateOperationsInput | number
    fechaVenta?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUpdateWithoutProductoInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateWithoutProductoInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateManyWithoutProductoInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}