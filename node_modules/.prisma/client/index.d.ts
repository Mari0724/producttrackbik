
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model passwordReset
 * 
 */
export type passwordReset = $Result.DefaultSelection<Prisma.$passwordResetPayload>
/**
 * Model notificaciones
 * 
 */
export type notificaciones = $Result.DefaultSelection<Prisma.$notificacionesPayload>
/**
 * Model preferenciasNotificaciones
 * 
 */
export type preferenciasNotificaciones = $Result.DefaultSelection<Prisma.$preferenciasNotificacionesPayload>
/**
 * Model productos
 * 
 */
export type productos = $Result.DefaultSelection<Prisma.$productosPayload>
/**
 * Model recorStock
 * 
 */
export type recorStock = $Result.DefaultSelection<Prisma.$recorStockPayload>
/**
 * Model comentarios
 * 
 */
export type comentarios = $Result.DefaultSelection<Prisma.$comentariosPayload>
/**
 * Model NutriScan
 * 
 */
export type NutriScan = $Result.DefaultSelection<Prisma.$NutriScanPayload>
/**
 * Model histInv
 * 
 */
export type histInv = $Result.DefaultSelection<Prisma.$histInvPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoUsuario: {
  INDIVIDUAL: 'INDIVIDUAL',
  EMPRESARIAL: 'EMPRESARIAL'
};

export type TipoUsuario = (typeof TipoUsuario)[keyof typeof TipoUsuario]


export const rol: {
  USUARIO: 'USUARIO',
  EQUIPO: 'EQUIPO',
  ADMIN: 'ADMIN',
  DESARROLLADOR: 'DESARROLLADOR'
};

export type rol = (typeof rol)[keyof typeof rol]


export const rolEquipo: {
  LECTOR: 'LECTOR',
  COMENTARISTA: 'COMENTARISTA',
  EDITOR: 'EDITOR'
};

export type rolEquipo = (typeof rolEquipo)[keyof typeof rolEquipo]


export const EstadoProducto: {
  DISPONIBLE: 'DISPONIBLE',
  AGOTADO: 'AGOTADO',
  RESERVADO: 'RESERVADO',
  VENCIDO: 'VENCIDO',
  ELIMINADO: 'ELIMINADO'
};

export type EstadoProducto = (typeof EstadoProducto)[keyof typeof EstadoProducto]


export const TipoNotificacion: {
  STOCK_BAJO: 'STOCK_BAJO',
  PRODUCTO_VENCIDO: 'PRODUCTO_VENCIDO',
  ACTUALIZACION_APP: 'ACTUALIZACION_APP',
  COMENTARIO_EQUIPO: 'COMENTARIO_EQUIPO',
  REPOSICION_RECOMENDADA: 'REPOSICION_RECOMENDADA',
  PRODUCTO_POR_VENCER: 'PRODUCTO_POR_VENCER',
  RECOMENDACION: 'RECOMENDACION'
};

export type TipoNotificacion = (typeof TipoNotificacion)[keyof typeof TipoNotificacion]


export const EstadoRecordatorio: {
  PENDIENTE: 'PENDIENTE',
  ENVIADO: 'ENVIADO',
  CANCELADO: 'CANCELADO'
};

export type EstadoRecordatorio = (typeof EstadoRecordatorio)[keyof typeof EstadoRecordatorio]


export const EstadoComentario: {
  pendiente: 'pendiente',
  revisado: 'revisado'
};

export type EstadoComentario = (typeof EstadoComentario)[keyof typeof EstadoComentario]


export const AccionHistorial: {
  agregado: 'agregado',
  modificado: 'modificado',
  eliminado: 'eliminado'
};

export type AccionHistorial = (typeof AccionHistorial)[keyof typeof AccionHistorial]

}

export type TipoUsuario = $Enums.TipoUsuario

export const TipoUsuario: typeof $Enums.TipoUsuario

export type rol = $Enums.rol

export const rol: typeof $Enums.rol

export type rolEquipo = $Enums.rolEquipo

export const rolEquipo: typeof $Enums.rolEquipo

export type EstadoProducto = $Enums.EstadoProducto

export const EstadoProducto: typeof $Enums.EstadoProducto

export type TipoNotificacion = $Enums.TipoNotificacion

export const TipoNotificacion: typeof $Enums.TipoNotificacion

export type EstadoRecordatorio = $Enums.EstadoRecordatorio

export const EstadoRecordatorio: typeof $Enums.EstadoRecordatorio

export type EstadoComentario = $Enums.EstadoComentario

export const EstadoComentario: typeof $Enums.EstadoComentario

export type AccionHistorial = $Enums.AccionHistorial

export const AccionHistorial: typeof $Enums.AccionHistorial

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **passwordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.passwordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificaciones`: Exposes CRUD operations for the **notificaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificaciones
    * const notificaciones = await prisma.notificaciones.findMany()
    * ```
    */
  get notificaciones(): Prisma.notificacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preferenciasNotificaciones`: Exposes CRUD operations for the **preferenciasNotificaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreferenciasNotificaciones
    * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findMany()
    * ```
    */
  get preferenciasNotificaciones(): Prisma.preferenciasNotificacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productos`: Exposes CRUD operations for the **productos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.productos.findMany()
    * ```
    */
  get productos(): Prisma.productosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recorStock`: Exposes CRUD operations for the **recorStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecorStocks
    * const recorStocks = await prisma.recorStock.findMany()
    * ```
    */
  get recorStock(): Prisma.recorStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comentarios`: Exposes CRUD operations for the **comentarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentarios.findMany()
    * ```
    */
  get comentarios(): Prisma.comentariosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutriScan`: Exposes CRUD operations for the **NutriScan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutriScans
    * const nutriScans = await prisma.nutriScan.findMany()
    * ```
    */
  get nutriScan(): Prisma.NutriScanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histInv`: Exposes CRUD operations for the **histInv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistInvs
    * const histInvs = await prisma.histInv.findMany()
    * ```
    */
  get histInv(): Prisma.histInvDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    passwordReset: 'passwordReset',
    notificaciones: 'notificaciones',
    preferenciasNotificaciones: 'preferenciasNotificaciones',
    productos: 'productos',
    recorStock: 'recorStock',
    comentarios: 'comentarios',
    NutriScan: 'NutriScan',
    histInv: 'histInv'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "passwordReset" | "notificaciones" | "preferenciasNotificaciones" | "productos" | "recorStock" | "comentarios" | "nutriScan" | "histInv"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      passwordReset: {
        payload: Prisma.$passwordResetPayload<ExtArgs>
        fields: Prisma.passwordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.passwordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.passwordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          findFirst: {
            args: Prisma.passwordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.passwordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          findMany: {
            args: Prisma.passwordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>[]
          }
          create: {
            args: Prisma.passwordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          createMany: {
            args: Prisma.passwordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.passwordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>[]
          }
          delete: {
            args: Prisma.passwordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          update: {
            args: Prisma.passwordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          deleteMany: {
            args: Prisma.passwordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.passwordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.passwordResetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>[]
          }
          upsert: {
            args: Prisma.passwordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passwordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.passwordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.passwordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      notificaciones: {
        payload: Prisma.$notificacionesPayload<ExtArgs>
        fields: Prisma.notificacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          findFirst: {
            args: Prisma.notificacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          findMany: {
            args: Prisma.notificacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          create: {
            args: Prisma.notificacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          createMany: {
            args: Prisma.notificacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          delete: {
            args: Prisma.notificacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          update: {
            args: Prisma.notificacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          deleteMany: {
            args: Prisma.notificacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>[]
          }
          upsert: {
            args: Prisma.notificacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificacionesPayload>
          }
          aggregate: {
            args: Prisma.NotificacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificaciones>
          }
          groupBy: {
            args: Prisma.notificacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificacionesCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionesCountAggregateOutputType> | number
          }
        }
      }
      preferenciasNotificaciones: {
        payload: Prisma.$preferenciasNotificacionesPayload<ExtArgs>
        fields: Prisma.preferenciasNotificacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preferenciasNotificacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preferenciasNotificacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          findFirst: {
            args: Prisma.preferenciasNotificacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preferenciasNotificacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          findMany: {
            args: Prisma.preferenciasNotificacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>[]
          }
          create: {
            args: Prisma.preferenciasNotificacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          createMany: {
            args: Prisma.preferenciasNotificacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.preferenciasNotificacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>[]
          }
          delete: {
            args: Prisma.preferenciasNotificacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          update: {
            args: Prisma.preferenciasNotificacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          deleteMany: {
            args: Prisma.preferenciasNotificacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preferenciasNotificacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.preferenciasNotificacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>[]
          }
          upsert: {
            args: Prisma.preferenciasNotificacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preferenciasNotificacionesPayload>
          }
          aggregate: {
            args: Prisma.PreferenciasNotificacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreferenciasNotificaciones>
          }
          groupBy: {
            args: Prisma.preferenciasNotificacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreferenciasNotificacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.preferenciasNotificacionesCountArgs<ExtArgs>
            result: $Utils.Optional<PreferenciasNotificacionesCountAggregateOutputType> | number
          }
        }
      }
      productos: {
        payload: Prisma.$productosPayload<ExtArgs>
        fields: Prisma.productosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          findFirst: {
            args: Prisma.productosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          findMany: {
            args: Prisma.productosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          create: {
            args: Prisma.productosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          createMany: {
            args: Prisma.productosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          delete: {
            args: Prisma.productosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          update: {
            args: Prisma.productosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          deleteMany: {
            args: Prisma.productosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>[]
          }
          upsert: {
            args: Prisma.productosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productosPayload>
          }
          aggregate: {
            args: Prisma.ProductosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductos>
          }
          groupBy: {
            args: Prisma.productosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductosGroupByOutputType>[]
          }
          count: {
            args: Prisma.productosCountArgs<ExtArgs>
            result: $Utils.Optional<ProductosCountAggregateOutputType> | number
          }
        }
      }
      recorStock: {
        payload: Prisma.$recorStockPayload<ExtArgs>
        fields: Prisma.recorStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recorStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recorStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          findFirst: {
            args: Prisma.recorStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recorStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          findMany: {
            args: Prisma.recorStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          create: {
            args: Prisma.recorStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          createMany: {
            args: Prisma.recorStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recorStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          delete: {
            args: Prisma.recorStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          update: {
            args: Prisma.recorStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          deleteMany: {
            args: Prisma.recorStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recorStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recorStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>[]
          }
          upsert: {
            args: Prisma.recorStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recorStockPayload>
          }
          aggregate: {
            args: Prisma.RecorStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecorStock>
          }
          groupBy: {
            args: Prisma.recorStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecorStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.recorStockCountArgs<ExtArgs>
            result: $Utils.Optional<RecorStockCountAggregateOutputType> | number
          }
        }
      }
      comentarios: {
        payload: Prisma.$comentariosPayload<ExtArgs>
        fields: Prisma.comentariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comentariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comentariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          findFirst: {
            args: Prisma.comentariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comentariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          findMany: {
            args: Prisma.comentariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          create: {
            args: Prisma.comentariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          createMany: {
            args: Prisma.comentariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comentariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          delete: {
            args: Prisma.comentariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          update: {
            args: Prisma.comentariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          deleteMany: {
            args: Prisma.comentariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comentariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comentariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>[]
          }
          upsert: {
            args: Prisma.comentariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentariosPayload>
          }
          aggregate: {
            args: Prisma.ComentariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentarios>
          }
          groupBy: {
            args: Prisma.comentariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.comentariosCountArgs<ExtArgs>
            result: $Utils.Optional<ComentariosCountAggregateOutputType> | number
          }
        }
      }
      NutriScan: {
        payload: Prisma.$NutriScanPayload<ExtArgs>
        fields: Prisma.NutriScanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutriScanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutriScanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          findFirst: {
            args: Prisma.NutriScanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutriScanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          findMany: {
            args: Prisma.NutriScanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>[]
          }
          create: {
            args: Prisma.NutriScanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          createMany: {
            args: Prisma.NutriScanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutriScanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>[]
          }
          delete: {
            args: Prisma.NutriScanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          update: {
            args: Prisma.NutriScanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          deleteMany: {
            args: Prisma.NutriScanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutriScanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutriScanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>[]
          }
          upsert: {
            args: Prisma.NutriScanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutriScanPayload>
          }
          aggregate: {
            args: Prisma.NutriScanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutriScan>
          }
          groupBy: {
            args: Prisma.NutriScanGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutriScanGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutriScanCountArgs<ExtArgs>
            result: $Utils.Optional<NutriScanCountAggregateOutputType> | number
          }
        }
      }
      histInv: {
        payload: Prisma.$histInvPayload<ExtArgs>
        fields: Prisma.histInvFieldRefs
        operations: {
          findUnique: {
            args: Prisma.histInvFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.histInvFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          findFirst: {
            args: Prisma.histInvFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.histInvFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          findMany: {
            args: Prisma.histInvFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          create: {
            args: Prisma.histInvCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          createMany: {
            args: Prisma.histInvCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.histInvCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          delete: {
            args: Prisma.histInvDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          update: {
            args: Prisma.histInvUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          deleteMany: {
            args: Prisma.histInvDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.histInvUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.histInvUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>[]
          }
          upsert: {
            args: Prisma.histInvUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$histInvPayload>
          }
          aggregate: {
            args: Prisma.HistInvAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistInv>
          }
          groupBy: {
            args: Prisma.histInvGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistInvGroupByOutputType>[]
          }
          count: {
            args: Prisma.histInvCountArgs<ExtArgs>
            result: $Utils.Optional<HistInvCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    passwordReset?: passwordResetOmit
    notificaciones?: notificacionesOmit
    preferenciasNotificaciones?: preferenciasNotificacionesOmit
    productos?: productosOmit
    recorStock?: recorStockOmit
    comentarios?: comentariosOmit
    nutriScan?: NutriScanOmit
    histInv?: histInvOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    miembros: number
    passwordResets: number
    notificaciones: number
    productos: number
    comentarios: number
    nutriScans: number
    histInv: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miembros?: boolean | UsersCountOutputTypeCountMiembrosArgs
    passwordResets?: boolean | UsersCountOutputTypeCountPasswordResetsArgs
    notificaciones?: boolean | UsersCountOutputTypeCountNotificacionesArgs
    productos?: boolean | UsersCountOutputTypeCountProductosArgs
    comentarios?: boolean | UsersCountOutputTypeCountComentariosArgs
    nutriScans?: boolean | UsersCountOutputTypeCountNutriScansArgs
    histInv?: boolean | UsersCountOutputTypeCountHistInvArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMiembrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passwordResetWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificacionesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productosWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentariosWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNutriScansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutriScanWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountHistInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
  }


  /**
   * Count Type ProductosCountOutputType
   */

  export type ProductosCountOutputType = {
    histInv: number
    recorStock: number
    comentarios: number
  }

  export type ProductosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histInv?: boolean | ProductosCountOutputTypeCountHistInvArgs
    recorStock?: boolean | ProductosCountOutputTypeCountRecorStockArgs
    comentarios?: boolean | ProductosCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductosCountOutputType
     */
    select?: ProductosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountHistInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountRecorStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recorStockWhereInput
  }

  /**
   * ProductosCountOutputType without action
   */
  export type ProductosCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentariosWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    idUsuario: number | null
    empresaId: number | null
  }

  export type UsersSumAggregateOutputType = {
    idUsuario: number | null
    empresaId: number | null
  }

  export type UsersMinAggregateOutputType = {
    idUsuario: number | null
    username: string | null
    correo: string | null
    password: string | null
    nombreCompleto: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfil: string | null
    nombreEmpresa: string | null
    nit: string | null
    estado: string | null
    rol: string | null
    tipoUsuario: $Enums.TipoUsuario | null
    rolEquipo: $Enums.rolEquipo | null
    perfilCompleto: boolean | null
    empresaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    idUsuario: number | null
    username: string | null
    correo: string | null
    password: string | null
    nombreCompleto: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfil: string | null
    nombreEmpresa: string | null
    nit: string | null
    estado: string | null
    rol: string | null
    tipoUsuario: $Enums.TipoUsuario | null
    rolEquipo: $Enums.rolEquipo | null
    perfilCompleto: boolean | null
    empresaId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    idUsuario: number
    username: number
    correo: number
    password: number
    nombreCompleto: number
    telefono: number
    direccion: number
    fotoPerfil: number
    nombreEmpresa: number
    nit: number
    estado: number
    rol: number
    tipoUsuario: number
    rolEquipo: number
    perfilCompleto: number
    empresaId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    idUsuario?: true
    empresaId?: true
  }

  export type UsersSumAggregateInputType = {
    idUsuario?: true
    empresaId?: true
  }

  export type UsersMinAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    tipoUsuario?: true
    rolEquipo?: true
    perfilCompleto?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    tipoUsuario?: true
    rolEquipo?: true
    perfilCompleto?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersCountAggregateInputType = {
    idUsuario?: true
    username?: true
    correo?: true
    password?: true
    nombreCompleto?: true
    telefono?: true
    direccion?: true
    fotoPerfil?: true
    nombreEmpresa?: true
    nit?: true
    estado?: true
    rol?: true
    tipoUsuario?: true
    rolEquipo?: true
    perfilCompleto?: true
    empresaId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    idUsuario: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil: string | null
    nombreEmpresa: string | null
    nit: string | null
    estado: string
    rol: string
    tipoUsuario: $Enums.TipoUsuario | null
    rolEquipo: $Enums.rolEquipo | null
    perfilCompleto: boolean
    empresaId: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    tipoUsuario?: boolean
    rolEquipo?: boolean
    perfilCompleto?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    jefe?: boolean | users$jefeArgs<ExtArgs>
    miembros?: boolean | users$miembrosArgs<ExtArgs>
    passwordResets?: boolean | users$passwordResetsArgs<ExtArgs>
    notificaciones?: boolean | users$notificacionesArgs<ExtArgs>
    productos?: boolean | users$productosArgs<ExtArgs>
    comentarios?: boolean | users$comentariosArgs<ExtArgs>
    nutriScans?: boolean | users$nutriScansArgs<ExtArgs>
    histInv?: boolean | users$histInvArgs<ExtArgs>
    preferencias?: boolean | users$preferenciasArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    tipoUsuario?: boolean
    rolEquipo?: boolean
    perfilCompleto?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    jefe?: boolean | users$jefeArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    tipoUsuario?: boolean
    rolEquipo?: boolean
    perfilCompleto?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    jefe?: boolean | users$jefeArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    idUsuario?: boolean
    username?: boolean
    correo?: boolean
    password?: boolean
    nombreCompleto?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfil?: boolean
    nombreEmpresa?: boolean
    nit?: boolean
    estado?: boolean
    rol?: boolean
    tipoUsuario?: boolean
    rolEquipo?: boolean
    perfilCompleto?: boolean
    empresaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idUsuario" | "username" | "correo" | "password" | "nombreCompleto" | "telefono" | "direccion" | "fotoPerfil" | "nombreEmpresa" | "nit" | "estado" | "rol" | "tipoUsuario" | "rolEquipo" | "perfilCompleto" | "empresaId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jefe?: boolean | users$jefeArgs<ExtArgs>
    miembros?: boolean | users$miembrosArgs<ExtArgs>
    passwordResets?: boolean | users$passwordResetsArgs<ExtArgs>
    notificaciones?: boolean | users$notificacionesArgs<ExtArgs>
    productos?: boolean | users$productosArgs<ExtArgs>
    comentarios?: boolean | users$comentariosArgs<ExtArgs>
    nutriScans?: boolean | users$nutriScansArgs<ExtArgs>
    histInv?: boolean | users$histInvArgs<ExtArgs>
    preferencias?: boolean | users$preferenciasArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jefe?: boolean | users$jefeArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jefe?: boolean | users$jefeArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      jefe: Prisma.$usersPayload<ExtArgs> | null
      miembros: Prisma.$usersPayload<ExtArgs>[]
      passwordResets: Prisma.$passwordResetPayload<ExtArgs>[]
      notificaciones: Prisma.$notificacionesPayload<ExtArgs>[]
      productos: Prisma.$productosPayload<ExtArgs>[]
      comentarios: Prisma.$comentariosPayload<ExtArgs>[]
      nutriScans: Prisma.$NutriScanPayload<ExtArgs>[]
      histInv: Prisma.$histInvPayload<ExtArgs>[]
      preferencias: Prisma.$preferenciasNotificacionesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idUsuario: number
      username: string
      correo: string
      password: string
      nombreCompleto: string
      telefono: string
      direccion: string
      fotoPerfil: string | null
      nombreEmpresa: string | null
      nit: string | null
      estado: string
      rol: string
      tipoUsuario: $Enums.TipoUsuario | null
      rolEquipo: $Enums.rolEquipo | null
      perfilCompleto: boolean
      empresaId: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.findMany({ select: { idUsuario: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.createManyAndReturn({
     *   select: { idUsuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `idUsuario`
     * const usersWithIdUsuarioOnly = await prisma.users.updateManyAndReturn({
     *   select: { idUsuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jefe<T extends users$jefeArgs<ExtArgs> = {}>(args?: Subset<T, users$jefeArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    miembros<T extends users$miembrosArgs<ExtArgs> = {}>(args?: Subset<T, users$miembrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResets<T extends users$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, users$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificaciones<T extends users$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, users$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productos<T extends users$productosArgs<ExtArgs> = {}>(args?: Subset<T, users$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comentarios<T extends users$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, users$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nutriScans<T extends users$nutriScansArgs<ExtArgs> = {}>(args?: Subset<T, users$nutriScansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    histInv<T extends users$histInvArgs<ExtArgs> = {}>(args?: Subset<T, users$histInvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferencias<T extends users$preferenciasArgs<ExtArgs> = {}>(args?: Subset<T, users$preferenciasArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly idUsuario: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly correo: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly nombreCompleto: FieldRef<"users", 'String'>
    readonly telefono: FieldRef<"users", 'String'>
    readonly direccion: FieldRef<"users", 'String'>
    readonly fotoPerfil: FieldRef<"users", 'String'>
    readonly nombreEmpresa: FieldRef<"users", 'String'>
    readonly nit: FieldRef<"users", 'String'>
    readonly estado: FieldRef<"users", 'String'>
    readonly rol: FieldRef<"users", 'String'>
    readonly tipoUsuario: FieldRef<"users", 'TipoUsuario'>
    readonly rolEquipo: FieldRef<"users", 'rolEquipo'>
    readonly perfilCompleto: FieldRef<"users", 'Boolean'>
    readonly empresaId: FieldRef<"users", 'Int'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly deletedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.jefe
   */
  export type users$jefeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * users.miembros
   */
  export type users$miembrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users.passwordResets
   */
  export type users$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    where?: passwordResetWhereInput
    orderBy?: passwordResetOrderByWithRelationInput | passwordResetOrderByWithRelationInput[]
    cursor?: passwordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * users.notificaciones
   */
  export type users$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    where?: notificacionesWhereInput
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    cursor?: notificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * users.productos
   */
  export type users$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    where?: productosWhereInput
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    cursor?: productosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * users.comentarios
   */
  export type users$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    where?: comentariosWhereInput
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    cursor?: comentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * users.nutriScans
   */
  export type users$nutriScansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    where?: NutriScanWhereInput
    orderBy?: NutriScanOrderByWithRelationInput | NutriScanOrderByWithRelationInput[]
    cursor?: NutriScanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutriScanScalarFieldEnum | NutriScanScalarFieldEnum[]
  }

  /**
   * users.histInv
   */
  export type users$histInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    cursor?: histInvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * users.preferencias
   */
  export type users$preferenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    where?: preferenciasNotificacionesWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model passwordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetAvgAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
  }

  export type PasswordResetSumAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
  }

  export type PasswordResetMinAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
    token: string | null
    fechaSolicitud: Date | null
    fechaExpiracion: Date | null
    usado: boolean | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    idSeguridad: number | null
    idUsuario: number | null
    token: string | null
    fechaSolicitud: Date | null
    fechaExpiracion: Date | null
    usado: boolean | null
  }

  export type PasswordResetCountAggregateOutputType = {
    idSeguridad: number
    idUsuario: number
    token: number
    fechaSolicitud: number
    fechaExpiracion: number
    usado: number
    _all: number
  }


  export type PasswordResetAvgAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
  }

  export type PasswordResetSumAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
  }

  export type PasswordResetMinAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
  }

  export type PasswordResetCountAggregateInputType = {
    idSeguridad?: true
    idUsuario?: true
    token?: true
    fechaSolicitud?: true
    fechaExpiracion?: true
    usado?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passwordReset to aggregate.
     */
    where?: passwordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordResets to fetch.
     */
    orderBy?: passwordResetOrderByWithRelationInput | passwordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: passwordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned passwordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type passwordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passwordResetWhereInput
    orderBy?: passwordResetOrderByWithAggregationInput | passwordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: passwordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _avg?: PasswordResetAvgAggregateInputType
    _sum?: PasswordResetSumAggregateInputType
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    idSeguridad: number
    idUsuario: number
    token: string
    fechaSolicitud: Date
    fechaExpiracion: Date
    usado: boolean
    _count: PasswordResetCountAggregateOutputType | null
    _avg: PasswordResetAvgAggregateOutputType | null
    _sum: PasswordResetSumAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends passwordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type passwordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type passwordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type passwordResetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSeguridad?: boolean
    idUsuario?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type passwordResetSelectScalar = {
    idSeguridad?: boolean
    idUsuario?: boolean
    token?: boolean
    fechaSolicitud?: boolean
    fechaExpiracion?: boolean
    usado?: boolean
  }

  export type passwordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSeguridad" | "idUsuario" | "token" | "fechaSolicitud" | "fechaExpiracion" | "usado", ExtArgs["result"]["passwordReset"]>
  export type passwordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type passwordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type passwordResetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $passwordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "passwordReset"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idSeguridad: number
      idUsuario: number
      token: string
      fechaSolicitud: Date
      fechaExpiracion: Date
      usado: boolean
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type passwordResetGetPayload<S extends boolean | null | undefined | passwordResetDefaultArgs> = $Result.GetResult<Prisma.$passwordResetPayload, S>

  type passwordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<passwordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface passwordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['passwordReset'], meta: { name: 'passwordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {passwordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends passwordResetFindUniqueArgs>(args: SelectSubset<T, passwordResetFindUniqueArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {passwordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends passwordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, passwordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends passwordResetFindFirstArgs>(args?: SelectSubset<T, passwordResetFindFirstArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends passwordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, passwordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `idSeguridad`
     * const passwordResetWithIdSeguridadOnly = await prisma.passwordReset.findMany({ select: { idSeguridad: true } })
     * 
     */
    findMany<T extends passwordResetFindManyArgs>(args?: SelectSubset<T, passwordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {passwordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends passwordResetCreateArgs>(args: SelectSubset<T, passwordResetCreateArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {passwordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends passwordResetCreateManyArgs>(args?: SelectSubset<T, passwordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {passwordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `idSeguridad`
     * const passwordResetWithIdSeguridadOnly = await prisma.passwordReset.createManyAndReturn({
     *   select: { idSeguridad: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends passwordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, passwordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordReset.
     * @param {passwordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends passwordResetDeleteArgs>(args: SelectSubset<T, passwordResetDeleteArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {passwordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends passwordResetUpdateArgs>(args: SelectSubset<T, passwordResetUpdateArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {passwordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends passwordResetDeleteManyArgs>(args?: SelectSubset<T, passwordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends passwordResetUpdateManyArgs>(args: SelectSubset<T, passwordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets and returns the data updated in the database.
     * @param {passwordResetUpdateManyAndReturnArgs} args - Arguments to update many PasswordResets.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResets and only return the `idSeguridad`
     * const passwordResetWithIdSeguridadOnly = await prisma.passwordReset.updateManyAndReturn({
     *   select: { idSeguridad: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends passwordResetUpdateManyAndReturnArgs>(args: SelectSubset<T, passwordResetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordReset.
     * @param {passwordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends passwordResetUpsertArgs>(args: SelectSubset<T, passwordResetUpsertArgs<ExtArgs>>): Prisma__passwordResetClient<$Result.GetResult<Prisma.$passwordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends passwordResetCountArgs>(
      args?: Subset<T, passwordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passwordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends passwordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: passwordResetGroupByArgs['orderBy'] }
        : { orderBy?: passwordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, passwordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the passwordReset model
   */
  readonly fields: passwordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for passwordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__passwordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the passwordReset model
   */
  interface passwordResetFieldRefs {
    readonly idSeguridad: FieldRef<"passwordReset", 'Int'>
    readonly idUsuario: FieldRef<"passwordReset", 'Int'>
    readonly token: FieldRef<"passwordReset", 'String'>
    readonly fechaSolicitud: FieldRef<"passwordReset", 'DateTime'>
    readonly fechaExpiracion: FieldRef<"passwordReset", 'DateTime'>
    readonly usado: FieldRef<"passwordReset", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * passwordReset findUnique
   */
  export type passwordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter, which passwordReset to fetch.
     */
    where: passwordResetWhereUniqueInput
  }

  /**
   * passwordReset findUniqueOrThrow
   */
  export type passwordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter, which passwordReset to fetch.
     */
    where: passwordResetWhereUniqueInput
  }

  /**
   * passwordReset findFirst
   */
  export type passwordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter, which passwordReset to fetch.
     */
    where?: passwordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordResets to fetch.
     */
    orderBy?: passwordResetOrderByWithRelationInput | passwordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passwordResets.
     */
    cursor?: passwordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passwordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * passwordReset findFirstOrThrow
   */
  export type passwordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter, which passwordReset to fetch.
     */
    where?: passwordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordResets to fetch.
     */
    orderBy?: passwordResetOrderByWithRelationInput | passwordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passwordResets.
     */
    cursor?: passwordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passwordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * passwordReset findMany
   */
  export type passwordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter, which passwordResets to fetch.
     */
    where?: passwordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passwordResets to fetch.
     */
    orderBy?: passwordResetOrderByWithRelationInput | passwordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing passwordResets.
     */
    cursor?: passwordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passwordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passwordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * passwordReset create
   */
  export type passwordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a passwordReset.
     */
    data: XOR<passwordResetCreateInput, passwordResetUncheckedCreateInput>
  }

  /**
   * passwordReset createMany
   */
  export type passwordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many passwordResets.
     */
    data: passwordResetCreateManyInput | passwordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * passwordReset createManyAndReturn
   */
  export type passwordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * The data used to create many passwordResets.
     */
    data: passwordResetCreateManyInput | passwordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * passwordReset update
   */
  export type passwordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a passwordReset.
     */
    data: XOR<passwordResetUpdateInput, passwordResetUncheckedUpdateInput>
    /**
     * Choose, which passwordReset to update.
     */
    where: passwordResetWhereUniqueInput
  }

  /**
   * passwordReset updateMany
   */
  export type passwordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update passwordResets.
     */
    data: XOR<passwordResetUpdateManyMutationInput, passwordResetUncheckedUpdateManyInput>
    /**
     * Filter which passwordResets to update
     */
    where?: passwordResetWhereInput
    /**
     * Limit how many passwordResets to update.
     */
    limit?: number
  }

  /**
   * passwordReset updateManyAndReturn
   */
  export type passwordResetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * The data used to update passwordResets.
     */
    data: XOR<passwordResetUpdateManyMutationInput, passwordResetUncheckedUpdateManyInput>
    /**
     * Filter which passwordResets to update
     */
    where?: passwordResetWhereInput
    /**
     * Limit how many passwordResets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * passwordReset upsert
   */
  export type passwordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the passwordReset to update in case it exists.
     */
    where: passwordResetWhereUniqueInput
    /**
     * In case the passwordReset found by the `where` argument doesn't exist, create a new passwordReset with this data.
     */
    create: XOR<passwordResetCreateInput, passwordResetUncheckedCreateInput>
    /**
     * In case the passwordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<passwordResetUpdateInput, passwordResetUncheckedUpdateInput>
  }

  /**
   * passwordReset delete
   */
  export type passwordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
    /**
     * Filter which passwordReset to delete.
     */
    where: passwordResetWhereUniqueInput
  }

  /**
   * passwordReset deleteMany
   */
  export type passwordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passwordResets to delete
     */
    where?: passwordResetWhereInput
    /**
     * Limit how many passwordResets to delete.
     */
    limit?: number
  }

  /**
   * passwordReset without action
   */
  export type passwordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passwordReset
     */
    select?: passwordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passwordReset
     */
    omit?: passwordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passwordResetInclude<ExtArgs> | null
  }


  /**
   * Model notificaciones
   */

  export type AggregateNotificaciones = {
    _count: NotificacionesCountAggregateOutputType | null
    _avg: NotificacionesAvgAggregateOutputType | null
    _sum: NotificacionesSumAggregateOutputType | null
    _min: NotificacionesMinAggregateOutputType | null
    _max: NotificacionesMaxAggregateOutputType | null
  }

  export type NotificacionesAvgAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
  }

  export type NotificacionesSumAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
  }

  export type NotificacionesMinAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    fechaEnvio: Date | null
    leida: boolean | null
  }

  export type NotificacionesMaxAggregateOutputType = {
    idNotificacion: number | null
    idUsuario: number | null
    tipo: $Enums.TipoNotificacion | null
    titulo: string | null
    mensaje: string | null
    fechaEnvio: Date | null
    leida: boolean | null
  }

  export type NotificacionesCountAggregateOutputType = {
    idNotificacion: number
    idUsuario: number
    tipo: number
    titulo: number
    mensaje: number
    fechaEnvio: number
    leida: number
    _all: number
  }


  export type NotificacionesAvgAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
  }

  export type NotificacionesSumAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
  }

  export type NotificacionesMinAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
  }

  export type NotificacionesMaxAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
  }

  export type NotificacionesCountAggregateInputType = {
    idNotificacion?: true
    idUsuario?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    fechaEnvio?: true
    leida?: true
    _all?: true
  }

  export type NotificacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificaciones to aggregate.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notificaciones
    **/
    _count?: true | NotificacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionesMaxAggregateInputType
  }

  export type GetNotificacionesAggregateType<T extends NotificacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificaciones[P]>
      : GetScalarType<T[P], AggregateNotificaciones[P]>
  }




  export type notificacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificacionesWhereInput
    orderBy?: notificacionesOrderByWithAggregationInput | notificacionesOrderByWithAggregationInput[]
    by: NotificacionesScalarFieldEnum[] | NotificacionesScalarFieldEnum
    having?: notificacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionesCountAggregateInputType | true
    _avg?: NotificacionesAvgAggregateInputType
    _sum?: NotificacionesSumAggregateInputType
    _min?: NotificacionesMinAggregateInputType
    _max?: NotificacionesMaxAggregateInputType
  }

  export type NotificacionesGroupByOutputType = {
    idNotificacion: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio: Date
    leida: boolean
    _count: NotificacionesCountAggregateOutputType | null
    _avg: NotificacionesAvgAggregateOutputType | null
    _sum: NotificacionesSumAggregateOutputType | null
    _min: NotificacionesMinAggregateOutputType | null
    _max: NotificacionesMaxAggregateOutputType | null
  }

  type GetNotificacionesGroupByPayload<T extends notificacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionesGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionesGroupByOutputType[P]>
        }
      >
    >


  export type notificacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificaciones"]>

  export type notificacionesSelectScalar = {
    idNotificacion?: boolean
    idUsuario?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    fechaEnvio?: boolean
    leida?: boolean
  }

  export type notificacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idNotificacion" | "idUsuario" | "tipo" | "titulo" | "mensaje" | "fechaEnvio" | "leida", ExtArgs["result"]["notificaciones"]>
  export type notificacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notificaciones"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idNotificacion: number
      idUsuario: number
      tipo: $Enums.TipoNotificacion
      titulo: string
      mensaje: string
      fechaEnvio: Date
      leida: boolean
    }, ExtArgs["result"]["notificaciones"]>
    composites: {}
  }

  type notificacionesGetPayload<S extends boolean | null | undefined | notificacionesDefaultArgs> = $Result.GetResult<Prisma.$notificacionesPayload, S>

  type notificacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionesCountAggregateInputType | true
    }

  export interface notificacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notificaciones'], meta: { name: 'notificaciones' } }
    /**
     * Find zero or one Notificaciones that matches the filter.
     * @param {notificacionesFindUniqueArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificacionesFindUniqueArgs>(args: SelectSubset<T, notificacionesFindUniqueArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificacionesFindUniqueOrThrowArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, notificacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindFirstArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificacionesFindFirstArgs>(args?: SelectSubset<T, notificacionesFindFirstArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindFirstOrThrowArgs} args - Arguments to find a Notificaciones
     * @example
     * // Get one Notificaciones
     * const notificaciones = await prisma.notificaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, notificacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificaciones
     * const notificaciones = await prisma.notificaciones.findMany()
     * 
     * // Get first 10 Notificaciones
     * const notificaciones = await prisma.notificaciones.findMany({ take: 10 })
     * 
     * // Only select the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.findMany({ select: { idNotificacion: true } })
     * 
     */
    findMany<T extends notificacionesFindManyArgs>(args?: SelectSubset<T, notificacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificaciones.
     * @param {notificacionesCreateArgs} args - Arguments to create a Notificaciones.
     * @example
     * // Create one Notificaciones
     * const Notificaciones = await prisma.notificaciones.create({
     *   data: {
     *     // ... data to create a Notificaciones
     *   }
     * })
     * 
     */
    create<T extends notificacionesCreateArgs>(args: SelectSubset<T, notificacionesCreateArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificaciones.
     * @param {notificacionesCreateManyArgs} args - Arguments to create many Notificaciones.
     * @example
     * // Create many Notificaciones
     * const notificaciones = await prisma.notificaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificacionesCreateManyArgs>(args?: SelectSubset<T, notificacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificaciones and returns the data saved in the database.
     * @param {notificacionesCreateManyAndReturnArgs} args - Arguments to create many Notificaciones.
     * @example
     * // Create many Notificaciones
     * const notificaciones = await prisma.notificaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificaciones and only return the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.createManyAndReturn({
     *   select: { idNotificacion: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, notificacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificaciones.
     * @param {notificacionesDeleteArgs} args - Arguments to delete one Notificaciones.
     * @example
     * // Delete one Notificaciones
     * const Notificaciones = await prisma.notificaciones.delete({
     *   where: {
     *     // ... filter to delete one Notificaciones
     *   }
     * })
     * 
     */
    delete<T extends notificacionesDeleteArgs>(args: SelectSubset<T, notificacionesDeleteArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificaciones.
     * @param {notificacionesUpdateArgs} args - Arguments to update one Notificaciones.
     * @example
     * // Update one Notificaciones
     * const notificaciones = await prisma.notificaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificacionesUpdateArgs>(args: SelectSubset<T, notificacionesUpdateArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificaciones.
     * @param {notificacionesDeleteManyArgs} args - Arguments to filter Notificaciones to delete.
     * @example
     * // Delete a few Notificaciones
     * const { count } = await prisma.notificaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificacionesDeleteManyArgs>(args?: SelectSubset<T, notificacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificaciones
     * const notificaciones = await prisma.notificaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificacionesUpdateManyArgs>(args: SelectSubset<T, notificacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificaciones and returns the data updated in the database.
     * @param {notificacionesUpdateManyAndReturnArgs} args - Arguments to update many Notificaciones.
     * @example
     * // Update many Notificaciones
     * const notificaciones = await prisma.notificaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificaciones and only return the `idNotificacion`
     * const notificacionesWithIdNotificacionOnly = await prisma.notificaciones.updateManyAndReturn({
     *   select: { idNotificacion: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, notificacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificaciones.
     * @param {notificacionesUpsertArgs} args - Arguments to update or create a Notificaciones.
     * @example
     * // Update or create a Notificaciones
     * const notificaciones = await prisma.notificaciones.upsert({
     *   create: {
     *     // ... data to create a Notificaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificaciones we want to update
     *   }
     * })
     */
    upsert<T extends notificacionesUpsertArgs>(args: SelectSubset<T, notificacionesUpsertArgs<ExtArgs>>): Prisma__notificacionesClient<$Result.GetResult<Prisma.$notificacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesCountArgs} args - Arguments to filter Notificaciones to count.
     * @example
     * // Count the number of Notificaciones
     * const count = await prisma.notificaciones.count({
     *   where: {
     *     // ... the filter for the Notificaciones we want to count
     *   }
     * })
    **/
    count<T extends notificacionesCountArgs>(
      args?: Subset<T, notificacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionesAggregateArgs>(args: Subset<T, NotificacionesAggregateArgs>): Prisma.PrismaPromise<GetNotificacionesAggregateType<T>>

    /**
     * Group by Notificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificacionesGroupByArgs['orderBy'] }
        : { orderBy?: notificacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notificaciones model
   */
  readonly fields: notificacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notificaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notificaciones model
   */
  interface notificacionesFieldRefs {
    readonly idNotificacion: FieldRef<"notificaciones", 'Int'>
    readonly idUsuario: FieldRef<"notificaciones", 'Int'>
    readonly tipo: FieldRef<"notificaciones", 'TipoNotificacion'>
    readonly titulo: FieldRef<"notificaciones", 'String'>
    readonly mensaje: FieldRef<"notificaciones", 'String'>
    readonly fechaEnvio: FieldRef<"notificaciones", 'DateTime'>
    readonly leida: FieldRef<"notificaciones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notificaciones findUnique
   */
  export type notificacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones findUniqueOrThrow
   */
  export type notificacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones findFirst
   */
  export type notificacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificaciones.
     */
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones findFirstOrThrow
   */
  export type notificacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notificaciones.
     */
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones findMany
   */
  export type notificacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter, which notificaciones to fetch.
     */
    where?: notificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notificaciones to fetch.
     */
    orderBy?: notificacionesOrderByWithRelationInput | notificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notificaciones.
     */
    cursor?: notificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notificaciones.
     */
    skip?: number
    distinct?: NotificacionesScalarFieldEnum | NotificacionesScalarFieldEnum[]
  }

  /**
   * notificaciones create
   */
  export type notificacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a notificaciones.
     */
    data: XOR<notificacionesCreateInput, notificacionesUncheckedCreateInput>
  }

  /**
   * notificaciones createMany
   */
  export type notificacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notificaciones.
     */
    data: notificacionesCreateManyInput | notificacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notificaciones createManyAndReturn
   */
  export type notificacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * The data used to create many notificaciones.
     */
    data: notificacionesCreateManyInput | notificacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificaciones update
   */
  export type notificacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a notificaciones.
     */
    data: XOR<notificacionesUpdateInput, notificacionesUncheckedUpdateInput>
    /**
     * Choose, which notificaciones to update.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones updateMany
   */
  export type notificacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notificaciones.
     */
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyInput>
    /**
     * Filter which notificaciones to update
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to update.
     */
    limit?: number
  }

  /**
   * notificaciones updateManyAndReturn
   */
  export type notificacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * The data used to update notificaciones.
     */
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyInput>
    /**
     * Filter which notificaciones to update
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notificaciones upsert
   */
  export type notificacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the notificaciones to update in case it exists.
     */
    where: notificacionesWhereUniqueInput
    /**
     * In case the notificaciones found by the `where` argument doesn't exist, create a new notificaciones with this data.
     */
    create: XOR<notificacionesCreateInput, notificacionesUncheckedCreateInput>
    /**
     * In case the notificaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificacionesUpdateInput, notificacionesUncheckedUpdateInput>
  }

  /**
   * notificaciones delete
   */
  export type notificacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
    /**
     * Filter which notificaciones to delete.
     */
    where: notificacionesWhereUniqueInput
  }

  /**
   * notificaciones deleteMany
   */
  export type notificacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notificaciones to delete
     */
    where?: notificacionesWhereInput
    /**
     * Limit how many notificaciones to delete.
     */
    limit?: number
  }

  /**
   * notificaciones without action
   */
  export type notificacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notificaciones
     */
    select?: notificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notificaciones
     */
    omit?: notificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificacionesInclude<ExtArgs> | null
  }


  /**
   * Model preferenciasNotificaciones
   */

  export type AggregatePreferenciasNotificaciones = {
    _count: PreferenciasNotificacionesCountAggregateOutputType | null
    _avg: PreferenciasNotificacionesAvgAggregateOutputType | null
    _sum: PreferenciasNotificacionesSumAggregateOutputType | null
    _min: PreferenciasNotificacionesMinAggregateOutputType | null
    _max: PreferenciasNotificacionesMaxAggregateOutputType | null
  }

  export type PreferenciasNotificacionesAvgAggregateOutputType = {
    id: number | null
    idUsuario: number | null
  }

  export type PreferenciasNotificacionesSumAggregateOutputType = {
    id: number | null
    idUsuario: number | null
  }

  export type PreferenciasNotificacionesMinAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    stockBajo: boolean | null
    productoVencido: boolean | null
    comentarios: boolean | null
    reposicion: boolean | null
    actualizacion: boolean | null
  }

  export type PreferenciasNotificacionesMaxAggregateOutputType = {
    id: number | null
    idUsuario: number | null
    stockBajo: boolean | null
    productoVencido: boolean | null
    comentarios: boolean | null
    reposicion: boolean | null
    actualizacion: boolean | null
  }

  export type PreferenciasNotificacionesCountAggregateOutputType = {
    id: number
    idUsuario: number
    stockBajo: number
    productoVencido: number
    comentarios: number
    reposicion: number
    actualizacion: number
    _all: number
  }


  export type PreferenciasNotificacionesAvgAggregateInputType = {
    id?: true
    idUsuario?: true
  }

  export type PreferenciasNotificacionesSumAggregateInputType = {
    id?: true
    idUsuario?: true
  }

  export type PreferenciasNotificacionesMinAggregateInputType = {
    id?: true
    idUsuario?: true
    stockBajo?: true
    productoVencido?: true
    comentarios?: true
    reposicion?: true
    actualizacion?: true
  }

  export type PreferenciasNotificacionesMaxAggregateInputType = {
    id?: true
    idUsuario?: true
    stockBajo?: true
    productoVencido?: true
    comentarios?: true
    reposicion?: true
    actualizacion?: true
  }

  export type PreferenciasNotificacionesCountAggregateInputType = {
    id?: true
    idUsuario?: true
    stockBajo?: true
    productoVencido?: true
    comentarios?: true
    reposicion?: true
    actualizacion?: true
    _all?: true
  }

  export type PreferenciasNotificacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preferenciasNotificaciones to aggregate.
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferenciasNotificaciones to fetch.
     */
    orderBy?: preferenciasNotificacionesOrderByWithRelationInput | preferenciasNotificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preferenciasNotificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferenciasNotificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferenciasNotificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preferenciasNotificaciones
    **/
    _count?: true | PreferenciasNotificacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferenciasNotificacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferenciasNotificacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferenciasNotificacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferenciasNotificacionesMaxAggregateInputType
  }

  export type GetPreferenciasNotificacionesAggregateType<T extends PreferenciasNotificacionesAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferenciasNotificaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferenciasNotificaciones[P]>
      : GetScalarType<T[P], AggregatePreferenciasNotificaciones[P]>
  }




  export type preferenciasNotificacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preferenciasNotificacionesWhereInput
    orderBy?: preferenciasNotificacionesOrderByWithAggregationInput | preferenciasNotificacionesOrderByWithAggregationInput[]
    by: PreferenciasNotificacionesScalarFieldEnum[] | PreferenciasNotificacionesScalarFieldEnum
    having?: preferenciasNotificacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferenciasNotificacionesCountAggregateInputType | true
    _avg?: PreferenciasNotificacionesAvgAggregateInputType
    _sum?: PreferenciasNotificacionesSumAggregateInputType
    _min?: PreferenciasNotificacionesMinAggregateInputType
    _max?: PreferenciasNotificacionesMaxAggregateInputType
  }

  export type PreferenciasNotificacionesGroupByOutputType = {
    id: number
    idUsuario: number
    stockBajo: boolean
    productoVencido: boolean
    comentarios: boolean
    reposicion: boolean
    actualizacion: boolean
    _count: PreferenciasNotificacionesCountAggregateOutputType | null
    _avg: PreferenciasNotificacionesAvgAggregateOutputType | null
    _sum: PreferenciasNotificacionesSumAggregateOutputType | null
    _min: PreferenciasNotificacionesMinAggregateOutputType | null
    _max: PreferenciasNotificacionesMaxAggregateOutputType | null
  }

  type GetPreferenciasNotificacionesGroupByPayload<T extends preferenciasNotificacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferenciasNotificacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferenciasNotificacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferenciasNotificacionesGroupByOutputType[P]>
            : GetScalarType<T[P], PreferenciasNotificacionesGroupByOutputType[P]>
        }
      >
    >


  export type preferenciasNotificacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idUsuario?: boolean
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciasNotificaciones"]>

  export type preferenciasNotificacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idUsuario?: boolean
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciasNotificaciones"]>

  export type preferenciasNotificacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idUsuario?: boolean
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciasNotificaciones"]>

  export type preferenciasNotificacionesSelectScalar = {
    id?: boolean
    idUsuario?: boolean
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
  }

  export type preferenciasNotificacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idUsuario" | "stockBajo" | "productoVencido" | "comentarios" | "reposicion" | "actualizacion", ExtArgs["result"]["preferenciasNotificaciones"]>
  export type preferenciasNotificacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type preferenciasNotificacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type preferenciasNotificacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $preferenciasNotificacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preferenciasNotificaciones"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idUsuario: number
      stockBajo: boolean
      productoVencido: boolean
      comentarios: boolean
      reposicion: boolean
      actualizacion: boolean
    }, ExtArgs["result"]["preferenciasNotificaciones"]>
    composites: {}
  }

  type preferenciasNotificacionesGetPayload<S extends boolean | null | undefined | preferenciasNotificacionesDefaultArgs> = $Result.GetResult<Prisma.$preferenciasNotificacionesPayload, S>

  type preferenciasNotificacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<preferenciasNotificacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreferenciasNotificacionesCountAggregateInputType | true
    }

  export interface preferenciasNotificacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preferenciasNotificaciones'], meta: { name: 'preferenciasNotificaciones' } }
    /**
     * Find zero or one PreferenciasNotificaciones that matches the filter.
     * @param {preferenciasNotificacionesFindUniqueArgs} args - Arguments to find a PreferenciasNotificaciones
     * @example
     * // Get one PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preferenciasNotificacionesFindUniqueArgs>(args: SelectSubset<T, preferenciasNotificacionesFindUniqueArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreferenciasNotificaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {preferenciasNotificacionesFindUniqueOrThrowArgs} args - Arguments to find a PreferenciasNotificaciones
     * @example
     * // Get one PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preferenciasNotificacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, preferenciasNotificacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenciasNotificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesFindFirstArgs} args - Arguments to find a PreferenciasNotificaciones
     * @example
     * // Get one PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preferenciasNotificacionesFindFirstArgs>(args?: SelectSubset<T, preferenciasNotificacionesFindFirstArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenciasNotificaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesFindFirstOrThrowArgs} args - Arguments to find a PreferenciasNotificaciones
     * @example
     * // Get one PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preferenciasNotificacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, preferenciasNotificacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreferenciasNotificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findMany()
     * 
     * // Get first 10 PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preferenciasNotificacionesWithIdOnly = await prisma.preferenciasNotificaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends preferenciasNotificacionesFindManyArgs>(args?: SelectSubset<T, preferenciasNotificacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesCreateArgs} args - Arguments to create a PreferenciasNotificaciones.
     * @example
     * // Create one PreferenciasNotificaciones
     * const PreferenciasNotificaciones = await prisma.preferenciasNotificaciones.create({
     *   data: {
     *     // ... data to create a PreferenciasNotificaciones
     *   }
     * })
     * 
     */
    create<T extends preferenciasNotificacionesCreateArgs>(args: SelectSubset<T, preferenciasNotificacionesCreateArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesCreateManyArgs} args - Arguments to create many PreferenciasNotificaciones.
     * @example
     * // Create many PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preferenciasNotificacionesCreateManyArgs>(args?: SelectSubset<T, preferenciasNotificacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreferenciasNotificaciones and returns the data saved in the database.
     * @param {preferenciasNotificacionesCreateManyAndReturnArgs} args - Arguments to create many PreferenciasNotificaciones.
     * @example
     * // Create many PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreferenciasNotificaciones and only return the `id`
     * const preferenciasNotificacionesWithIdOnly = await prisma.preferenciasNotificaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends preferenciasNotificacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, preferenciasNotificacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesDeleteArgs} args - Arguments to delete one PreferenciasNotificaciones.
     * @example
     * // Delete one PreferenciasNotificaciones
     * const PreferenciasNotificaciones = await prisma.preferenciasNotificaciones.delete({
     *   where: {
     *     // ... filter to delete one PreferenciasNotificaciones
     *   }
     * })
     * 
     */
    delete<T extends preferenciasNotificacionesDeleteArgs>(args: SelectSubset<T, preferenciasNotificacionesDeleteArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesUpdateArgs} args - Arguments to update one PreferenciasNotificaciones.
     * @example
     * // Update one PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preferenciasNotificacionesUpdateArgs>(args: SelectSubset<T, preferenciasNotificacionesUpdateArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesDeleteManyArgs} args - Arguments to filter PreferenciasNotificaciones to delete.
     * @example
     * // Delete a few PreferenciasNotificaciones
     * const { count } = await prisma.preferenciasNotificaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preferenciasNotificacionesDeleteManyArgs>(args?: SelectSubset<T, preferenciasNotificacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenciasNotificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preferenciasNotificacionesUpdateManyArgs>(args: SelectSubset<T, preferenciasNotificacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenciasNotificaciones and returns the data updated in the database.
     * @param {preferenciasNotificacionesUpdateManyAndReturnArgs} args - Arguments to update many PreferenciasNotificaciones.
     * @example
     * // Update many PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreferenciasNotificaciones and only return the `id`
     * const preferenciasNotificacionesWithIdOnly = await prisma.preferenciasNotificaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends preferenciasNotificacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, preferenciasNotificacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreferenciasNotificaciones.
     * @param {preferenciasNotificacionesUpsertArgs} args - Arguments to update or create a PreferenciasNotificaciones.
     * @example
     * // Update or create a PreferenciasNotificaciones
     * const preferenciasNotificaciones = await prisma.preferenciasNotificaciones.upsert({
     *   create: {
     *     // ... data to create a PreferenciasNotificaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreferenciasNotificaciones we want to update
     *   }
     * })
     */
    upsert<T extends preferenciasNotificacionesUpsertArgs>(args: SelectSubset<T, preferenciasNotificacionesUpsertArgs<ExtArgs>>): Prisma__preferenciasNotificacionesClient<$Result.GetResult<Prisma.$preferenciasNotificacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreferenciasNotificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesCountArgs} args - Arguments to filter PreferenciasNotificaciones to count.
     * @example
     * // Count the number of PreferenciasNotificaciones
     * const count = await prisma.preferenciasNotificaciones.count({
     *   where: {
     *     // ... the filter for the PreferenciasNotificaciones we want to count
     *   }
     * })
    **/
    count<T extends preferenciasNotificacionesCountArgs>(
      args?: Subset<T, preferenciasNotificacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferenciasNotificacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreferenciasNotificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciasNotificacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferenciasNotificacionesAggregateArgs>(args: Subset<T, PreferenciasNotificacionesAggregateArgs>): Prisma.PrismaPromise<GetPreferenciasNotificacionesAggregateType<T>>

    /**
     * Group by PreferenciasNotificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preferenciasNotificacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preferenciasNotificacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preferenciasNotificacionesGroupByArgs['orderBy'] }
        : { orderBy?: preferenciasNotificacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preferenciasNotificacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferenciasNotificacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preferenciasNotificaciones model
   */
  readonly fields: preferenciasNotificacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preferenciasNotificaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preferenciasNotificacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preferenciasNotificaciones model
   */
  interface preferenciasNotificacionesFieldRefs {
    readonly id: FieldRef<"preferenciasNotificaciones", 'Int'>
    readonly idUsuario: FieldRef<"preferenciasNotificaciones", 'Int'>
    readonly stockBajo: FieldRef<"preferenciasNotificaciones", 'Boolean'>
    readonly productoVencido: FieldRef<"preferenciasNotificaciones", 'Boolean'>
    readonly comentarios: FieldRef<"preferenciasNotificaciones", 'Boolean'>
    readonly reposicion: FieldRef<"preferenciasNotificaciones", 'Boolean'>
    readonly actualizacion: FieldRef<"preferenciasNotificaciones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * preferenciasNotificaciones findUnique
   */
  export type preferenciasNotificacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter, which preferenciasNotificaciones to fetch.
     */
    where: preferenciasNotificacionesWhereUniqueInput
  }

  /**
   * preferenciasNotificaciones findUniqueOrThrow
   */
  export type preferenciasNotificacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter, which preferenciasNotificaciones to fetch.
     */
    where: preferenciasNotificacionesWhereUniqueInput
  }

  /**
   * preferenciasNotificaciones findFirst
   */
  export type preferenciasNotificacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter, which preferenciasNotificaciones to fetch.
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferenciasNotificaciones to fetch.
     */
    orderBy?: preferenciasNotificacionesOrderByWithRelationInput | preferenciasNotificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preferenciasNotificaciones.
     */
    cursor?: preferenciasNotificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferenciasNotificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferenciasNotificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preferenciasNotificaciones.
     */
    distinct?: PreferenciasNotificacionesScalarFieldEnum | PreferenciasNotificacionesScalarFieldEnum[]
  }

  /**
   * preferenciasNotificaciones findFirstOrThrow
   */
  export type preferenciasNotificacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter, which preferenciasNotificaciones to fetch.
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferenciasNotificaciones to fetch.
     */
    orderBy?: preferenciasNotificacionesOrderByWithRelationInput | preferenciasNotificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preferenciasNotificaciones.
     */
    cursor?: preferenciasNotificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferenciasNotificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferenciasNotificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preferenciasNotificaciones.
     */
    distinct?: PreferenciasNotificacionesScalarFieldEnum | PreferenciasNotificacionesScalarFieldEnum[]
  }

  /**
   * preferenciasNotificaciones findMany
   */
  export type preferenciasNotificacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter, which preferenciasNotificaciones to fetch.
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preferenciasNotificaciones to fetch.
     */
    orderBy?: preferenciasNotificacionesOrderByWithRelationInput | preferenciasNotificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preferenciasNotificaciones.
     */
    cursor?: preferenciasNotificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preferenciasNotificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preferenciasNotificaciones.
     */
    skip?: number
    distinct?: PreferenciasNotificacionesScalarFieldEnum | PreferenciasNotificacionesScalarFieldEnum[]
  }

  /**
   * preferenciasNotificaciones create
   */
  export type preferenciasNotificacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a preferenciasNotificaciones.
     */
    data: XOR<preferenciasNotificacionesCreateInput, preferenciasNotificacionesUncheckedCreateInput>
  }

  /**
   * preferenciasNotificaciones createMany
   */
  export type preferenciasNotificacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preferenciasNotificaciones.
     */
    data: preferenciasNotificacionesCreateManyInput | preferenciasNotificacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preferenciasNotificaciones createManyAndReturn
   */
  export type preferenciasNotificacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * The data used to create many preferenciasNotificaciones.
     */
    data: preferenciasNotificacionesCreateManyInput | preferenciasNotificacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * preferenciasNotificaciones update
   */
  export type preferenciasNotificacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a preferenciasNotificaciones.
     */
    data: XOR<preferenciasNotificacionesUpdateInput, preferenciasNotificacionesUncheckedUpdateInput>
    /**
     * Choose, which preferenciasNotificaciones to update.
     */
    where: preferenciasNotificacionesWhereUniqueInput
  }

  /**
   * preferenciasNotificaciones updateMany
   */
  export type preferenciasNotificacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preferenciasNotificaciones.
     */
    data: XOR<preferenciasNotificacionesUpdateManyMutationInput, preferenciasNotificacionesUncheckedUpdateManyInput>
    /**
     * Filter which preferenciasNotificaciones to update
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * Limit how many preferenciasNotificaciones to update.
     */
    limit?: number
  }

  /**
   * preferenciasNotificaciones updateManyAndReturn
   */
  export type preferenciasNotificacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * The data used to update preferenciasNotificaciones.
     */
    data: XOR<preferenciasNotificacionesUpdateManyMutationInput, preferenciasNotificacionesUncheckedUpdateManyInput>
    /**
     * Filter which preferenciasNotificaciones to update
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * Limit how many preferenciasNotificaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * preferenciasNotificaciones upsert
   */
  export type preferenciasNotificacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the preferenciasNotificaciones to update in case it exists.
     */
    where: preferenciasNotificacionesWhereUniqueInput
    /**
     * In case the preferenciasNotificaciones found by the `where` argument doesn't exist, create a new preferenciasNotificaciones with this data.
     */
    create: XOR<preferenciasNotificacionesCreateInput, preferenciasNotificacionesUncheckedCreateInput>
    /**
     * In case the preferenciasNotificaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preferenciasNotificacionesUpdateInput, preferenciasNotificacionesUncheckedUpdateInput>
  }

  /**
   * preferenciasNotificaciones delete
   */
  export type preferenciasNotificacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
    /**
     * Filter which preferenciasNotificaciones to delete.
     */
    where: preferenciasNotificacionesWhereUniqueInput
  }

  /**
   * preferenciasNotificaciones deleteMany
   */
  export type preferenciasNotificacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preferenciasNotificaciones to delete
     */
    where?: preferenciasNotificacionesWhereInput
    /**
     * Limit how many preferenciasNotificaciones to delete.
     */
    limit?: number
  }

  /**
   * preferenciasNotificaciones without action
   */
  export type preferenciasNotificacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preferenciasNotificaciones
     */
    select?: preferenciasNotificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preferenciasNotificaciones
     */
    omit?: preferenciasNotificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preferenciasNotificacionesInclude<ExtArgs> | null
  }


  /**
   * Model productos
   */

  export type AggregateProductos = {
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  export type ProductosAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    cantidad: number | null
    usuarioId: number | null
  }

  export type ProductosSumAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    cantidad: number | null
    usuarioId: number | null
  }

  export type ProductosMinAggregateOutputType = {
    id: number | null
    codigoBarras: string | null
    codigoQR: string | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    cantidad: number | null
    fechaAdquisicion: Date | null
    fechaVencimiento: Date | null
    usuarioId: number | null
    estado: $Enums.EstadoProducto | null
    imagen: string | null
    categoria: string | null
    createdAt: Date | null
    updatedAt: Date | null
    eliminadoEn: Date | null
  }

  export type ProductosMaxAggregateOutputType = {
    id: number | null
    codigoBarras: string | null
    codigoQR: string | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    cantidad: number | null
    fechaAdquisicion: Date | null
    fechaVencimiento: Date | null
    usuarioId: number | null
    estado: $Enums.EstadoProducto | null
    imagen: string | null
    categoria: string | null
    createdAt: Date | null
    updatedAt: Date | null
    eliminadoEn: Date | null
  }

  export type ProductosCountAggregateOutputType = {
    id: number
    codigoBarras: number
    codigoQR: number
    nombre: number
    descripcion: number
    precio: number
    cantidad: number
    fechaAdquisicion: number
    fechaVencimiento: number
    usuarioId: number
    estado: number
    imagen: number
    categoria: number
    createdAt: number
    updatedAt: number
    eliminadoEn: number
    _all: number
  }


  export type ProductosAvgAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    usuarioId?: true
  }

  export type ProductosSumAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    usuarioId?: true
  }

  export type ProductosMinAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    precio?: true
    cantidad?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
  }

  export type ProductosMaxAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    precio?: true
    cantidad?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
  }

  export type ProductosCountAggregateInputType = {
    id?: true
    codigoBarras?: true
    codigoQR?: true
    nombre?: true
    descripcion?: true
    precio?: true
    cantidad?: true
    fechaAdquisicion?: true
    fechaVencimiento?: true
    usuarioId?: true
    estado?: true
    imagen?: true
    categoria?: true
    createdAt?: true
    updatedAt?: true
    eliminadoEn?: true
    _all?: true
  }

  export type ProductosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos to aggregate.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productos
    **/
    _count?: true | ProductosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductosMaxAggregateInputType
  }

  export type GetProductosAggregateType<T extends ProductosAggregateArgs> = {
        [P in keyof T & keyof AggregateProductos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductos[P]>
      : GetScalarType<T[P], AggregateProductos[P]>
  }




  export type productosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productosWhereInput
    orderBy?: productosOrderByWithAggregationInput | productosOrderByWithAggregationInput[]
    by: ProductosScalarFieldEnum[] | ProductosScalarFieldEnum
    having?: productosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductosCountAggregateInputType | true
    _avg?: ProductosAvgAggregateInputType
    _sum?: ProductosSumAggregateInputType
    _min?: ProductosMinAggregateInputType
    _max?: ProductosMaxAggregateInputType
  }

  export type ProductosGroupByOutputType = {
    id: number
    codigoBarras: string | null
    codigoQR: string | null
    nombre: string
    descripcion: string
    precio: Decimal
    cantidad: number
    fechaAdquisicion: Date
    fechaVencimiento: Date
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria: string | null
    createdAt: Date
    updatedAt: Date
    eliminadoEn: Date | null
    _count: ProductosCountAggregateOutputType | null
    _avg: ProductosAvgAggregateOutputType | null
    _sum: ProductosSumAggregateOutputType | null
    _min: ProductosMinAggregateOutputType | null
    _max: ProductosMaxAggregateOutputType | null
  }

  type GetProductosGroupByPayload<T extends productosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductosGroupByOutputType[P]>
            : GetScalarType<T[P], ProductosGroupByOutputType[P]>
        }
      >
    >


  export type productosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    cantidad?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    histInv?: boolean | productos$histInvArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
    recorStock?: boolean | productos$recorStockArgs<ExtArgs>
    comentarios?: boolean | productos$comentariosArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    cantidad?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    cantidad?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productos"]>

  export type productosSelectScalar = {
    id?: boolean
    codigoBarras?: boolean
    codigoQR?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    cantidad?: boolean
    fechaAdquisicion?: boolean
    fechaVencimiento?: boolean
    usuarioId?: boolean
    estado?: boolean
    imagen?: boolean
    categoria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eliminadoEn?: boolean
  }

  export type productosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigoBarras" | "codigoQR" | "nombre" | "descripcion" | "precio" | "cantidad" | "fechaAdquisicion" | "fechaVencimiento" | "usuarioId" | "estado" | "imagen" | "categoria" | "createdAt" | "updatedAt" | "eliminadoEn", ExtArgs["result"]["productos"]>
  export type productosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histInv?: boolean | productos$histInvArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
    recorStock?: boolean | productos$recorStockArgs<ExtArgs>
    comentarios?: boolean | productos$comentariosArgs<ExtArgs>
    _count?: boolean | ProductosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type productosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $productosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productos"
    objects: {
      histInv: Prisma.$histInvPayload<ExtArgs>[]
      usuario: Prisma.$usersPayload<ExtArgs>
      recorStock: Prisma.$recorStockPayload<ExtArgs>[]
      comentarios: Prisma.$comentariosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoBarras: string | null
      codigoQR: string | null
      nombre: string
      descripcion: string
      precio: Prisma.Decimal
      cantidad: number
      fechaAdquisicion: Date
      fechaVencimiento: Date
      usuarioId: number
      estado: $Enums.EstadoProducto
      imagen: string
      categoria: string | null
      createdAt: Date
      updatedAt: Date
      eliminadoEn: Date | null
    }, ExtArgs["result"]["productos"]>
    composites: {}
  }

  type productosGetPayload<S extends boolean | null | undefined | productosDefaultArgs> = $Result.GetResult<Prisma.$productosPayload, S>

  type productosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductosCountAggregateInputType | true
    }

  export interface productosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productos'], meta: { name: 'productos' } }
    /**
     * Find zero or one Productos that matches the filter.
     * @param {productosFindUniqueArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productosFindUniqueArgs>(args: SelectSubset<T, productosFindUniqueArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Productos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productosFindUniqueOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productosFindUniqueOrThrowArgs>(args: SelectSubset<T, productosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindFirstArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productosFindFirstArgs>(args?: SelectSubset<T, productosFindFirstArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindFirstOrThrowArgs} args - Arguments to find a Productos
     * @example
     * // Get one Productos
     * const productos = await prisma.productos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productosFindFirstOrThrowArgs>(args?: SelectSubset<T, productosFindFirstOrThrowArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.productos.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.productos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productosWithIdOnly = await prisma.productos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productosFindManyArgs>(args?: SelectSubset<T, productosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Productos.
     * @param {productosCreateArgs} args - Arguments to create a Productos.
     * @example
     * // Create one Productos
     * const Productos = await prisma.productos.create({
     *   data: {
     *     // ... data to create a Productos
     *   }
     * })
     * 
     */
    create<T extends productosCreateArgs>(args: SelectSubset<T, productosCreateArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productos.
     * @param {productosCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const productos = await prisma.productos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productosCreateManyArgs>(args?: SelectSubset<T, productosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productos and returns the data saved in the database.
     * @param {productosCreateManyAndReturnArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const productos = await prisma.productos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productos and only return the `id`
     * const productosWithIdOnly = await prisma.productos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productosCreateManyAndReturnArgs>(args?: SelectSubset<T, productosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Productos.
     * @param {productosDeleteArgs} args - Arguments to delete one Productos.
     * @example
     * // Delete one Productos
     * const Productos = await prisma.productos.delete({
     *   where: {
     *     // ... filter to delete one Productos
     *   }
     * })
     * 
     */
    delete<T extends productosDeleteArgs>(args: SelectSubset<T, productosDeleteArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Productos.
     * @param {productosUpdateArgs} args - Arguments to update one Productos.
     * @example
     * // Update one Productos
     * const productos = await prisma.productos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productosUpdateArgs>(args: SelectSubset<T, productosUpdateArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productos.
     * @param {productosDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.productos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productosDeleteManyArgs>(args?: SelectSubset<T, productosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productosUpdateManyArgs>(args: SelectSubset<T, productosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos and returns the data updated in the database.
     * @param {productosUpdateManyAndReturnArgs} args - Arguments to update many Productos.
     * @example
     * // Update many Productos
     * const productos = await prisma.productos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productos and only return the `id`
     * const productosWithIdOnly = await prisma.productos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productosUpdateManyAndReturnArgs>(args: SelectSubset<T, productosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Productos.
     * @param {productosUpsertArgs} args - Arguments to update or create a Productos.
     * @example
     * // Update or create a Productos
     * const productos = await prisma.productos.upsert({
     *   create: {
     *     // ... data to create a Productos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productos we want to update
     *   }
     * })
     */
    upsert<T extends productosUpsertArgs>(args: SelectSubset<T, productosUpsertArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.productos.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends productosCountArgs>(
      args?: Subset<T, productosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductosAggregateArgs>(args: Subset<T, ProductosAggregateArgs>): Prisma.PrismaPromise<GetProductosAggregateType<T>>

    /**
     * Group by Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productosGroupByArgs['orderBy'] }
        : { orderBy?: productosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productos model
   */
  readonly fields: productosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    histInv<T extends productos$histInvArgs<ExtArgs> = {}>(args?: Subset<T, productos$histInvArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recorStock<T extends productos$recorStockArgs<ExtArgs> = {}>(args?: Subset<T, productos$recorStockArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comentarios<T extends productos$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, productos$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productos model
   */
  interface productosFieldRefs {
    readonly id: FieldRef<"productos", 'Int'>
    readonly codigoBarras: FieldRef<"productos", 'String'>
    readonly codigoQR: FieldRef<"productos", 'String'>
    readonly nombre: FieldRef<"productos", 'String'>
    readonly descripcion: FieldRef<"productos", 'String'>
    readonly precio: FieldRef<"productos", 'Decimal'>
    readonly cantidad: FieldRef<"productos", 'Int'>
    readonly fechaAdquisicion: FieldRef<"productos", 'DateTime'>
    readonly fechaVencimiento: FieldRef<"productos", 'DateTime'>
    readonly usuarioId: FieldRef<"productos", 'Int'>
    readonly estado: FieldRef<"productos", 'EstadoProducto'>
    readonly imagen: FieldRef<"productos", 'String'>
    readonly categoria: FieldRef<"productos", 'String'>
    readonly createdAt: FieldRef<"productos", 'DateTime'>
    readonly updatedAt: FieldRef<"productos", 'DateTime'>
    readonly eliminadoEn: FieldRef<"productos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * productos findUnique
   */
  export type productosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos findUniqueOrThrow
   */
  export type productosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos findFirst
   */
  export type productosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos findFirstOrThrow
   */
  export type productosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productos.
     */
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos findMany
   */
  export type productosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter, which productos to fetch.
     */
    where?: productosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productos to fetch.
     */
    orderBy?: productosOrderByWithRelationInput | productosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productos.
     */
    cursor?: productosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productos.
     */
    skip?: number
    distinct?: ProductosScalarFieldEnum | ProductosScalarFieldEnum[]
  }

  /**
   * productos create
   */
  export type productosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The data needed to create a productos.
     */
    data: XOR<productosCreateInput, productosUncheckedCreateInput>
  }

  /**
   * productos createMany
   */
  export type productosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productos.
     */
    data: productosCreateManyInput | productosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productos createManyAndReturn
   */
  export type productosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * The data used to create many productos.
     */
    data: productosCreateManyInput | productosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos update
   */
  export type productosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The data needed to update a productos.
     */
    data: XOR<productosUpdateInput, productosUncheckedUpdateInput>
    /**
     * Choose, which productos to update.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos updateMany
   */
  export type productosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productos.
     */
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyInput>
    /**
     * Filter which productos to update
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to update.
     */
    limit?: number
  }

  /**
   * productos updateManyAndReturn
   */
  export type productosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * The data used to update productos.
     */
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyInput>
    /**
     * Filter which productos to update
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * productos upsert
   */
  export type productosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * The filter to search for the productos to update in case it exists.
     */
    where: productosWhereUniqueInput
    /**
     * In case the productos found by the `where` argument doesn't exist, create a new productos with this data.
     */
    create: XOR<productosCreateInput, productosUncheckedCreateInput>
    /**
     * In case the productos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productosUpdateInput, productosUncheckedUpdateInput>
  }

  /**
   * productos delete
   */
  export type productosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
    /**
     * Filter which productos to delete.
     */
    where: productosWhereUniqueInput
  }

  /**
   * productos deleteMany
   */
  export type productosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productos to delete
     */
    where?: productosWhereInput
    /**
     * Limit how many productos to delete.
     */
    limit?: number
  }

  /**
   * productos.histInv
   */
  export type productos$histInvArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    cursor?: histInvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * productos.recorStock
   */
  export type productos$recorStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    where?: recorStockWhereInput
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    cursor?: recorStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * productos.comentarios
   */
  export type productos$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    where?: comentariosWhereInput
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    cursor?: comentariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * productos without action
   */
  export type productosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productos
     */
    select?: productosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productos
     */
    omit?: productosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productosInclude<ExtArgs> | null
  }


  /**
   * Model recorStock
   */

  export type AggregateRecorStock = {
    _count: RecorStockCountAggregateOutputType | null
    _avg: RecorStockAvgAggregateOutputType | null
    _sum: RecorStockSumAggregateOutputType | null
    _min: RecorStockMinAggregateOutputType | null
    _max: RecorStockMaxAggregateOutputType | null
  }

  export type RecorStockAvgAggregateOutputType = {
    idRecordatorio: number | null
    productoId: number | null
    cantidadMinima: number | null
  }

  export type RecorStockSumAggregateOutputType = {
    idRecordatorio: number | null
    productoId: number | null
    cantidadMinima: number | null
  }

  export type RecorStockMinAggregateOutputType = {
    idRecordatorio: number | null
    productoId: number | null
    cantidadMinima: number | null
    fechaRecordatorio: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecorStockMaxAggregateOutputType = {
    idRecordatorio: number | null
    productoId: number | null
    cantidadMinima: number | null
    fechaRecordatorio: Date | null
    estado: $Enums.EstadoRecordatorio | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecorStockCountAggregateOutputType = {
    idRecordatorio: number
    productoId: number
    cantidadMinima: number
    fechaRecordatorio: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecorStockAvgAggregateInputType = {
    idRecordatorio?: true
    productoId?: true
    cantidadMinima?: true
  }

  export type RecorStockSumAggregateInputType = {
    idRecordatorio?: true
    productoId?: true
    cantidadMinima?: true
  }

  export type RecorStockMinAggregateInputType = {
    idRecordatorio?: true
    productoId?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecorStockMaxAggregateInputType = {
    idRecordatorio?: true
    productoId?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecorStockCountAggregateInputType = {
    idRecordatorio?: true
    productoId?: true
    cantidadMinima?: true
    fechaRecordatorio?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecorStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recorStock to aggregate.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recorStocks
    **/
    _count?: true | RecorStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecorStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecorStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecorStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecorStockMaxAggregateInputType
  }

  export type GetRecorStockAggregateType<T extends RecorStockAggregateArgs> = {
        [P in keyof T & keyof AggregateRecorStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecorStock[P]>
      : GetScalarType<T[P], AggregateRecorStock[P]>
  }




  export type recorStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recorStockWhereInput
    orderBy?: recorStockOrderByWithAggregationInput | recorStockOrderByWithAggregationInput[]
    by: RecorStockScalarFieldEnum[] | RecorStockScalarFieldEnum
    having?: recorStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecorStockCountAggregateInputType | true
    _avg?: RecorStockAvgAggregateInputType
    _sum?: RecorStockSumAggregateInputType
    _min?: RecorStockMinAggregateInputType
    _max?: RecorStockMaxAggregateInputType
  }

  export type RecorStockGroupByOutputType = {
    idRecordatorio: number
    productoId: number
    cantidadMinima: number
    fechaRecordatorio: Date
    estado: $Enums.EstadoRecordatorio
    createdAt: Date
    updatedAt: Date
    _count: RecorStockCountAggregateOutputType | null
    _avg: RecorStockAvgAggregateOutputType | null
    _sum: RecorStockSumAggregateOutputType | null
    _min: RecorStockMinAggregateOutputType | null
    _max: RecorStockMaxAggregateOutputType | null
  }

  type GetRecorStockGroupByPayload<T extends recorStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecorStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecorStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecorStockGroupByOutputType[P]>
            : GetScalarType<T[P], RecorStockGroupByOutputType[P]>
        }
      >
    >


  export type recorStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    productoId?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    productoId?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecordatorio?: boolean
    productoId?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recorStock"]>

  export type recorStockSelectScalar = {
    idRecordatorio?: boolean
    productoId?: boolean
    cantidadMinima?: boolean
    fechaRecordatorio?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type recorStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idRecordatorio" | "productoId" | "cantidadMinima" | "fechaRecordatorio" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["recorStock"]>
  export type recorStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type recorStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type recorStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $recorStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recorStock"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idRecordatorio: number
      productoId: number
      cantidadMinima: number
      fechaRecordatorio: Date
      estado: $Enums.EstadoRecordatorio
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recorStock"]>
    composites: {}
  }

  type recorStockGetPayload<S extends boolean | null | undefined | recorStockDefaultArgs> = $Result.GetResult<Prisma.$recorStockPayload, S>

  type recorStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recorStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecorStockCountAggregateInputType | true
    }

  export interface recorStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recorStock'], meta: { name: 'recorStock' } }
    /**
     * Find zero or one RecorStock that matches the filter.
     * @param {recorStockFindUniqueArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recorStockFindUniqueArgs>(args: SelectSubset<T, recorStockFindUniqueArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecorStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recorStockFindUniqueOrThrowArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recorStockFindUniqueOrThrowArgs>(args: SelectSubset<T, recorStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecorStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindFirstArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recorStockFindFirstArgs>(args?: SelectSubset<T, recorStockFindFirstArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecorStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindFirstOrThrowArgs} args - Arguments to find a RecorStock
     * @example
     * // Get one RecorStock
     * const recorStock = await prisma.recorStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recorStockFindFirstOrThrowArgs>(args?: SelectSubset<T, recorStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecorStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecorStocks
     * const recorStocks = await prisma.recorStock.findMany()
     * 
     * // Get first 10 RecorStocks
     * const recorStocks = await prisma.recorStock.findMany({ take: 10 })
     * 
     * // Only select the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.findMany({ select: { idRecordatorio: true } })
     * 
     */
    findMany<T extends recorStockFindManyArgs>(args?: SelectSubset<T, recorStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecorStock.
     * @param {recorStockCreateArgs} args - Arguments to create a RecorStock.
     * @example
     * // Create one RecorStock
     * const RecorStock = await prisma.recorStock.create({
     *   data: {
     *     // ... data to create a RecorStock
     *   }
     * })
     * 
     */
    create<T extends recorStockCreateArgs>(args: SelectSubset<T, recorStockCreateArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecorStocks.
     * @param {recorStockCreateManyArgs} args - Arguments to create many RecorStocks.
     * @example
     * // Create many RecorStocks
     * const recorStock = await prisma.recorStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recorStockCreateManyArgs>(args?: SelectSubset<T, recorStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecorStocks and returns the data saved in the database.
     * @param {recorStockCreateManyAndReturnArgs} args - Arguments to create many RecorStocks.
     * @example
     * // Create many RecorStocks
     * const recorStock = await prisma.recorStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecorStocks and only return the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.createManyAndReturn({
     *   select: { idRecordatorio: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recorStockCreateManyAndReturnArgs>(args?: SelectSubset<T, recorStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecorStock.
     * @param {recorStockDeleteArgs} args - Arguments to delete one RecorStock.
     * @example
     * // Delete one RecorStock
     * const RecorStock = await prisma.recorStock.delete({
     *   where: {
     *     // ... filter to delete one RecorStock
     *   }
     * })
     * 
     */
    delete<T extends recorStockDeleteArgs>(args: SelectSubset<T, recorStockDeleteArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecorStock.
     * @param {recorStockUpdateArgs} args - Arguments to update one RecorStock.
     * @example
     * // Update one RecorStock
     * const recorStock = await prisma.recorStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recorStockUpdateArgs>(args: SelectSubset<T, recorStockUpdateArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecorStocks.
     * @param {recorStockDeleteManyArgs} args - Arguments to filter RecorStocks to delete.
     * @example
     * // Delete a few RecorStocks
     * const { count } = await prisma.recorStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recorStockDeleteManyArgs>(args?: SelectSubset<T, recorStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecorStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecorStocks
     * const recorStock = await prisma.recorStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recorStockUpdateManyArgs>(args: SelectSubset<T, recorStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecorStocks and returns the data updated in the database.
     * @param {recorStockUpdateManyAndReturnArgs} args - Arguments to update many RecorStocks.
     * @example
     * // Update many RecorStocks
     * const recorStock = await prisma.recorStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecorStocks and only return the `idRecordatorio`
     * const recorStockWithIdRecordatorioOnly = await prisma.recorStock.updateManyAndReturn({
     *   select: { idRecordatorio: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recorStockUpdateManyAndReturnArgs>(args: SelectSubset<T, recorStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecorStock.
     * @param {recorStockUpsertArgs} args - Arguments to update or create a RecorStock.
     * @example
     * // Update or create a RecorStock
     * const recorStock = await prisma.recorStock.upsert({
     *   create: {
     *     // ... data to create a RecorStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecorStock we want to update
     *   }
     * })
     */
    upsert<T extends recorStockUpsertArgs>(args: SelectSubset<T, recorStockUpsertArgs<ExtArgs>>): Prisma__recorStockClient<$Result.GetResult<Prisma.$recorStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecorStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockCountArgs} args - Arguments to filter RecorStocks to count.
     * @example
     * // Count the number of RecorStocks
     * const count = await prisma.recorStock.count({
     *   where: {
     *     // ... the filter for the RecorStocks we want to count
     *   }
     * })
    **/
    count<T extends recorStockCountArgs>(
      args?: Subset<T, recorStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecorStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecorStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecorStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecorStockAggregateArgs>(args: Subset<T, RecorStockAggregateArgs>): Prisma.PrismaPromise<GetRecorStockAggregateType<T>>

    /**
     * Group by RecorStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recorStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recorStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recorStockGroupByArgs['orderBy'] }
        : { orderBy?: recorStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recorStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecorStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recorStock model
   */
  readonly fields: recorStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recorStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recorStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recorStock model
   */
  interface recorStockFieldRefs {
    readonly idRecordatorio: FieldRef<"recorStock", 'Int'>
    readonly productoId: FieldRef<"recorStock", 'Int'>
    readonly cantidadMinima: FieldRef<"recorStock", 'Int'>
    readonly fechaRecordatorio: FieldRef<"recorStock", 'DateTime'>
    readonly estado: FieldRef<"recorStock", 'EstadoRecordatorio'>
    readonly createdAt: FieldRef<"recorStock", 'DateTime'>
    readonly updatedAt: FieldRef<"recorStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * recorStock findUnique
   */
  export type recorStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock findUniqueOrThrow
   */
  export type recorStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock findFirst
   */
  export type recorStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recorStocks.
     */
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock findFirstOrThrow
   */
  export type recorStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStock to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recorStocks.
     */
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock findMany
   */
  export type recorStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter, which recorStocks to fetch.
     */
    where?: recorStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recorStocks to fetch.
     */
    orderBy?: recorStockOrderByWithRelationInput | recorStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recorStocks.
     */
    cursor?: recorStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recorStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recorStocks.
     */
    skip?: number
    distinct?: RecorStockScalarFieldEnum | RecorStockScalarFieldEnum[]
  }

  /**
   * recorStock create
   */
  export type recorStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The data needed to create a recorStock.
     */
    data: XOR<recorStockCreateInput, recorStockUncheckedCreateInput>
  }

  /**
   * recorStock createMany
   */
  export type recorStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recorStocks.
     */
    data: recorStockCreateManyInput | recorStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recorStock createManyAndReturn
   */
  export type recorStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * The data used to create many recorStocks.
     */
    data: recorStockCreateManyInput | recorStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recorStock update
   */
  export type recorStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The data needed to update a recorStock.
     */
    data: XOR<recorStockUpdateInput, recorStockUncheckedUpdateInput>
    /**
     * Choose, which recorStock to update.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock updateMany
   */
  export type recorStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recorStocks.
     */
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyInput>
    /**
     * Filter which recorStocks to update
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to update.
     */
    limit?: number
  }

  /**
   * recorStock updateManyAndReturn
   */
  export type recorStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * The data used to update recorStocks.
     */
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyInput>
    /**
     * Filter which recorStocks to update
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * recorStock upsert
   */
  export type recorStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * The filter to search for the recorStock to update in case it exists.
     */
    where: recorStockWhereUniqueInput
    /**
     * In case the recorStock found by the `where` argument doesn't exist, create a new recorStock with this data.
     */
    create: XOR<recorStockCreateInput, recorStockUncheckedCreateInput>
    /**
     * In case the recorStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recorStockUpdateInput, recorStockUncheckedUpdateInput>
  }

  /**
   * recorStock delete
   */
  export type recorStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
    /**
     * Filter which recorStock to delete.
     */
    where: recorStockWhereUniqueInput
  }

  /**
   * recorStock deleteMany
   */
  export type recorStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recorStocks to delete
     */
    where?: recorStockWhereInput
    /**
     * Limit how many recorStocks to delete.
     */
    limit?: number
  }

  /**
   * recorStock without action
   */
  export type recorStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recorStock
     */
    select?: recorStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recorStock
     */
    omit?: recorStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recorStockInclude<ExtArgs> | null
  }


  /**
   * Model comentarios
   */

  export type AggregateComentarios = {
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  export type ComentariosAvgAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    idProducto: number | null
  }

  export type ComentariosSumAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    idProducto: number | null
  }

  export type ComentariosMinAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    idProducto: number | null
    comentario: string | null
    fechaComentario: Date | null
    estado: $Enums.EstadoComentario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosMaxAggregateOutputType = {
    idComentario: number | null
    idUsuario: number | null
    idProducto: number | null
    comentario: string | null
    fechaComentario: Date | null
    estado: $Enums.EstadoComentario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComentariosCountAggregateOutputType = {
    idComentario: number
    idUsuario: number
    idProducto: number
    comentario: number
    fechaComentario: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComentariosAvgAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    idProducto?: true
  }

  export type ComentariosSumAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    idProducto?: true
  }

  export type ComentariosMinAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    idProducto?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosMaxAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    idProducto?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComentariosCountAggregateInputType = {
    idComentario?: true
    idUsuario?: true
    idProducto?: true
    comentario?: true
    fechaComentario?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComentariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to aggregate.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentarios
    **/
    _count?: true | ComentariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentariosMaxAggregateInputType
  }

  export type GetComentariosAggregateType<T extends ComentariosAggregateArgs> = {
        [P in keyof T & keyof AggregateComentarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentarios[P]>
      : GetScalarType<T[P], AggregateComentarios[P]>
  }




  export type comentariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentariosWhereInput
    orderBy?: comentariosOrderByWithAggregationInput | comentariosOrderByWithAggregationInput[]
    by: ComentariosScalarFieldEnum[] | ComentariosScalarFieldEnum
    having?: comentariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentariosCountAggregateInputType | true
    _avg?: ComentariosAvgAggregateInputType
    _sum?: ComentariosSumAggregateInputType
    _min?: ComentariosMinAggregateInputType
    _max?: ComentariosMaxAggregateInputType
  }

  export type ComentariosGroupByOutputType = {
    idComentario: number
    idUsuario: number
    idProducto: number
    comentario: string
    fechaComentario: Date
    estado: $Enums.EstadoComentario
    createdAt: Date
    updatedAt: Date
    _count: ComentariosCountAggregateOutputType | null
    _avg: ComentariosAvgAggregateOutputType | null
    _sum: ComentariosSumAggregateOutputType | null
    _min: ComentariosMinAggregateOutputType | null
    _max: ComentariosMaxAggregateOutputType | null
  }

  type GetComentariosGroupByPayload<T extends comentariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
            : GetScalarType<T[P], ComentariosGroupByOutputType[P]>
        }
      >
    >


  export type comentariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentario?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentarios"]>

  export type comentariosSelectScalar = {
    idComentario?: boolean
    idUsuario?: boolean
    idProducto?: boolean
    comentario?: boolean
    fechaComentario?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type comentariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idComentario" | "idUsuario" | "idProducto" | "comentario" | "fechaComentario" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["comentarios"]>
  export type comentariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type comentariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }
  export type comentariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    producto?: boolean | productosDefaultArgs<ExtArgs>
  }

  export type $comentariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comentarios"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      producto: Prisma.$productosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idComentario: number
      idUsuario: number
      idProducto: number
      comentario: string
      fechaComentario: Date
      estado: $Enums.EstadoComentario
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comentarios"]>
    composites: {}
  }

  type comentariosGetPayload<S extends boolean | null | undefined | comentariosDefaultArgs> = $Result.GetResult<Prisma.$comentariosPayload, S>

  type comentariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comentariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComentariosCountAggregateInputType | true
    }

  export interface comentariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comentarios'], meta: { name: 'comentarios' } }
    /**
     * Find zero or one Comentarios that matches the filter.
     * @param {comentariosFindUniqueArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comentariosFindUniqueArgs>(args: SelectSubset<T, comentariosFindUniqueArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comentarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comentariosFindUniqueOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comentariosFindUniqueOrThrowArgs>(args: SelectSubset<T, comentariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comentariosFindFirstArgs>(args?: SelectSubset<T, comentariosFindFirstArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comentarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindFirstOrThrowArgs} args - Arguments to find a Comentarios
     * @example
     * // Get one Comentarios
     * const comentarios = await prisma.comentarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comentariosFindFirstOrThrowArgs>(args?: SelectSubset<T, comentariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentarios.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentarios.findMany({ take: 10 })
     * 
     * // Only select the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.findMany({ select: { idComentario: true } })
     * 
     */
    findMany<T extends comentariosFindManyArgs>(args?: SelectSubset<T, comentariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comentarios.
     * @param {comentariosCreateArgs} args - Arguments to create a Comentarios.
     * @example
     * // Create one Comentarios
     * const Comentarios = await prisma.comentarios.create({
     *   data: {
     *     // ... data to create a Comentarios
     *   }
     * })
     * 
     */
    create<T extends comentariosCreateArgs>(args: SelectSubset<T, comentariosCreateArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comentarios.
     * @param {comentariosCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentarios = await prisma.comentarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comentariosCreateManyArgs>(args?: SelectSubset<T, comentariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comentarios and returns the data saved in the database.
     * @param {comentariosCreateManyAndReturnArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentarios = await prisma.comentarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comentarios and only return the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.createManyAndReturn({
     *   select: { idComentario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comentariosCreateManyAndReturnArgs>(args?: SelectSubset<T, comentariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comentarios.
     * @param {comentariosDeleteArgs} args - Arguments to delete one Comentarios.
     * @example
     * // Delete one Comentarios
     * const Comentarios = await prisma.comentarios.delete({
     *   where: {
     *     // ... filter to delete one Comentarios
     *   }
     * })
     * 
     */
    delete<T extends comentariosDeleteArgs>(args: SelectSubset<T, comentariosDeleteArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comentarios.
     * @param {comentariosUpdateArgs} args - Arguments to update one Comentarios.
     * @example
     * // Update one Comentarios
     * const comentarios = await prisma.comentarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comentariosUpdateArgs>(args: SelectSubset<T, comentariosUpdateArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comentarios.
     * @param {comentariosDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comentariosDeleteManyArgs>(args?: SelectSubset<T, comentariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comentariosUpdateManyArgs>(args: SelectSubset<T, comentariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios and returns the data updated in the database.
     * @param {comentariosUpdateManyAndReturnArgs} args - Arguments to update many Comentarios.
     * @example
     * // Update many Comentarios
     * const comentarios = await prisma.comentarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comentarios and only return the `idComentario`
     * const comentariosWithIdComentarioOnly = await prisma.comentarios.updateManyAndReturn({
     *   select: { idComentario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comentariosUpdateManyAndReturnArgs>(args: SelectSubset<T, comentariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comentarios.
     * @param {comentariosUpsertArgs} args - Arguments to update or create a Comentarios.
     * @example
     * // Update or create a Comentarios
     * const comentarios = await prisma.comentarios.upsert({
     *   create: {
     *     // ... data to create a Comentarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentarios we want to update
     *   }
     * })
     */
    upsert<T extends comentariosUpsertArgs>(args: SelectSubset<T, comentariosUpsertArgs<ExtArgs>>): Prisma__comentariosClient<$Result.GetResult<Prisma.$comentariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentarios.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends comentariosCountArgs>(
      args?: Subset<T, comentariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentariosAggregateArgs>(args: Subset<T, ComentariosAggregateArgs>): Prisma.PrismaPromise<GetComentariosAggregateType<T>>

    /**
     * Group by Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comentariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comentariosGroupByArgs['orderBy'] }
        : { orderBy?: comentariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comentariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comentarios model
   */
  readonly fields: comentariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comentarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comentariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comentarios model
   */
  interface comentariosFieldRefs {
    readonly idComentario: FieldRef<"comentarios", 'Int'>
    readonly idUsuario: FieldRef<"comentarios", 'Int'>
    readonly idProducto: FieldRef<"comentarios", 'Int'>
    readonly comentario: FieldRef<"comentarios", 'String'>
    readonly fechaComentario: FieldRef<"comentarios", 'DateTime'>
    readonly estado: FieldRef<"comentarios", 'EstadoComentario'>
    readonly createdAt: FieldRef<"comentarios", 'DateTime'>
    readonly updatedAt: FieldRef<"comentarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comentarios findUnique
   */
  export type comentariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios findUniqueOrThrow
   */
  export type comentariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios findFirst
   */
  export type comentariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios findFirstOrThrow
   */
  export type comentariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios findMany
   */
  export type comentariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentariosOrderByWithRelationInput | comentariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentarios.
     */
    cursor?: comentariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    distinct?: ComentariosScalarFieldEnum | ComentariosScalarFieldEnum[]
  }

  /**
   * comentarios create
   */
  export type comentariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The data needed to create a comentarios.
     */
    data: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
  }

  /**
   * comentarios createMany
   */
  export type comentariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comentarios.
     */
    data: comentariosCreateManyInput | comentariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comentarios createManyAndReturn
   */
  export type comentariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * The data used to create many comentarios.
     */
    data: comentariosCreateManyInput | comentariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comentarios update
   */
  export type comentariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The data needed to update a comentarios.
     */
    data: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
    /**
     * Choose, which comentarios to update.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios updateMany
   */
  export type comentariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to update.
     */
    limit?: number
  }

  /**
   * comentarios updateManyAndReturn
   */
  export type comentariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comentarios upsert
   */
  export type comentariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * The filter to search for the comentarios to update in case it exists.
     */
    where: comentariosWhereUniqueInput
    /**
     * In case the comentarios found by the `where` argument doesn't exist, create a new comentarios with this data.
     */
    create: XOR<comentariosCreateInput, comentariosUncheckedCreateInput>
    /**
     * In case the comentarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentariosUpdateInput, comentariosUncheckedUpdateInput>
  }

  /**
   * comentarios delete
   */
  export type comentariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
    /**
     * Filter which comentarios to delete.
     */
    where: comentariosWhereUniqueInput
  }

  /**
   * comentarios deleteMany
   */
  export type comentariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to delete
     */
    where?: comentariosWhereInput
    /**
     * Limit how many comentarios to delete.
     */
    limit?: number
  }

  /**
   * comentarios without action
   */
  export type comentariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentarios
     */
    select?: comentariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comentarios
     */
    omit?: comentariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentariosInclude<ExtArgs> | null
  }


  /**
   * Model NutriScan
   */

  export type AggregateNutriScan = {
    _count: NutriScanCountAggregateOutputType | null
    _avg: NutriScanAvgAggregateOutputType | null
    _sum: NutriScanSumAggregateOutputType | null
    _min: NutriScanMinAggregateOutputType | null
    _max: NutriScanMaxAggregateOutputType | null
  }

  export type NutriScanAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NutriScanSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type NutriScanMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    esAlimento: boolean | null
    consulta: string | null
    tipoAnalisis: string | null
    fechaAnalisis: Date | null
    actualizadoEn: Date | null
    isTest: boolean | null
  }

  export type NutriScanMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    esAlimento: boolean | null
    consulta: string | null
    tipoAnalisis: string | null
    fechaAnalisis: Date | null
    actualizadoEn: Date | null
    isTest: boolean | null
  }

  export type NutriScanCountAggregateOutputType = {
    id: number
    usuarioId: number
    esAlimento: number
    consulta: number
    respuesta: number
    tipoAnalisis: number
    fechaAnalisis: number
    actualizadoEn: number
    isTest: number
    _all: number
  }


  export type NutriScanAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NutriScanSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type NutriScanMinAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    tipoAnalisis?: true
    fechaAnalisis?: true
    actualizadoEn?: true
    isTest?: true
  }

  export type NutriScanMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    tipoAnalisis?: true
    fechaAnalisis?: true
    actualizadoEn?: true
    isTest?: true
  }

  export type NutriScanCountAggregateInputType = {
    id?: true
    usuarioId?: true
    esAlimento?: true
    consulta?: true
    respuesta?: true
    tipoAnalisis?: true
    fechaAnalisis?: true
    actualizadoEn?: true
    isTest?: true
    _all?: true
  }

  export type NutriScanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutriScan to aggregate.
     */
    where?: NutriScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutriScans to fetch.
     */
    orderBy?: NutriScanOrderByWithRelationInput | NutriScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutriScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutriScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutriScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutriScans
    **/
    _count?: true | NutriScanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutriScanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutriScanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutriScanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutriScanMaxAggregateInputType
  }

  export type GetNutriScanAggregateType<T extends NutriScanAggregateArgs> = {
        [P in keyof T & keyof AggregateNutriScan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutriScan[P]>
      : GetScalarType<T[P], AggregateNutriScan[P]>
  }




  export type NutriScanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutriScanWhereInput
    orderBy?: NutriScanOrderByWithAggregationInput | NutriScanOrderByWithAggregationInput[]
    by: NutriScanScalarFieldEnum[] | NutriScanScalarFieldEnum
    having?: NutriScanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutriScanCountAggregateInputType | true
    _avg?: NutriScanAvgAggregateInputType
    _sum?: NutriScanSumAggregateInputType
    _min?: NutriScanMinAggregateInputType
    _max?: NutriScanMaxAggregateInputType
  }

  export type NutriScanGroupByOutputType = {
    id: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonValue
    tipoAnalisis: string
    fechaAnalisis: Date
    actualizadoEn: Date
    isTest: boolean
    _count: NutriScanCountAggregateOutputType | null
    _avg: NutriScanAvgAggregateOutputType | null
    _sum: NutriScanSumAggregateOutputType | null
    _min: NutriScanMinAggregateOutputType | null
    _max: NutriScanMaxAggregateOutputType | null
  }

  type GetNutriScanGroupByPayload<T extends NutriScanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutriScanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutriScanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutriScanGroupByOutputType[P]>
            : GetScalarType<T[P], NutriScanGroupByOutputType[P]>
        }
      >
    >


  export type NutriScanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    tipoAnalisis?: boolean
    fechaAnalisis?: boolean
    actualizadoEn?: boolean
    isTest?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutriScan"]>

  export type NutriScanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    tipoAnalisis?: boolean
    fechaAnalisis?: boolean
    actualizadoEn?: boolean
    isTest?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutriScan"]>

  export type NutriScanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    tipoAnalisis?: boolean
    fechaAnalisis?: boolean
    actualizadoEn?: boolean
    isTest?: boolean
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutriScan"]>

  export type NutriScanSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    esAlimento?: boolean
    consulta?: boolean
    respuesta?: boolean
    tipoAnalisis?: boolean
    fechaAnalisis?: boolean
    actualizadoEn?: boolean
    isTest?: boolean
  }

  export type NutriScanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "esAlimento" | "consulta" | "respuesta" | "tipoAnalisis" | "fechaAnalisis" | "actualizadoEn" | "isTest", ExtArgs["result"]["nutriScan"]>
  export type NutriScanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type NutriScanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type NutriScanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $NutriScanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutriScan"
    objects: {
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      esAlimento: boolean
      consulta: string
      respuesta: Prisma.JsonValue
      tipoAnalisis: string
      fechaAnalisis: Date
      actualizadoEn: Date
      isTest: boolean
    }, ExtArgs["result"]["nutriScan"]>
    composites: {}
  }

  type NutriScanGetPayload<S extends boolean | null | undefined | NutriScanDefaultArgs> = $Result.GetResult<Prisma.$NutriScanPayload, S>

  type NutriScanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutriScanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutriScanCountAggregateInputType | true
    }

  export interface NutriScanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutriScan'], meta: { name: 'NutriScan' } }
    /**
     * Find zero or one NutriScan that matches the filter.
     * @param {NutriScanFindUniqueArgs} args - Arguments to find a NutriScan
     * @example
     * // Get one NutriScan
     * const nutriScan = await prisma.nutriScan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutriScanFindUniqueArgs>(args: SelectSubset<T, NutriScanFindUniqueArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutriScan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutriScanFindUniqueOrThrowArgs} args - Arguments to find a NutriScan
     * @example
     * // Get one NutriScan
     * const nutriScan = await prisma.nutriScan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutriScanFindUniqueOrThrowArgs>(args: SelectSubset<T, NutriScanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutriScan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanFindFirstArgs} args - Arguments to find a NutriScan
     * @example
     * // Get one NutriScan
     * const nutriScan = await prisma.nutriScan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutriScanFindFirstArgs>(args?: SelectSubset<T, NutriScanFindFirstArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutriScan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanFindFirstOrThrowArgs} args - Arguments to find a NutriScan
     * @example
     * // Get one NutriScan
     * const nutriScan = await prisma.nutriScan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutriScanFindFirstOrThrowArgs>(args?: SelectSubset<T, NutriScanFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutriScans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutriScans
     * const nutriScans = await prisma.nutriScan.findMany()
     * 
     * // Get first 10 NutriScans
     * const nutriScans = await prisma.nutriScan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutriScanWithIdOnly = await prisma.nutriScan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutriScanFindManyArgs>(args?: SelectSubset<T, NutriScanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutriScan.
     * @param {NutriScanCreateArgs} args - Arguments to create a NutriScan.
     * @example
     * // Create one NutriScan
     * const NutriScan = await prisma.nutriScan.create({
     *   data: {
     *     // ... data to create a NutriScan
     *   }
     * })
     * 
     */
    create<T extends NutriScanCreateArgs>(args: SelectSubset<T, NutriScanCreateArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutriScans.
     * @param {NutriScanCreateManyArgs} args - Arguments to create many NutriScans.
     * @example
     * // Create many NutriScans
     * const nutriScan = await prisma.nutriScan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutriScanCreateManyArgs>(args?: SelectSubset<T, NutriScanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutriScans and returns the data saved in the database.
     * @param {NutriScanCreateManyAndReturnArgs} args - Arguments to create many NutriScans.
     * @example
     * // Create many NutriScans
     * const nutriScan = await prisma.nutriScan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutriScans and only return the `id`
     * const nutriScanWithIdOnly = await prisma.nutriScan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutriScanCreateManyAndReturnArgs>(args?: SelectSubset<T, NutriScanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutriScan.
     * @param {NutriScanDeleteArgs} args - Arguments to delete one NutriScan.
     * @example
     * // Delete one NutriScan
     * const NutriScan = await prisma.nutriScan.delete({
     *   where: {
     *     // ... filter to delete one NutriScan
     *   }
     * })
     * 
     */
    delete<T extends NutriScanDeleteArgs>(args: SelectSubset<T, NutriScanDeleteArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutriScan.
     * @param {NutriScanUpdateArgs} args - Arguments to update one NutriScan.
     * @example
     * // Update one NutriScan
     * const nutriScan = await prisma.nutriScan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutriScanUpdateArgs>(args: SelectSubset<T, NutriScanUpdateArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutriScans.
     * @param {NutriScanDeleteManyArgs} args - Arguments to filter NutriScans to delete.
     * @example
     * // Delete a few NutriScans
     * const { count } = await prisma.nutriScan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutriScanDeleteManyArgs>(args?: SelectSubset<T, NutriScanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutriScans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutriScans
     * const nutriScan = await prisma.nutriScan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutriScanUpdateManyArgs>(args: SelectSubset<T, NutriScanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutriScans and returns the data updated in the database.
     * @param {NutriScanUpdateManyAndReturnArgs} args - Arguments to update many NutriScans.
     * @example
     * // Update many NutriScans
     * const nutriScan = await prisma.nutriScan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutriScans and only return the `id`
     * const nutriScanWithIdOnly = await prisma.nutriScan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutriScanUpdateManyAndReturnArgs>(args: SelectSubset<T, NutriScanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutriScan.
     * @param {NutriScanUpsertArgs} args - Arguments to update or create a NutriScan.
     * @example
     * // Update or create a NutriScan
     * const nutriScan = await prisma.nutriScan.upsert({
     *   create: {
     *     // ... data to create a NutriScan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutriScan we want to update
     *   }
     * })
     */
    upsert<T extends NutriScanUpsertArgs>(args: SelectSubset<T, NutriScanUpsertArgs<ExtArgs>>): Prisma__NutriScanClient<$Result.GetResult<Prisma.$NutriScanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutriScans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanCountArgs} args - Arguments to filter NutriScans to count.
     * @example
     * // Count the number of NutriScans
     * const count = await prisma.nutriScan.count({
     *   where: {
     *     // ... the filter for the NutriScans we want to count
     *   }
     * })
    **/
    count<T extends NutriScanCountArgs>(
      args?: Subset<T, NutriScanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutriScanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutriScan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutriScanAggregateArgs>(args: Subset<T, NutriScanAggregateArgs>): Prisma.PrismaPromise<GetNutriScanAggregateType<T>>

    /**
     * Group by NutriScan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutriScanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutriScanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutriScanGroupByArgs['orderBy'] }
        : { orderBy?: NutriScanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutriScanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutriScanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutriScan model
   */
  readonly fields: NutriScanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutriScan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutriScanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutriScan model
   */
  interface NutriScanFieldRefs {
    readonly id: FieldRef<"NutriScan", 'Int'>
    readonly usuarioId: FieldRef<"NutriScan", 'Int'>
    readonly esAlimento: FieldRef<"NutriScan", 'Boolean'>
    readonly consulta: FieldRef<"NutriScan", 'String'>
    readonly respuesta: FieldRef<"NutriScan", 'Json'>
    readonly tipoAnalisis: FieldRef<"NutriScan", 'String'>
    readonly fechaAnalisis: FieldRef<"NutriScan", 'DateTime'>
    readonly actualizadoEn: FieldRef<"NutriScan", 'DateTime'>
    readonly isTest: FieldRef<"NutriScan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NutriScan findUnique
   */
  export type NutriScanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter, which NutriScan to fetch.
     */
    where: NutriScanWhereUniqueInput
  }

  /**
   * NutriScan findUniqueOrThrow
   */
  export type NutriScanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter, which NutriScan to fetch.
     */
    where: NutriScanWhereUniqueInput
  }

  /**
   * NutriScan findFirst
   */
  export type NutriScanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter, which NutriScan to fetch.
     */
    where?: NutriScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutriScans to fetch.
     */
    orderBy?: NutriScanOrderByWithRelationInput | NutriScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutriScans.
     */
    cursor?: NutriScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutriScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutriScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutriScans.
     */
    distinct?: NutriScanScalarFieldEnum | NutriScanScalarFieldEnum[]
  }

  /**
   * NutriScan findFirstOrThrow
   */
  export type NutriScanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter, which NutriScan to fetch.
     */
    where?: NutriScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutriScans to fetch.
     */
    orderBy?: NutriScanOrderByWithRelationInput | NutriScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutriScans.
     */
    cursor?: NutriScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutriScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutriScans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutriScans.
     */
    distinct?: NutriScanScalarFieldEnum | NutriScanScalarFieldEnum[]
  }

  /**
   * NutriScan findMany
   */
  export type NutriScanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter, which NutriScans to fetch.
     */
    where?: NutriScanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutriScans to fetch.
     */
    orderBy?: NutriScanOrderByWithRelationInput | NutriScanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutriScans.
     */
    cursor?: NutriScanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutriScans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutriScans.
     */
    skip?: number
    distinct?: NutriScanScalarFieldEnum | NutriScanScalarFieldEnum[]
  }

  /**
   * NutriScan create
   */
  export type NutriScanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * The data needed to create a NutriScan.
     */
    data: XOR<NutriScanCreateInput, NutriScanUncheckedCreateInput>
  }

  /**
   * NutriScan createMany
   */
  export type NutriScanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutriScans.
     */
    data: NutriScanCreateManyInput | NutriScanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutriScan createManyAndReturn
   */
  export type NutriScanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * The data used to create many NutriScans.
     */
    data: NutriScanCreateManyInput | NutriScanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutriScan update
   */
  export type NutriScanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * The data needed to update a NutriScan.
     */
    data: XOR<NutriScanUpdateInput, NutriScanUncheckedUpdateInput>
    /**
     * Choose, which NutriScan to update.
     */
    where: NutriScanWhereUniqueInput
  }

  /**
   * NutriScan updateMany
   */
  export type NutriScanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutriScans.
     */
    data: XOR<NutriScanUpdateManyMutationInput, NutriScanUncheckedUpdateManyInput>
    /**
     * Filter which NutriScans to update
     */
    where?: NutriScanWhereInput
    /**
     * Limit how many NutriScans to update.
     */
    limit?: number
  }

  /**
   * NutriScan updateManyAndReturn
   */
  export type NutriScanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * The data used to update NutriScans.
     */
    data: XOR<NutriScanUpdateManyMutationInput, NutriScanUncheckedUpdateManyInput>
    /**
     * Filter which NutriScans to update
     */
    where?: NutriScanWhereInput
    /**
     * Limit how many NutriScans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutriScan upsert
   */
  export type NutriScanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * The filter to search for the NutriScan to update in case it exists.
     */
    where: NutriScanWhereUniqueInput
    /**
     * In case the NutriScan found by the `where` argument doesn't exist, create a new NutriScan with this data.
     */
    create: XOR<NutriScanCreateInput, NutriScanUncheckedCreateInput>
    /**
     * In case the NutriScan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutriScanUpdateInput, NutriScanUncheckedUpdateInput>
  }

  /**
   * NutriScan delete
   */
  export type NutriScanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
    /**
     * Filter which NutriScan to delete.
     */
    where: NutriScanWhereUniqueInput
  }

  /**
   * NutriScan deleteMany
   */
  export type NutriScanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutriScans to delete
     */
    where?: NutriScanWhereInput
    /**
     * Limit how many NutriScans to delete.
     */
    limit?: number
  }

  /**
   * NutriScan without action
   */
  export type NutriScanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutriScan
     */
    select?: NutriScanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutriScan
     */
    omit?: NutriScanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutriScanInclude<ExtArgs> | null
  }


  /**
   * Model histInv
   */

  export type AggregateHistInv = {
    _count: HistInvCountAggregateOutputType | null
    _avg: HistInvAvgAggregateOutputType | null
    _sum: HistInvSumAggregateOutputType | null
    _min: HistInvMinAggregateOutputType | null
    _max: HistInvMaxAggregateOutputType | null
  }

  export type HistInvAvgAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
  }

  export type HistInvSumAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
  }

  export type HistInvMinAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    accion: $Enums.AccionHistorial | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
    fechaCambio: Date | null
  }

  export type HistInvMaxAggregateOutputType = {
    id: number | null
    productoId: number | null
    usuarioId: number | null
    accion: $Enums.AccionHistorial | null
    cantidad_anterior: number | null
    cantidad_nueva: number | null
    precio_anterior: Decimal | null
    precio_nuevo: Decimal | null
    fechaCambio: Date | null
  }

  export type HistInvCountAggregateOutputType = {
    id: number
    productoId: number
    usuarioId: number
    accion: number
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: number
    precio_nuevo: number
    fechaCambio: number
    _all: number
  }


  export type HistInvAvgAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
  }

  export type HistInvSumAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
  }

  export type HistInvMinAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
  }

  export type HistInvMaxAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
  }

  export type HistInvCountAggregateInputType = {
    id?: true
    productoId?: true
    usuarioId?: true
    accion?: true
    cantidad_anterior?: true
    cantidad_nueva?: true
    precio_anterior?: true
    precio_nuevo?: true
    fechaCambio?: true
    _all?: true
  }

  export type HistInvAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histInv to aggregate.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned histInvs
    **/
    _count?: true | HistInvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistInvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistInvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistInvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistInvMaxAggregateInputType
  }

  export type GetHistInvAggregateType<T extends HistInvAggregateArgs> = {
        [P in keyof T & keyof AggregateHistInv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistInv[P]>
      : GetScalarType<T[P], AggregateHistInv[P]>
  }




  export type histInvGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: histInvWhereInput
    orderBy?: histInvOrderByWithAggregationInput | histInvOrderByWithAggregationInput[]
    by: HistInvScalarFieldEnum[] | HistInvScalarFieldEnum
    having?: histInvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistInvCountAggregateInputType | true
    _avg?: HistInvAvgAggregateInputType
    _sum?: HistInvSumAggregateInputType
    _min?: HistInvMinAggregateInputType
    _max?: HistInvMaxAggregateInputType
  }

  export type HistInvGroupByOutputType = {
    id: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal
    precio_nuevo: Decimal
    fechaCambio: Date
    _count: HistInvCountAggregateOutputType | null
    _avg: HistInvAvgAggregateOutputType | null
    _sum: HistInvSumAggregateOutputType | null
    _min: HistInvMinAggregateOutputType | null
    _max: HistInvMaxAggregateOutputType | null
  }

  type GetHistInvGroupByPayload<T extends histInvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistInvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistInvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistInvGroupByOutputType[P]>
            : GetScalarType<T[P], HistInvGroupByOutputType[P]>
        }
      >
    >


  export type histInvSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["histInv"]>

  export type histInvSelectScalar = {
    id?: boolean
    productoId?: boolean
    usuarioId?: boolean
    accion?: boolean
    cantidad_anterior?: boolean
    cantidad_nueva?: boolean
    precio_anterior?: boolean
    precio_nuevo?: boolean
    fechaCambio?: boolean
  }

  export type histInvOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productoId" | "usuarioId" | "accion" | "cantidad_anterior" | "cantidad_nueva" | "precio_anterior" | "precio_nuevo" | "fechaCambio", ExtArgs["result"]["histInv"]>
  export type histInvInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type histInvIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type histInvIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    producto?: boolean | productosDefaultArgs<ExtArgs>
    usuario?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $histInvPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "histInv"
    objects: {
      producto: Prisma.$productosPayload<ExtArgs>
      usuario: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productoId: number
      usuarioId: number
      accion: $Enums.AccionHistorial
      cantidad_anterior: number
      cantidad_nueva: number
      precio_anterior: Prisma.Decimal
      precio_nuevo: Prisma.Decimal
      fechaCambio: Date
    }, ExtArgs["result"]["histInv"]>
    composites: {}
  }

  type histInvGetPayload<S extends boolean | null | undefined | histInvDefaultArgs> = $Result.GetResult<Prisma.$histInvPayload, S>

  type histInvCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<histInvFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistInvCountAggregateInputType | true
    }

  export interface histInvDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['histInv'], meta: { name: 'histInv' } }
    /**
     * Find zero or one HistInv that matches the filter.
     * @param {histInvFindUniqueArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends histInvFindUniqueArgs>(args: SelectSubset<T, histInvFindUniqueArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistInv that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {histInvFindUniqueOrThrowArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends histInvFindUniqueOrThrowArgs>(args: SelectSubset<T, histInvFindUniqueOrThrowArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistInv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindFirstArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends histInvFindFirstArgs>(args?: SelectSubset<T, histInvFindFirstArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistInv that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindFirstOrThrowArgs} args - Arguments to find a HistInv
     * @example
     * // Get one HistInv
     * const histInv = await prisma.histInv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends histInvFindFirstOrThrowArgs>(args?: SelectSubset<T, histInvFindFirstOrThrowArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistInvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistInvs
     * const histInvs = await prisma.histInv.findMany()
     * 
     * // Get first 10 HistInvs
     * const histInvs = await prisma.histInv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const histInvWithIdOnly = await prisma.histInv.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends histInvFindManyArgs>(args?: SelectSubset<T, histInvFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistInv.
     * @param {histInvCreateArgs} args - Arguments to create a HistInv.
     * @example
     * // Create one HistInv
     * const HistInv = await prisma.histInv.create({
     *   data: {
     *     // ... data to create a HistInv
     *   }
     * })
     * 
     */
    create<T extends histInvCreateArgs>(args: SelectSubset<T, histInvCreateArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistInvs.
     * @param {histInvCreateManyArgs} args - Arguments to create many HistInvs.
     * @example
     * // Create many HistInvs
     * const histInv = await prisma.histInv.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends histInvCreateManyArgs>(args?: SelectSubset<T, histInvCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistInvs and returns the data saved in the database.
     * @param {histInvCreateManyAndReturnArgs} args - Arguments to create many HistInvs.
     * @example
     * // Create many HistInvs
     * const histInv = await prisma.histInv.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistInvs and only return the `id`
     * const histInvWithIdOnly = await prisma.histInv.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends histInvCreateManyAndReturnArgs>(args?: SelectSubset<T, histInvCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistInv.
     * @param {histInvDeleteArgs} args - Arguments to delete one HistInv.
     * @example
     * // Delete one HistInv
     * const HistInv = await prisma.histInv.delete({
     *   where: {
     *     // ... filter to delete one HistInv
     *   }
     * })
     * 
     */
    delete<T extends histInvDeleteArgs>(args: SelectSubset<T, histInvDeleteArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistInv.
     * @param {histInvUpdateArgs} args - Arguments to update one HistInv.
     * @example
     * // Update one HistInv
     * const histInv = await prisma.histInv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends histInvUpdateArgs>(args: SelectSubset<T, histInvUpdateArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistInvs.
     * @param {histInvDeleteManyArgs} args - Arguments to filter HistInvs to delete.
     * @example
     * // Delete a few HistInvs
     * const { count } = await prisma.histInv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends histInvDeleteManyArgs>(args?: SelectSubset<T, histInvDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistInvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistInvs
     * const histInv = await prisma.histInv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends histInvUpdateManyArgs>(args: SelectSubset<T, histInvUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistInvs and returns the data updated in the database.
     * @param {histInvUpdateManyAndReturnArgs} args - Arguments to update many HistInvs.
     * @example
     * // Update many HistInvs
     * const histInv = await prisma.histInv.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistInvs and only return the `id`
     * const histInvWithIdOnly = await prisma.histInv.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends histInvUpdateManyAndReturnArgs>(args: SelectSubset<T, histInvUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistInv.
     * @param {histInvUpsertArgs} args - Arguments to update or create a HistInv.
     * @example
     * // Update or create a HistInv
     * const histInv = await prisma.histInv.upsert({
     *   create: {
     *     // ... data to create a HistInv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistInv we want to update
     *   }
     * })
     */
    upsert<T extends histInvUpsertArgs>(args: SelectSubset<T, histInvUpsertArgs<ExtArgs>>): Prisma__histInvClient<$Result.GetResult<Prisma.$histInvPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistInvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvCountArgs} args - Arguments to filter HistInvs to count.
     * @example
     * // Count the number of HistInvs
     * const count = await prisma.histInv.count({
     *   where: {
     *     // ... the filter for the HistInvs we want to count
     *   }
     * })
    **/
    count<T extends histInvCountArgs>(
      args?: Subset<T, histInvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistInvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistInv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistInvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistInvAggregateArgs>(args: Subset<T, HistInvAggregateArgs>): Prisma.PrismaPromise<GetHistInvAggregateType<T>>

    /**
     * Group by HistInv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {histInvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends histInvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: histInvGroupByArgs['orderBy'] }
        : { orderBy?: histInvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, histInvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistInvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the histInv model
   */
  readonly fields: histInvFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for histInv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__histInvClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    producto<T extends productosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productosDefaultArgs<ExtArgs>>): Prisma__productosClient<$Result.GetResult<Prisma.$productosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the histInv model
   */
  interface histInvFieldRefs {
    readonly id: FieldRef<"histInv", 'Int'>
    readonly productoId: FieldRef<"histInv", 'Int'>
    readonly usuarioId: FieldRef<"histInv", 'Int'>
    readonly accion: FieldRef<"histInv", 'AccionHistorial'>
    readonly cantidad_anterior: FieldRef<"histInv", 'Int'>
    readonly cantidad_nueva: FieldRef<"histInv", 'Int'>
    readonly precio_anterior: FieldRef<"histInv", 'Decimal'>
    readonly precio_nuevo: FieldRef<"histInv", 'Decimal'>
    readonly fechaCambio: FieldRef<"histInv", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * histInv findUnique
   */
  export type histInvFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv findUniqueOrThrow
   */
  export type histInvFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv findFirst
   */
  export type histInvFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histInvs.
     */
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv findFirstOrThrow
   */
  export type histInvFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInv to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histInvs.
     */
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv findMany
   */
  export type histInvFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter, which histInvs to fetch.
     */
    where?: histInvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histInvs to fetch.
     */
    orderBy?: histInvOrderByWithRelationInput | histInvOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing histInvs.
     */
    cursor?: histInvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histInvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histInvs.
     */
    skip?: number
    distinct?: HistInvScalarFieldEnum | HistInvScalarFieldEnum[]
  }

  /**
   * histInv create
   */
  export type histInvCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The data needed to create a histInv.
     */
    data: XOR<histInvCreateInput, histInvUncheckedCreateInput>
  }

  /**
   * histInv createMany
   */
  export type histInvCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many histInvs.
     */
    data: histInvCreateManyInput | histInvCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * histInv createManyAndReturn
   */
  export type histInvCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * The data used to create many histInvs.
     */
    data: histInvCreateManyInput | histInvCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * histInv update
   */
  export type histInvUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The data needed to update a histInv.
     */
    data: XOR<histInvUpdateInput, histInvUncheckedUpdateInput>
    /**
     * Choose, which histInv to update.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv updateMany
   */
  export type histInvUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update histInvs.
     */
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyInput>
    /**
     * Filter which histInvs to update
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to update.
     */
    limit?: number
  }

  /**
   * histInv updateManyAndReturn
   */
  export type histInvUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * The data used to update histInvs.
     */
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyInput>
    /**
     * Filter which histInvs to update
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * histInv upsert
   */
  export type histInvUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * The filter to search for the histInv to update in case it exists.
     */
    where: histInvWhereUniqueInput
    /**
     * In case the histInv found by the `where` argument doesn't exist, create a new histInv with this data.
     */
    create: XOR<histInvCreateInput, histInvUncheckedCreateInput>
    /**
     * In case the histInv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<histInvUpdateInput, histInvUncheckedUpdateInput>
  }

  /**
   * histInv delete
   */
  export type histInvDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
    /**
     * Filter which histInv to delete.
     */
    where: histInvWhereUniqueInput
  }

  /**
   * histInv deleteMany
   */
  export type histInvDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histInvs to delete
     */
    where?: histInvWhereInput
    /**
     * Limit how many histInvs to delete.
     */
    limit?: number
  }

  /**
   * histInv without action
   */
  export type histInvDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histInv
     */
    select?: histInvSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histInv
     */
    omit?: histInvOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: histInvInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    idUsuario: 'idUsuario',
    username: 'username',
    correo: 'correo',
    password: 'password',
    nombreCompleto: 'nombreCompleto',
    telefono: 'telefono',
    direccion: 'direccion',
    fotoPerfil: 'fotoPerfil',
    nombreEmpresa: 'nombreEmpresa',
    nit: 'nit',
    estado: 'estado',
    rol: 'rol',
    tipoUsuario: 'tipoUsuario',
    rolEquipo: 'rolEquipo',
    perfilCompleto: 'perfilCompleto',
    empresaId: 'empresaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    idSeguridad: 'idSeguridad',
    idUsuario: 'idUsuario',
    token: 'token',
    fechaSolicitud: 'fechaSolicitud',
    fechaExpiracion: 'fechaExpiracion',
    usado: 'usado'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const NotificacionesScalarFieldEnum: {
    idNotificacion: 'idNotificacion',
    idUsuario: 'idUsuario',
    tipo: 'tipo',
    titulo: 'titulo',
    mensaje: 'mensaje',
    fechaEnvio: 'fechaEnvio',
    leida: 'leida'
  };

  export type NotificacionesScalarFieldEnum = (typeof NotificacionesScalarFieldEnum)[keyof typeof NotificacionesScalarFieldEnum]


  export const PreferenciasNotificacionesScalarFieldEnum: {
    id: 'id',
    idUsuario: 'idUsuario',
    stockBajo: 'stockBajo',
    productoVencido: 'productoVencido',
    comentarios: 'comentarios',
    reposicion: 'reposicion',
    actualizacion: 'actualizacion'
  };

  export type PreferenciasNotificacionesScalarFieldEnum = (typeof PreferenciasNotificacionesScalarFieldEnum)[keyof typeof PreferenciasNotificacionesScalarFieldEnum]


  export const ProductosScalarFieldEnum: {
    id: 'id',
    codigoBarras: 'codigoBarras',
    codigoQR: 'codigoQR',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precio: 'precio',
    cantidad: 'cantidad',
    fechaAdquisicion: 'fechaAdquisicion',
    fechaVencimiento: 'fechaVencimiento',
    usuarioId: 'usuarioId',
    estado: 'estado',
    imagen: 'imagen',
    categoria: 'categoria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    eliminadoEn: 'eliminadoEn'
  };

  export type ProductosScalarFieldEnum = (typeof ProductosScalarFieldEnum)[keyof typeof ProductosScalarFieldEnum]


  export const RecorStockScalarFieldEnum: {
    idRecordatorio: 'idRecordatorio',
    productoId: 'productoId',
    cantidadMinima: 'cantidadMinima',
    fechaRecordatorio: 'fechaRecordatorio',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecorStockScalarFieldEnum = (typeof RecorStockScalarFieldEnum)[keyof typeof RecorStockScalarFieldEnum]


  export const ComentariosScalarFieldEnum: {
    idComentario: 'idComentario',
    idUsuario: 'idUsuario',
    idProducto: 'idProducto',
    comentario: 'comentario',
    fechaComentario: 'fechaComentario',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComentariosScalarFieldEnum = (typeof ComentariosScalarFieldEnum)[keyof typeof ComentariosScalarFieldEnum]


  export const NutriScanScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    esAlimento: 'esAlimento',
    consulta: 'consulta',
    respuesta: 'respuesta',
    tipoAnalisis: 'tipoAnalisis',
    fechaAnalisis: 'fechaAnalisis',
    actualizadoEn: 'actualizadoEn',
    isTest: 'isTest'
  };

  export type NutriScanScalarFieldEnum = (typeof NutriScanScalarFieldEnum)[keyof typeof NutriScanScalarFieldEnum]


  export const HistInvScalarFieldEnum: {
    id: 'id',
    productoId: 'productoId',
    usuarioId: 'usuarioId',
    accion: 'accion',
    cantidad_anterior: 'cantidad_anterior',
    cantidad_nueva: 'cantidad_nueva',
    precio_anterior: 'precio_anterior',
    precio_nuevo: 'precio_nuevo',
    fechaCambio: 'fechaCambio'
  };

  export type HistInvScalarFieldEnum = (typeof HistInvScalarFieldEnum)[keyof typeof HistInvScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TipoUsuario'
   */
  export type EnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario'>
    


  /**
   * Reference to a field of type 'TipoUsuario[]'
   */
  export type ListEnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario[]'>
    


  /**
   * Reference to a field of type 'rolEquipo'
   */
  export type EnumrolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rolEquipo'>
    


  /**
   * Reference to a field of type 'rolEquipo[]'
   */
  export type ListEnumrolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rolEquipo[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipoNotificacion'
   */
  export type EnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion'>
    


  /**
   * Reference to a field of type 'TipoNotificacion[]'
   */
  export type ListEnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EstadoProducto'
   */
  export type EnumEstadoProductoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoProducto'>
    


  /**
   * Reference to a field of type 'EstadoProducto[]'
   */
  export type ListEnumEstadoProductoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoProducto[]'>
    


  /**
   * Reference to a field of type 'EstadoRecordatorio'
   */
  export type EnumEstadoRecordatorioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoRecordatorio'>
    


  /**
   * Reference to a field of type 'EstadoRecordatorio[]'
   */
  export type ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoRecordatorio[]'>
    


  /**
   * Reference to a field of type 'EstadoComentario'
   */
  export type EnumEstadoComentarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoComentario'>
    


  /**
   * Reference to a field of type 'EstadoComentario[]'
   */
  export type ListEnumEstadoComentarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoComentario[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AccionHistorial'
   */
  export type EnumAccionHistorialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionHistorial'>
    


  /**
   * Reference to a field of type 'AccionHistorial[]'
   */
  export type ListEnumAccionHistorialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionHistorial[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    idUsuario?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    correo?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    nombreCompleto?: StringFilter<"users"> | string
    telefono?: StringFilter<"users"> | string
    direccion?: StringFilter<"users"> | string
    fotoPerfil?: StringNullableFilter<"users"> | string | null
    nombreEmpresa?: StringNullableFilter<"users"> | string | null
    nit?: StringNullableFilter<"users"> | string | null
    estado?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    tipoUsuario?: EnumTipoUsuarioNullableFilter<"users"> | $Enums.TipoUsuario | null
    rolEquipo?: EnumrolEquipoNullableFilter<"users"> | $Enums.rolEquipo | null
    perfilCompleto?: BoolFilter<"users"> | boolean
    empresaId?: IntNullableFilter<"users"> | number | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    jefe?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    miembros?: UsersListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    notificaciones?: NotificacionesListRelationFilter
    productos?: ProductosListRelationFilter
    comentarios?: ComentariosListRelationFilter
    nutriScans?: NutriScanListRelationFilter
    histInv?: HistInvListRelationFilter
    preferencias?: XOR<PreferenciasNotificacionesNullableScalarRelationFilter, preferenciasNotificacionesWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrderInput | SortOrder
    nombreEmpresa?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    estado?: SortOrder
    rol?: SortOrder
    tipoUsuario?: SortOrderInput | SortOrder
    rolEquipo?: SortOrderInput | SortOrder
    perfilCompleto?: SortOrder
    empresaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    jefe?: usersOrderByWithRelationInput
    miembros?: usersOrderByRelationAggregateInput
    passwordResets?: passwordResetOrderByRelationAggregateInput
    notificaciones?: notificacionesOrderByRelationAggregateInput
    productos?: productosOrderByRelationAggregateInput
    comentarios?: comentariosOrderByRelationAggregateInput
    nutriScans?: NutriScanOrderByRelationAggregateInput
    histInv?: histInvOrderByRelationAggregateInput
    preferencias?: preferenciasNotificacionesOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    idUsuario?: number
    username?: string
    correo?: string
    nit?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    nombreCompleto?: StringFilter<"users"> | string
    telefono?: StringFilter<"users"> | string
    direccion?: StringFilter<"users"> | string
    fotoPerfil?: StringNullableFilter<"users"> | string | null
    nombreEmpresa?: StringNullableFilter<"users"> | string | null
    estado?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    tipoUsuario?: EnumTipoUsuarioNullableFilter<"users"> | $Enums.TipoUsuario | null
    rolEquipo?: EnumrolEquipoNullableFilter<"users"> | $Enums.rolEquipo | null
    perfilCompleto?: BoolFilter<"users"> | boolean
    empresaId?: IntNullableFilter<"users"> | number | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
    jefe?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    miembros?: UsersListRelationFilter
    passwordResets?: PasswordResetListRelationFilter
    notificaciones?: NotificacionesListRelationFilter
    productos?: ProductosListRelationFilter
    comentarios?: ComentariosListRelationFilter
    nutriScans?: NutriScanListRelationFilter
    histInv?: HistInvListRelationFilter
    preferencias?: XOR<PreferenciasNotificacionesNullableScalarRelationFilter, preferenciasNotificacionesWhereInput> | null
  }, "idUsuario" | "username" | "correo" | "nit">

  export type usersOrderByWithAggregationInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrderInput | SortOrder
    nombreEmpresa?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    estado?: SortOrder
    rol?: SortOrder
    tipoUsuario?: SortOrderInput | SortOrder
    rolEquipo?: SortOrderInput | SortOrder
    perfilCompleto?: SortOrder
    empresaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    idUsuario?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    correo?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    nombreCompleto?: StringWithAggregatesFilter<"users"> | string
    telefono?: StringWithAggregatesFilter<"users"> | string
    direccion?: StringWithAggregatesFilter<"users"> | string
    fotoPerfil?: StringNullableWithAggregatesFilter<"users"> | string | null
    nombreEmpresa?: StringNullableWithAggregatesFilter<"users"> | string | null
    nit?: StringNullableWithAggregatesFilter<"users"> | string | null
    estado?: StringWithAggregatesFilter<"users"> | string
    rol?: StringWithAggregatesFilter<"users"> | string
    tipoUsuario?: EnumTipoUsuarioNullableWithAggregatesFilter<"users"> | $Enums.TipoUsuario | null
    rolEquipo?: EnumrolEquipoNullableWithAggregatesFilter<"users"> | $Enums.rolEquipo | null
    perfilCompleto?: BoolWithAggregatesFilter<"users"> | boolean
    empresaId?: IntNullableWithAggregatesFilter<"users"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type passwordResetWhereInput = {
    AND?: passwordResetWhereInput | passwordResetWhereInput[]
    OR?: passwordResetWhereInput[]
    NOT?: passwordResetWhereInput | passwordResetWhereInput[]
    idSeguridad?: IntFilter<"passwordReset"> | number
    idUsuario?: IntFilter<"passwordReset"> | number
    token?: StringFilter<"passwordReset"> | string
    fechaSolicitud?: DateTimeFilter<"passwordReset"> | Date | string
    fechaExpiracion?: DateTimeFilter<"passwordReset"> | Date | string
    usado?: BoolFilter<"passwordReset"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type passwordResetOrderByWithRelationInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type passwordResetWhereUniqueInput = Prisma.AtLeast<{
    idSeguridad?: number
    AND?: passwordResetWhereInput | passwordResetWhereInput[]
    OR?: passwordResetWhereInput[]
    NOT?: passwordResetWhereInput | passwordResetWhereInput[]
    idUsuario?: IntFilter<"passwordReset"> | number
    token?: StringFilter<"passwordReset"> | string
    fechaSolicitud?: DateTimeFilter<"passwordReset"> | Date | string
    fechaExpiracion?: DateTimeFilter<"passwordReset"> | Date | string
    usado?: BoolFilter<"passwordReset"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idSeguridad">

  export type passwordResetOrderByWithAggregationInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
    _count?: passwordResetCountOrderByAggregateInput
    _avg?: passwordResetAvgOrderByAggregateInput
    _max?: passwordResetMaxOrderByAggregateInput
    _min?: passwordResetMinOrderByAggregateInput
    _sum?: passwordResetSumOrderByAggregateInput
  }

  export type passwordResetScalarWhereWithAggregatesInput = {
    AND?: passwordResetScalarWhereWithAggregatesInput | passwordResetScalarWhereWithAggregatesInput[]
    OR?: passwordResetScalarWhereWithAggregatesInput[]
    NOT?: passwordResetScalarWhereWithAggregatesInput | passwordResetScalarWhereWithAggregatesInput[]
    idSeguridad?: IntWithAggregatesFilter<"passwordReset"> | number
    idUsuario?: IntWithAggregatesFilter<"passwordReset"> | number
    token?: StringWithAggregatesFilter<"passwordReset"> | string
    fechaSolicitud?: DateTimeWithAggregatesFilter<"passwordReset"> | Date | string
    fechaExpiracion?: DateTimeWithAggregatesFilter<"passwordReset"> | Date | string
    usado?: BoolWithAggregatesFilter<"passwordReset"> | boolean
  }

  export type notificacionesWhereInput = {
    AND?: notificacionesWhereInput | notificacionesWhereInput[]
    OR?: notificacionesWhereInput[]
    NOT?: notificacionesWhereInput | notificacionesWhereInput[]
    idNotificacion?: IntFilter<"notificaciones"> | number
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificacionesOrderByWithRelationInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type notificacionesWhereUniqueInput = Prisma.AtLeast<{
    idNotificacion?: number
    AND?: notificacionesWhereInput | notificacionesWhereInput[]
    OR?: notificacionesWhereInput[]
    NOT?: notificacionesWhereInput | notificacionesWhereInput[]
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "idNotificacion">

  export type notificacionesOrderByWithAggregationInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
    _count?: notificacionesCountOrderByAggregateInput
    _avg?: notificacionesAvgOrderByAggregateInput
    _max?: notificacionesMaxOrderByAggregateInput
    _min?: notificacionesMinOrderByAggregateInput
    _sum?: notificacionesSumOrderByAggregateInput
  }

  export type notificacionesScalarWhereWithAggregatesInput = {
    AND?: notificacionesScalarWhereWithAggregatesInput | notificacionesScalarWhereWithAggregatesInput[]
    OR?: notificacionesScalarWhereWithAggregatesInput[]
    NOT?: notificacionesScalarWhereWithAggregatesInput | notificacionesScalarWhereWithAggregatesInput[]
    idNotificacion?: IntWithAggregatesFilter<"notificaciones"> | number
    idUsuario?: IntWithAggregatesFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionWithAggregatesFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringWithAggregatesFilter<"notificaciones"> | string
    mensaje?: StringWithAggregatesFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeWithAggregatesFilter<"notificaciones"> | Date | string
    leida?: BoolWithAggregatesFilter<"notificaciones"> | boolean
  }

  export type preferenciasNotificacionesWhereInput = {
    AND?: preferenciasNotificacionesWhereInput | preferenciasNotificacionesWhereInput[]
    OR?: preferenciasNotificacionesWhereInput[]
    NOT?: preferenciasNotificacionesWhereInput | preferenciasNotificacionesWhereInput[]
    id?: IntFilter<"preferenciasNotificaciones"> | number
    idUsuario?: IntFilter<"preferenciasNotificaciones"> | number
    stockBajo?: BoolFilter<"preferenciasNotificaciones"> | boolean
    productoVencido?: BoolFilter<"preferenciasNotificaciones"> | boolean
    comentarios?: BoolFilter<"preferenciasNotificaciones"> | boolean
    reposicion?: BoolFilter<"preferenciasNotificaciones"> | boolean
    actualizacion?: BoolFilter<"preferenciasNotificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type preferenciasNotificacionesOrderByWithRelationInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    stockBajo?: SortOrder
    productoVencido?: SortOrder
    comentarios?: SortOrder
    reposicion?: SortOrder
    actualizacion?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type preferenciasNotificacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    idUsuario?: number
    AND?: preferenciasNotificacionesWhereInput | preferenciasNotificacionesWhereInput[]
    OR?: preferenciasNotificacionesWhereInput[]
    NOT?: preferenciasNotificacionesWhereInput | preferenciasNotificacionesWhereInput[]
    stockBajo?: BoolFilter<"preferenciasNotificaciones"> | boolean
    productoVencido?: BoolFilter<"preferenciasNotificaciones"> | boolean
    comentarios?: BoolFilter<"preferenciasNotificaciones"> | boolean
    reposicion?: BoolFilter<"preferenciasNotificaciones"> | boolean
    actualizacion?: BoolFilter<"preferenciasNotificaciones"> | boolean
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "idUsuario">

  export type preferenciasNotificacionesOrderByWithAggregationInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    stockBajo?: SortOrder
    productoVencido?: SortOrder
    comentarios?: SortOrder
    reposicion?: SortOrder
    actualizacion?: SortOrder
    _count?: preferenciasNotificacionesCountOrderByAggregateInput
    _avg?: preferenciasNotificacionesAvgOrderByAggregateInput
    _max?: preferenciasNotificacionesMaxOrderByAggregateInput
    _min?: preferenciasNotificacionesMinOrderByAggregateInput
    _sum?: preferenciasNotificacionesSumOrderByAggregateInput
  }

  export type preferenciasNotificacionesScalarWhereWithAggregatesInput = {
    AND?: preferenciasNotificacionesScalarWhereWithAggregatesInput | preferenciasNotificacionesScalarWhereWithAggregatesInput[]
    OR?: preferenciasNotificacionesScalarWhereWithAggregatesInput[]
    NOT?: preferenciasNotificacionesScalarWhereWithAggregatesInput | preferenciasNotificacionesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"preferenciasNotificaciones"> | number
    idUsuario?: IntWithAggregatesFilter<"preferenciasNotificaciones"> | number
    stockBajo?: BoolWithAggregatesFilter<"preferenciasNotificaciones"> | boolean
    productoVencido?: BoolWithAggregatesFilter<"preferenciasNotificaciones"> | boolean
    comentarios?: BoolWithAggregatesFilter<"preferenciasNotificaciones"> | boolean
    reposicion?: BoolWithAggregatesFilter<"preferenciasNotificaciones"> | boolean
    actualizacion?: BoolWithAggregatesFilter<"preferenciasNotificaciones"> | boolean
  }

  export type productosWhereInput = {
    AND?: productosWhereInput | productosWhereInput[]
    OR?: productosWhereInput[]
    NOT?: productosWhereInput | productosWhereInput[]
    id?: IntFilter<"productos"> | number
    codigoBarras?: StringNullableFilter<"productos"> | string | null
    codigoQR?: StringNullableFilter<"productos"> | string | null
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"productos"> | number
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: EnumEstadoProductoFilter<"productos"> | $Enums.EstadoProducto
    imagen?: StringFilter<"productos"> | string
    categoria?: StringNullableFilter<"productos"> | string | null
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
    histInv?: HistInvListRelationFilter
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
    recorStock?: RecorStockListRelationFilter
    comentarios?: ComentariosListRelationFilter
  }

  export type productosOrderByWithRelationInput = {
    id?: SortOrder
    codigoBarras?: SortOrderInput | SortOrder
    codigoQR?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    categoria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrderInput | SortOrder
    histInv?: histInvOrderByRelationAggregateInput
    usuario?: usersOrderByWithRelationInput
    recorStock?: recorStockOrderByRelationAggregateInput
    comentarios?: comentariosOrderByRelationAggregateInput
  }

  export type productosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoBarras?: string
    codigoQR?: string
    AND?: productosWhereInput | productosWhereInput[]
    OR?: productosWhereInput[]
    NOT?: productosWhereInput | productosWhereInput[]
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"productos"> | number
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: EnumEstadoProductoFilter<"productos"> | $Enums.EstadoProducto
    imagen?: StringFilter<"productos"> | string
    categoria?: StringNullableFilter<"productos"> | string | null
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
    histInv?: HistInvListRelationFilter
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
    recorStock?: RecorStockListRelationFilter
    comentarios?: ComentariosListRelationFilter
  }, "id" | "codigoBarras" | "codigoQR">

  export type productosOrderByWithAggregationInput = {
    id?: SortOrder
    codigoBarras?: SortOrderInput | SortOrder
    codigoQR?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    categoria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrderInput | SortOrder
    _count?: productosCountOrderByAggregateInput
    _avg?: productosAvgOrderByAggregateInput
    _max?: productosMaxOrderByAggregateInput
    _min?: productosMinOrderByAggregateInput
    _sum?: productosSumOrderByAggregateInput
  }

  export type productosScalarWhereWithAggregatesInput = {
    AND?: productosScalarWhereWithAggregatesInput | productosScalarWhereWithAggregatesInput[]
    OR?: productosScalarWhereWithAggregatesInput[]
    NOT?: productosScalarWhereWithAggregatesInput | productosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"productos"> | number
    codigoBarras?: StringNullableWithAggregatesFilter<"productos"> | string | null
    codigoQR?: StringNullableWithAggregatesFilter<"productos"> | string | null
    nombre?: StringWithAggregatesFilter<"productos"> | string
    descripcion?: StringWithAggregatesFilter<"productos"> | string
    precio?: DecimalWithAggregatesFilter<"productos"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntWithAggregatesFilter<"productos"> | number
    fechaAdquisicion?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    usuarioId?: IntWithAggregatesFilter<"productos"> | number
    estado?: EnumEstadoProductoWithAggregatesFilter<"productos"> | $Enums.EstadoProducto
    imagen?: StringWithAggregatesFilter<"productos"> | string
    categoria?: StringNullableWithAggregatesFilter<"productos"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableWithAggregatesFilter<"productos"> | Date | string | null
  }

  export type recorStockWhereInput = {
    AND?: recorStockWhereInput | recorStockWhereInput[]
    OR?: recorStockWhereInput[]
    NOT?: recorStockWhereInput | recorStockWhereInput[]
    idRecordatorio?: IntFilter<"recorStock"> | number
    productoId?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type recorStockOrderByWithRelationInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    producto?: productosOrderByWithRelationInput
  }

  export type recorStockWhereUniqueInput = Prisma.AtLeast<{
    idRecordatorio?: number
    AND?: recorStockWhereInput | recorStockWhereInput[]
    OR?: recorStockWhereInput[]
    NOT?: recorStockWhereInput | recorStockWhereInput[]
    productoId?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "idRecordatorio">

  export type recorStockOrderByWithAggregationInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: recorStockCountOrderByAggregateInput
    _avg?: recorStockAvgOrderByAggregateInput
    _max?: recorStockMaxOrderByAggregateInput
    _min?: recorStockMinOrderByAggregateInput
    _sum?: recorStockSumOrderByAggregateInput
  }

  export type recorStockScalarWhereWithAggregatesInput = {
    AND?: recorStockScalarWhereWithAggregatesInput | recorStockScalarWhereWithAggregatesInput[]
    OR?: recorStockScalarWhereWithAggregatesInput[]
    NOT?: recorStockScalarWhereWithAggregatesInput | recorStockScalarWhereWithAggregatesInput[]
    idRecordatorio?: IntWithAggregatesFilter<"recorStock"> | number
    productoId?: IntWithAggregatesFilter<"recorStock"> | number
    cantidadMinima?: IntWithAggregatesFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioWithAggregatesFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"recorStock"> | Date | string
  }

  export type comentariosWhereInput = {
    AND?: comentariosWhereInput | comentariosWhereInput[]
    OR?: comentariosWhereInput[]
    NOT?: comentariosWhereInput | comentariosWhereInput[]
    idComentario?: IntFilter<"comentarios"> | number
    idUsuario?: IntFilter<"comentarios"> | number
    idProducto?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }

  export type comentariosOrderByWithRelationInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    producto?: productosOrderByWithRelationInput
  }

  export type comentariosWhereUniqueInput = Prisma.AtLeast<{
    idComentario?: number
    AND?: comentariosWhereInput | comentariosWhereInput[]
    OR?: comentariosWhereInput[]
    NOT?: comentariosWhereInput | comentariosWhereInput[]
    idUsuario?: IntFilter<"comentarios"> | number
    idProducto?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
  }, "idComentario">

  export type comentariosOrderByWithAggregationInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: comentariosCountOrderByAggregateInput
    _avg?: comentariosAvgOrderByAggregateInput
    _max?: comentariosMaxOrderByAggregateInput
    _min?: comentariosMinOrderByAggregateInput
    _sum?: comentariosSumOrderByAggregateInput
  }

  export type comentariosScalarWhereWithAggregatesInput = {
    AND?: comentariosScalarWhereWithAggregatesInput | comentariosScalarWhereWithAggregatesInput[]
    OR?: comentariosScalarWhereWithAggregatesInput[]
    NOT?: comentariosScalarWhereWithAggregatesInput | comentariosScalarWhereWithAggregatesInput[]
    idComentario?: IntWithAggregatesFilter<"comentarios"> | number
    idUsuario?: IntWithAggregatesFilter<"comentarios"> | number
    idProducto?: IntWithAggregatesFilter<"comentarios"> | number
    comentario?: StringWithAggregatesFilter<"comentarios"> | string
    fechaComentario?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioWithAggregatesFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"comentarios"> | Date | string
  }

  export type NutriScanWhereInput = {
    AND?: NutriScanWhereInput | NutriScanWhereInput[]
    OR?: NutriScanWhereInput[]
    NOT?: NutriScanWhereInput | NutriScanWhereInput[]
    id?: IntFilter<"NutriScan"> | number
    usuarioId?: IntFilter<"NutriScan"> | number
    esAlimento?: BoolFilter<"NutriScan"> | boolean
    consulta?: StringFilter<"NutriScan"> | string
    respuesta?: JsonFilter<"NutriScan">
    tipoAnalisis?: StringFilter<"NutriScan"> | string
    fechaAnalisis?: DateTimeFilter<"NutriScan"> | Date | string
    actualizadoEn?: DateTimeFilter<"NutriScan"> | Date | string
    isTest?: BoolFilter<"NutriScan"> | boolean
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type NutriScanOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    tipoAnalisis?: SortOrder
    fechaAnalisis?: SortOrder
    actualizadoEn?: SortOrder
    isTest?: SortOrder
    usuario?: usersOrderByWithRelationInput
  }

  export type NutriScanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NutriScanWhereInput | NutriScanWhereInput[]
    OR?: NutriScanWhereInput[]
    NOT?: NutriScanWhereInput | NutriScanWhereInput[]
    usuarioId?: IntFilter<"NutriScan"> | number
    esAlimento?: BoolFilter<"NutriScan"> | boolean
    consulta?: StringFilter<"NutriScan"> | string
    respuesta?: JsonFilter<"NutriScan">
    tipoAnalisis?: StringFilter<"NutriScan"> | string
    fechaAnalisis?: DateTimeFilter<"NutriScan"> | Date | string
    actualizadoEn?: DateTimeFilter<"NutriScan"> | Date | string
    isTest?: BoolFilter<"NutriScan"> | boolean
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type NutriScanOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    tipoAnalisis?: SortOrder
    fechaAnalisis?: SortOrder
    actualizadoEn?: SortOrder
    isTest?: SortOrder
    _count?: NutriScanCountOrderByAggregateInput
    _avg?: NutriScanAvgOrderByAggregateInput
    _max?: NutriScanMaxOrderByAggregateInput
    _min?: NutriScanMinOrderByAggregateInput
    _sum?: NutriScanSumOrderByAggregateInput
  }

  export type NutriScanScalarWhereWithAggregatesInput = {
    AND?: NutriScanScalarWhereWithAggregatesInput | NutriScanScalarWhereWithAggregatesInput[]
    OR?: NutriScanScalarWhereWithAggregatesInput[]
    NOT?: NutriScanScalarWhereWithAggregatesInput | NutriScanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NutriScan"> | number
    usuarioId?: IntWithAggregatesFilter<"NutriScan"> | number
    esAlimento?: BoolWithAggregatesFilter<"NutriScan"> | boolean
    consulta?: StringWithAggregatesFilter<"NutriScan"> | string
    respuesta?: JsonWithAggregatesFilter<"NutriScan">
    tipoAnalisis?: StringWithAggregatesFilter<"NutriScan"> | string
    fechaAnalisis?: DateTimeWithAggregatesFilter<"NutriScan"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"NutriScan"> | Date | string
    isTest?: BoolWithAggregatesFilter<"NutriScan"> | boolean
  }

  export type histInvWhereInput = {
    AND?: histInvWhereInput | histInvWhereInput[]
    OR?: histInvWhereInput[]
    NOT?: histInvWhereInput | histInvWhereInput[]
    id?: IntFilter<"histInv"> | number
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type histInvOrderByWithRelationInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
    producto?: productosOrderByWithRelationInput
    usuario?: usersOrderByWithRelationInput
  }

  export type histInvWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: histInvWhereInput | histInvWhereInput[]
    OR?: histInvWhereInput[]
    NOT?: histInvWhereInput | histInvWhereInput[]
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
    producto?: XOR<ProductosScalarRelationFilter, productosWhereInput>
    usuario?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type histInvOrderByWithAggregationInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
    _count?: histInvCountOrderByAggregateInput
    _avg?: histInvAvgOrderByAggregateInput
    _max?: histInvMaxOrderByAggregateInput
    _min?: histInvMinOrderByAggregateInput
    _sum?: histInvSumOrderByAggregateInput
  }

  export type histInvScalarWhereWithAggregatesInput = {
    AND?: histInvScalarWhereWithAggregatesInput | histInvScalarWhereWithAggregatesInput[]
    OR?: histInvScalarWhereWithAggregatesInput[]
    NOT?: histInvScalarWhereWithAggregatesInput | histInvScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"histInv"> | number
    productoId?: IntWithAggregatesFilter<"histInv"> | number
    usuarioId?: IntWithAggregatesFilter<"histInv"> | number
    accion?: EnumAccionHistorialWithAggregatesFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntWithAggregatesFilter<"histInv"> | number
    cantidad_nueva?: IntWithAggregatesFilter<"histInv"> | number
    precio_anterior?: DecimalWithAggregatesFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalWithAggregatesFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeWithAggregatesFilter<"histInv"> | Date | string
  }

  export type usersCreateInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passwordResetCreateInput = {
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
    user: usersCreateNestedOneWithoutPasswordResetsInput
  }

  export type passwordResetUncheckedCreateInput = {
    idSeguridad?: number
    idUsuario: number
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
  }

  export type passwordResetUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type passwordResetUncheckedUpdateInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type passwordResetCreateManyInput = {
    idSeguridad?: number
    idUsuario: number
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
  }

  export type passwordResetUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type passwordResetUncheckedUpdateManyInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesCreateInput = {
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
    user: usersCreateNestedOneWithoutNotificacionesInput
  }

  export type notificacionesUncheckedCreateInput = {
    idNotificacion?: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
  }

  export type notificacionesUpdateInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type notificacionesUncheckedUpdateInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesCreateManyInput = {
    idNotificacion?: number
    idUsuario: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
  }

  export type notificacionesUpdateManyMutationInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateManyInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type preferenciasNotificacionesCreateInput = {
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
    user: usersCreateNestedOneWithoutPreferenciasInput
  }

  export type preferenciasNotificacionesUncheckedCreateInput = {
    id?: number
    idUsuario: number
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
  }

  export type preferenciasNotificacionesUpdateInput = {
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
    user?: usersUpdateOneRequiredWithoutPreferenciasNestedInput
  }

  export type preferenciasNotificacionesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type preferenciasNotificacionesCreateManyInput = {
    id?: number
    idUsuario: number
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
  }

  export type preferenciasNotificacionesUpdateManyMutationInput = {
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type preferenciasNotificacionesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productosCreateInput = {
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
    comentarios?: comentariosCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosUpdateInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosCreateManyInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
  }

  export type productosUpdateManyMutationInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recorStockCreateInput = {
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutRecorStockInput
  }

  export type recorStockUncheckedCreateInput = {
    idRecordatorio?: number
    productoId: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUpdateInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutRecorStockNestedInput
  }

  export type recorStockUncheckedUpdateInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockCreateManyInput = {
    idRecordatorio?: number
    productoId: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUpdateManyMutationInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateManyInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosCreateInput = {
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutComentariosInput
    producto: productosCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateInput = {
    idComentario?: number
    idUsuario: number
    idProducto: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutComentariosNestedInput
    producto?: productosUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosCreateManyInput = {
    idComentario?: number
    idUsuario: number
    idProducto: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutriScanCreateInput = {
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
    usuario: usersCreateNestedOneWithoutNutriScansInput
  }

  export type NutriScanUncheckedCreateInput = {
    id?: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
  }

  export type NutriScanUpdateInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
    usuario?: usersUpdateOneRequiredWithoutNutriScansNestedInput
  }

  export type NutriScanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NutriScanCreateManyInput = {
    id?: number
    usuarioId: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
  }

  export type NutriScanUpdateManyMutationInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NutriScanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type histInvCreateInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    producto: productosCreateNestedOneWithoutHistInvInput
    usuario: usersCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateInput = {
    id?: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvUpdateInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutHistInvNestedInput
    usuario?: usersUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvCreateManyInput = {
    id?: number
    productoId: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvUpdateManyMutationInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTipoUsuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel> | $Enums.TipoUsuario | null
  }

  export type EnumrolEquipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableFilter<$PrismaModel> | $Enums.rolEquipo | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type PasswordResetListRelationFilter = {
    every?: passwordResetWhereInput
    some?: passwordResetWhereInput
    none?: passwordResetWhereInput
  }

  export type NotificacionesListRelationFilter = {
    every?: notificacionesWhereInput
    some?: notificacionesWhereInput
    none?: notificacionesWhereInput
  }

  export type ProductosListRelationFilter = {
    every?: productosWhereInput
    some?: productosWhereInput
    none?: productosWhereInput
  }

  export type ComentariosListRelationFilter = {
    every?: comentariosWhereInput
    some?: comentariosWhereInput
    none?: comentariosWhereInput
  }

  export type NutriScanListRelationFilter = {
    every?: NutriScanWhereInput
    some?: NutriScanWhereInput
    none?: NutriScanWhereInput
  }

  export type HistInvListRelationFilter = {
    every?: histInvWhereInput
    some?: histInvWhereInput
    none?: histInvWhereInput
  }

  export type PreferenciasNotificacionesNullableScalarRelationFilter = {
    is?: preferenciasNotificacionesWhereInput | null
    isNot?: preferenciasNotificacionesWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type passwordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comentariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutriScanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type histInvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    tipoUsuario?: SortOrder
    rolEquipo?: SortOrder
    perfilCompleto?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    idUsuario?: SortOrder
    empresaId?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    tipoUsuario?: SortOrder
    rolEquipo?: SortOrder
    perfilCompleto?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    idUsuario?: SortOrder
    username?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    nombreCompleto?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfil?: SortOrder
    nombreEmpresa?: SortOrder
    nit?: SortOrder
    estado?: SortOrder
    rol?: SortOrder
    tipoUsuario?: SortOrder
    rolEquipo?: SortOrder
    perfilCompleto?: SortOrder
    empresaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    idUsuario?: SortOrder
    empresaId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTipoUsuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoUsuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel>
  }

  export type EnumrolEquipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.rolEquipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
    _max?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type passwordResetCountOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
  }

  export type passwordResetAvgOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
  }

  export type passwordResetMaxOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
  }

  export type passwordResetMinOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
    token?: SortOrder
    fechaSolicitud?: SortOrder
    fechaExpiracion?: SortOrder
    usado?: SortOrder
  }

  export type passwordResetSumOrderByAggregateInput = {
    idSeguridad?: SortOrder
    idUsuario?: SortOrder
  }

  export type EnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type notificacionesCountOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesAvgOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
  }

  export type notificacionesMaxOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesMinOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    fechaEnvio?: SortOrder
    leida?: SortOrder
  }

  export type notificacionesSumOrderByAggregateInput = {
    idNotificacion?: SortOrder
    idUsuario?: SortOrder
  }

  export type EnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type preferenciasNotificacionesCountOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    stockBajo?: SortOrder
    productoVencido?: SortOrder
    comentarios?: SortOrder
    reposicion?: SortOrder
    actualizacion?: SortOrder
  }

  export type preferenciasNotificacionesAvgOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
  }

  export type preferenciasNotificacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    stockBajo?: SortOrder
    productoVencido?: SortOrder
    comentarios?: SortOrder
    reposicion?: SortOrder
    actualizacion?: SortOrder
  }

  export type preferenciasNotificacionesMinOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
    stockBajo?: SortOrder
    productoVencido?: SortOrder
    comentarios?: SortOrder
    reposicion?: SortOrder
    actualizacion?: SortOrder
  }

  export type preferenciasNotificacionesSumOrderByAggregateInput = {
    id?: SortOrder
    idUsuario?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoProductoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProducto | EnumEstadoProductoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProductoFilter<$PrismaModel> | $Enums.EstadoProducto
  }

  export type RecorStockListRelationFilter = {
    every?: recorStockWhereInput
    some?: recorStockWhereInput
    none?: recorStockWhereInput
  }

  export type recorStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productosCountOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    usuarioId?: SortOrder
  }

  export type productosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosMinOrderByAggregateInput = {
    id?: SortOrder
    codigoBarras?: SortOrder
    codigoQR?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    fechaAdquisicion?: SortOrder
    fechaVencimiento?: SortOrder
    usuarioId?: SortOrder
    estado?: SortOrder
    imagen?: SortOrder
    categoria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eliminadoEn?: SortOrder
  }

  export type productosSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    usuarioId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumEstadoProductoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProducto | EnumEstadoProductoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProductoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoProducto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoProductoFilter<$PrismaModel>
    _max?: NestedEnumEstadoProductoFilter<$PrismaModel>
  }

  export type EnumEstadoRecordatorioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioFilter<$PrismaModel> | $Enums.EstadoRecordatorio
  }

  export type ProductosScalarRelationFilter = {
    is?: productosWhereInput
    isNot?: productosWhereInput
  }

  export type recorStockCountOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockAvgOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
  }

  export type recorStockMaxOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockMinOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
    fechaRecordatorio?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type recorStockSumOrderByAggregateInput = {
    idRecordatorio?: SortOrder
    productoId?: SortOrder
    cantidadMinima?: SortOrder
  }

  export type EnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoRecordatorio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
    _max?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
  }

  export type EnumEstadoComentarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioFilter<$PrismaModel> | $Enums.EstadoComentario
  }

  export type comentariosCountOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosAvgOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
  }

  export type comentariosMaxOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosMinOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
    comentario?: SortOrder
    fechaComentario?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type comentariosSumOrderByAggregateInput = {
    idComentario?: SortOrder
    idUsuario?: SortOrder
    idProducto?: SortOrder
  }

  export type EnumEstadoComentarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoComentario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoComentarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoComentarioFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NutriScanCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    respuesta?: SortOrder
    tipoAnalisis?: SortOrder
    fechaAnalisis?: SortOrder
    actualizadoEn?: SortOrder
    isTest?: SortOrder
  }

  export type NutriScanAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type NutriScanMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    tipoAnalisis?: SortOrder
    fechaAnalisis?: SortOrder
    actualizadoEn?: SortOrder
    isTest?: SortOrder
  }

  export type NutriScanMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    esAlimento?: SortOrder
    consulta?: SortOrder
    tipoAnalisis?: SortOrder
    fechaAnalisis?: SortOrder
    actualizadoEn?: SortOrder
    isTest?: SortOrder
  }

  export type NutriScanSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAccionHistorialFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialFilter<$PrismaModel> | $Enums.AccionHistorial
  }

  export type histInvCountOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvAvgOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
  }

  export type histInvMaxOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvMinOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
    fechaCambio?: SortOrder
  }

  export type histInvSumOrderByAggregateInput = {
    id?: SortOrder
    productoId?: SortOrder
    usuarioId?: SortOrder
    cantidad_anterior?: SortOrder
    cantidad_nueva?: SortOrder
    precio_anterior?: SortOrder
    precio_nuevo?: SortOrder
  }

  export type EnumAccionHistorialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel> | $Enums.AccionHistorial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionHistorialFilter<$PrismaModel>
    _max?: NestedEnumAccionHistorialFilter<$PrismaModel>
  }

  export type usersCreateNestedOneWithoutMiembrosInput = {
    create?: XOR<usersCreateWithoutMiembrosInput, usersUncheckedCreateWithoutMiembrosInput>
    connectOrCreate?: usersCreateOrConnectWithoutMiembrosInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutJefeInput = {
    create?: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput> | usersCreateWithoutJefeInput[] | usersUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutJefeInput | usersCreateOrConnectWithoutJefeInput[]
    createMany?: usersCreateManyJefeInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type passwordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput> | passwordResetCreateWithoutUserInput[] | passwordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passwordResetCreateOrConnectWithoutUserInput | passwordResetCreateOrConnectWithoutUserInput[]
    createMany?: passwordResetCreateManyUserInputEnvelope
    connect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
  }

  export type notificacionesCreateNestedManyWithoutUserInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
  }

  export type productosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
  }

  export type comentariosCreateNestedManyWithoutUserInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type NutriScanCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput> | NutriScanCreateWithoutUsuarioInput[] | NutriScanUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NutriScanCreateOrConnectWithoutUsuarioInput | NutriScanCreateOrConnectWithoutUsuarioInput[]
    createMany?: NutriScanCreateManyUsuarioInputEnvelope
    connect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
  }

  export type histInvCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type preferenciasNotificacionesCreateNestedOneWithoutUserInput = {
    create?: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
    connectOrCreate?: preferenciasNotificacionesCreateOrConnectWithoutUserInput
    connect?: preferenciasNotificacionesWhereUniqueInput
  }

  export type usersUncheckedCreateNestedManyWithoutJefeInput = {
    create?: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput> | usersCreateWithoutJefeInput[] | usersUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutJefeInput | usersCreateOrConnectWithoutJefeInput[]
    createMany?: usersCreateManyJefeInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type passwordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput> | passwordResetCreateWithoutUserInput[] | passwordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passwordResetCreateOrConnectWithoutUserInput | passwordResetCreateOrConnectWithoutUserInput[]
    createMany?: passwordResetCreateManyUserInputEnvelope
    connect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
  }

  export type notificacionesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
  }

  export type productosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
  }

  export type comentariosUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type NutriScanUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput> | NutriScanCreateWithoutUsuarioInput[] | NutriScanUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NutriScanCreateOrConnectWithoutUsuarioInput | NutriScanCreateOrConnectWithoutUsuarioInput[]
    createMany?: NutriScanCreateManyUsuarioInputEnvelope
    connect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
  }

  export type histInvUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
    connectOrCreate?: preferenciasNotificacionesCreateOrConnectWithoutUserInput
    connect?: preferenciasNotificacionesWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumTipoUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.TipoUsuario | null
  }

  export type NullableEnumrolEquipoFieldUpdateOperationsInput = {
    set?: $Enums.rolEquipo | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneWithoutMiembrosNestedInput = {
    create?: XOR<usersCreateWithoutMiembrosInput, usersUncheckedCreateWithoutMiembrosInput>
    connectOrCreate?: usersCreateOrConnectWithoutMiembrosInput
    upsert?: usersUpsertWithoutMiembrosInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMiembrosInput, usersUpdateWithoutMiembrosInput>, usersUncheckedUpdateWithoutMiembrosInput>
  }

  export type usersUpdateManyWithoutJefeNestedInput = {
    create?: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput> | usersCreateWithoutJefeInput[] | usersUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutJefeInput | usersCreateOrConnectWithoutJefeInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutJefeInput | usersUpsertWithWhereUniqueWithoutJefeInput[]
    createMany?: usersCreateManyJefeInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutJefeInput | usersUpdateWithWhereUniqueWithoutJefeInput[]
    updateMany?: usersUpdateManyWithWhereWithoutJefeInput | usersUpdateManyWithWhereWithoutJefeInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type passwordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput> | passwordResetCreateWithoutUserInput[] | passwordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passwordResetCreateOrConnectWithoutUserInput | passwordResetCreateOrConnectWithoutUserInput[]
    upsert?: passwordResetUpsertWithWhereUniqueWithoutUserInput | passwordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: passwordResetCreateManyUserInputEnvelope
    set?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    disconnect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    delete?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    connect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    update?: passwordResetUpdateWithWhereUniqueWithoutUserInput | passwordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: passwordResetUpdateManyWithWhereWithoutUserInput | passwordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: passwordResetScalarWhereInput | passwordResetScalarWhereInput[]
  }

  export type notificacionesUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    upsert?: notificacionesUpsertWithWhereUniqueWithoutUserInput | notificacionesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    set?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    disconnect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    delete?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    update?: notificacionesUpdateWithWhereUniqueWithoutUserInput | notificacionesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificacionesUpdateManyWithWhereWithoutUserInput | notificacionesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
  }

  export type productosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    upsert?: productosUpsertWithWhereUniqueWithoutUsuarioInput | productosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    set?: productosWhereUniqueInput | productosWhereUniqueInput[]
    disconnect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    delete?: productosWhereUniqueInput | productosWhereUniqueInput[]
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    update?: productosUpdateWithWhereUniqueWithoutUsuarioInput | productosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: productosUpdateManyWithWhereWithoutUsuarioInput | productosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: productosScalarWhereInput | productosScalarWhereInput[]
  }

  export type comentariosUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutUserInput | comentariosUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutUserInput | comentariosUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutUserInput | comentariosUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type NutriScanUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput> | NutriScanCreateWithoutUsuarioInput[] | NutriScanUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NutriScanCreateOrConnectWithoutUsuarioInput | NutriScanCreateOrConnectWithoutUsuarioInput[]
    upsert?: NutriScanUpsertWithWhereUniqueWithoutUsuarioInput | NutriScanUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NutriScanCreateManyUsuarioInputEnvelope
    set?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    disconnect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    delete?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    connect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    update?: NutriScanUpdateWithWhereUniqueWithoutUsuarioInput | NutriScanUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NutriScanUpdateManyWithWhereWithoutUsuarioInput | NutriScanUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NutriScanScalarWhereInput | NutriScanScalarWhereInput[]
  }

  export type histInvUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutUsuarioInput | histInvUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutUsuarioInput | histInvUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutUsuarioInput | histInvUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type preferenciasNotificacionesUpdateOneWithoutUserNestedInput = {
    create?: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
    connectOrCreate?: preferenciasNotificacionesCreateOrConnectWithoutUserInput
    upsert?: preferenciasNotificacionesUpsertWithoutUserInput
    disconnect?: preferenciasNotificacionesWhereInput | boolean
    delete?: preferenciasNotificacionesWhereInput | boolean
    connect?: preferenciasNotificacionesWhereUniqueInput
    update?: XOR<XOR<preferenciasNotificacionesUpdateToOneWithWhereWithoutUserInput, preferenciasNotificacionesUpdateWithoutUserInput>, preferenciasNotificacionesUncheckedUpdateWithoutUserInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUncheckedUpdateManyWithoutJefeNestedInput = {
    create?: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput> | usersCreateWithoutJefeInput[] | usersUncheckedCreateWithoutJefeInput[]
    connectOrCreate?: usersCreateOrConnectWithoutJefeInput | usersCreateOrConnectWithoutJefeInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutJefeInput | usersUpsertWithWhereUniqueWithoutJefeInput[]
    createMany?: usersCreateManyJefeInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutJefeInput | usersUpdateWithWhereUniqueWithoutJefeInput[]
    updateMany?: usersUpdateManyWithWhereWithoutJefeInput | usersUpdateManyWithWhereWithoutJefeInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type passwordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput> | passwordResetCreateWithoutUserInput[] | passwordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: passwordResetCreateOrConnectWithoutUserInput | passwordResetCreateOrConnectWithoutUserInput[]
    upsert?: passwordResetUpsertWithWhereUniqueWithoutUserInput | passwordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: passwordResetCreateManyUserInputEnvelope
    set?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    disconnect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    delete?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    connect?: passwordResetWhereUniqueInput | passwordResetWhereUniqueInput[]
    update?: passwordResetUpdateWithWhereUniqueWithoutUserInput | passwordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: passwordResetUpdateManyWithWhereWithoutUserInput | passwordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: passwordResetScalarWhereInput | passwordResetScalarWhereInput[]
  }

  export type notificacionesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput> | notificacionesCreateWithoutUserInput[] | notificacionesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificacionesCreateOrConnectWithoutUserInput | notificacionesCreateOrConnectWithoutUserInput[]
    upsert?: notificacionesUpsertWithWhereUniqueWithoutUserInput | notificacionesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificacionesCreateManyUserInputEnvelope
    set?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    disconnect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    delete?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    connect?: notificacionesWhereUniqueInput | notificacionesWhereUniqueInput[]
    update?: notificacionesUpdateWithWhereUniqueWithoutUserInput | notificacionesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificacionesUpdateManyWithWhereWithoutUserInput | notificacionesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
  }

  export type productosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput> | productosCreateWithoutUsuarioInput[] | productosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: productosCreateOrConnectWithoutUsuarioInput | productosCreateOrConnectWithoutUsuarioInput[]
    upsert?: productosUpsertWithWhereUniqueWithoutUsuarioInput | productosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: productosCreateManyUsuarioInputEnvelope
    set?: productosWhereUniqueInput | productosWhereUniqueInput[]
    disconnect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    delete?: productosWhereUniqueInput | productosWhereUniqueInput[]
    connect?: productosWhereUniqueInput | productosWhereUniqueInput[]
    update?: productosUpdateWithWhereUniqueWithoutUsuarioInput | productosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: productosUpdateManyWithWhereWithoutUsuarioInput | productosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: productosScalarWhereInput | productosScalarWhereInput[]
  }

  export type comentariosUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput> | comentariosCreateWithoutUserInput[] | comentariosUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutUserInput | comentariosCreateOrConnectWithoutUserInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutUserInput | comentariosUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comentariosCreateManyUserInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutUserInput | comentariosUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutUserInput | comentariosUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput> | NutriScanCreateWithoutUsuarioInput[] | NutriScanUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NutriScanCreateOrConnectWithoutUsuarioInput | NutriScanCreateOrConnectWithoutUsuarioInput[]
    upsert?: NutriScanUpsertWithWhereUniqueWithoutUsuarioInput | NutriScanUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NutriScanCreateManyUsuarioInputEnvelope
    set?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    disconnect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    delete?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    connect?: NutriScanWhereUniqueInput | NutriScanWhereUniqueInput[]
    update?: NutriScanUpdateWithWhereUniqueWithoutUsuarioInput | NutriScanUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NutriScanUpdateManyWithWhereWithoutUsuarioInput | NutriScanUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NutriScanScalarWhereInput | NutriScanScalarWhereInput[]
  }

  export type histInvUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput> | histInvCreateWithoutUsuarioInput[] | histInvUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutUsuarioInput | histInvCreateOrConnectWithoutUsuarioInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutUsuarioInput | histInvUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: histInvCreateManyUsuarioInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutUsuarioInput | histInvUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutUsuarioInput | histInvUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
    connectOrCreate?: preferenciasNotificacionesCreateOrConnectWithoutUserInput
    upsert?: preferenciasNotificacionesUpsertWithoutUserInput
    disconnect?: preferenciasNotificacionesWhereInput | boolean
    delete?: preferenciasNotificacionesWhereInput | boolean
    connect?: preferenciasNotificacionesWhereUniqueInput
    update?: XOR<XOR<preferenciasNotificacionesUpdateToOneWithWhereWithoutUserInput, preferenciasNotificacionesUpdateWithoutUserInput>, preferenciasNotificacionesUncheckedUpdateWithoutUserInput>
  }

  export type usersCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<usersCreateWithoutPasswordResetsInput, usersUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPasswordResetsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<usersCreateWithoutPasswordResetsInput, usersUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPasswordResetsInput
    upsert?: usersUpsertWithoutPasswordResetsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPasswordResetsInput, usersUpdateWithoutPasswordResetsInput>, usersUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type usersCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificacionesInput
    connect?: usersWhereUniqueInput
  }

  export type EnumTipoNotificacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoNotificacion
  }

  export type usersUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificacionesInput
    upsert?: usersUpsertWithoutNotificacionesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificacionesInput, usersUpdateWithoutNotificacionesInput>, usersUncheckedUpdateWithoutNotificacionesInput>
  }

  export type usersCreateNestedOneWithoutPreferenciasInput = {
    create?: XOR<usersCreateWithoutPreferenciasInput, usersUncheckedCreateWithoutPreferenciasInput>
    connectOrCreate?: usersCreateOrConnectWithoutPreferenciasInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPreferenciasNestedInput = {
    create?: XOR<usersCreateWithoutPreferenciasInput, usersUncheckedCreateWithoutPreferenciasInput>
    connectOrCreate?: usersCreateOrConnectWithoutPreferenciasInput
    upsert?: usersUpsertWithoutPreferenciasInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPreferenciasInput, usersUpdateWithoutPreferenciasInput>, usersUncheckedUpdateWithoutPreferenciasInput>
  }

  export type histInvCreateNestedManyWithoutProductoInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutProductosInput = {
    create?: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductosInput
    connect?: usersWhereUniqueInput
  }

  export type recorStockCreateNestedManyWithoutProductoInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
  }

  export type comentariosCreateNestedManyWithoutProductoInput = {
    create?: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput> | comentariosCreateWithoutProductoInput[] | comentariosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutProductoInput | comentariosCreateOrConnectWithoutProductoInput[]
    createMany?: comentariosCreateManyProductoInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type histInvUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
  }

  export type recorStockUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
  }

  export type comentariosUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput> | comentariosCreateWithoutProductoInput[] | comentariosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutProductoInput | comentariosCreateOrConnectWithoutProductoInput[]
    createMany?: comentariosCreateManyProductoInputEnvelope
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumEstadoProductoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoProducto
  }

  export type histInvUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutProductoInput | histInvUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutProductoInput | histInvUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutProductoInput | histInvUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductosInput
    upsert?: usersUpsertWithoutProductosInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProductosInput, usersUpdateWithoutProductosInput>, usersUncheckedUpdateWithoutProductosInput>
  }

  export type recorStockUpdateManyWithoutProductoNestedInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    upsert?: recorStockUpsertWithWhereUniqueWithoutProductoInput | recorStockUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    set?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    disconnect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    delete?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    update?: recorStockUpdateWithWhereUniqueWithoutProductoInput | recorStockUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: recorStockUpdateManyWithWhereWithoutProductoInput | recorStockUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
  }

  export type comentariosUpdateManyWithoutProductoNestedInput = {
    create?: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput> | comentariosCreateWithoutProductoInput[] | comentariosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutProductoInput | comentariosCreateOrConnectWithoutProductoInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutProductoInput | comentariosUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: comentariosCreateManyProductoInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutProductoInput | comentariosUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutProductoInput | comentariosUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type histInvUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput> | histInvCreateWithoutProductoInput[] | histInvUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: histInvCreateOrConnectWithoutProductoInput | histInvCreateOrConnectWithoutProductoInput[]
    upsert?: histInvUpsertWithWhereUniqueWithoutProductoInput | histInvUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: histInvCreateManyProductoInputEnvelope
    set?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    disconnect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    delete?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    connect?: histInvWhereUniqueInput | histInvWhereUniqueInput[]
    update?: histInvUpdateWithWhereUniqueWithoutProductoInput | histInvUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: histInvUpdateManyWithWhereWithoutProductoInput | histInvUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: histInvScalarWhereInput | histInvScalarWhereInput[]
  }

  export type recorStockUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput> | recorStockCreateWithoutProductoInput[] | recorStockUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: recorStockCreateOrConnectWithoutProductoInput | recorStockCreateOrConnectWithoutProductoInput[]
    upsert?: recorStockUpsertWithWhereUniqueWithoutProductoInput | recorStockUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: recorStockCreateManyProductoInputEnvelope
    set?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    disconnect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    delete?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    connect?: recorStockWhereUniqueInput | recorStockWhereUniqueInput[]
    update?: recorStockUpdateWithWhereUniqueWithoutProductoInput | recorStockUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: recorStockUpdateManyWithWhereWithoutProductoInput | recorStockUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
  }

  export type comentariosUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput> | comentariosCreateWithoutProductoInput[] | comentariosUncheckedCreateWithoutProductoInput[]
    connectOrCreate?: comentariosCreateOrConnectWithoutProductoInput | comentariosCreateOrConnectWithoutProductoInput[]
    upsert?: comentariosUpsertWithWhereUniqueWithoutProductoInput | comentariosUpsertWithWhereUniqueWithoutProductoInput[]
    createMany?: comentariosCreateManyProductoInputEnvelope
    set?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    disconnect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    delete?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    connect?: comentariosWhereUniqueInput | comentariosWhereUniqueInput[]
    update?: comentariosUpdateWithWhereUniqueWithoutProductoInput | comentariosUpdateWithWhereUniqueWithoutProductoInput[]
    updateMany?: comentariosUpdateManyWithWhereWithoutProductoInput | comentariosUpdateManyWithWhereWithoutProductoInput[]
    deleteMany?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
  }

  export type productosCreateNestedOneWithoutRecorStockInput = {
    create?: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    connectOrCreate?: productosCreateOrConnectWithoutRecorStockInput
    connect?: productosWhereUniqueInput
  }

  export type EnumEstadoRecordatorioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoRecordatorio
  }

  export type productosUpdateOneRequiredWithoutRecorStockNestedInput = {
    create?: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    connectOrCreate?: productosCreateOrConnectWithoutRecorStockInput
    upsert?: productosUpsertWithoutRecorStockInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutRecorStockInput, productosUpdateWithoutRecorStockInput>, productosUncheckedUpdateWithoutRecorStockInput>
  }

  export type usersCreateNestedOneWithoutComentariosInput = {
    create?: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usersCreateOrConnectWithoutComentariosInput
    connect?: usersWhereUniqueInput
  }

  export type productosCreateNestedOneWithoutComentariosInput = {
    create?: XOR<productosCreateWithoutComentariosInput, productosUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: productosCreateOrConnectWithoutComentariosInput
    connect?: productosWhereUniqueInput
  }

  export type EnumEstadoComentarioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoComentario
  }

  export type usersUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usersCreateOrConnectWithoutComentariosInput
    upsert?: usersUpsertWithoutComentariosInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutComentariosInput, usersUpdateWithoutComentariosInput>, usersUncheckedUpdateWithoutComentariosInput>
  }

  export type productosUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<productosCreateWithoutComentariosInput, productosUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: productosCreateOrConnectWithoutComentariosInput
    upsert?: productosUpsertWithoutComentariosInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutComentariosInput, productosUpdateWithoutComentariosInput>, productosUncheckedUpdateWithoutComentariosInput>
  }

  export type usersCreateNestedOneWithoutNutriScansInput = {
    create?: XOR<usersCreateWithoutNutriScansInput, usersUncheckedCreateWithoutNutriScansInput>
    connectOrCreate?: usersCreateOrConnectWithoutNutriScansInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNutriScansNestedInput = {
    create?: XOR<usersCreateWithoutNutriScansInput, usersUncheckedCreateWithoutNutriScansInput>
    connectOrCreate?: usersCreateOrConnectWithoutNutriScansInput
    upsert?: usersUpsertWithoutNutriScansInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNutriScansInput, usersUpdateWithoutNutriScansInput>, usersUncheckedUpdateWithoutNutriScansInput>
  }

  export type productosCreateNestedOneWithoutHistInvInput = {
    create?: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistInvInput
    connect?: productosWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutHistInvInput = {
    create?: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistInvInput
    connect?: usersWhereUniqueInput
  }

  export type EnumAccionHistorialFieldUpdateOperationsInput = {
    set?: $Enums.AccionHistorial
  }

  export type productosUpdateOneRequiredWithoutHistInvNestedInput = {
    create?: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: productosCreateOrConnectWithoutHistInvInput
    upsert?: productosUpsertWithoutHistInvInput
    connect?: productosWhereUniqueInput
    update?: XOR<XOR<productosUpdateToOneWithWhereWithoutHistInvInput, productosUpdateWithoutHistInvInput>, productosUncheckedUpdateWithoutHistInvInput>
  }

  export type usersUpdateOneRequiredWithoutHistInvNestedInput = {
    create?: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistInvInput
    upsert?: usersUpsertWithoutHistInvInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutHistInvInput, usersUpdateWithoutHistInvInput>, usersUncheckedUpdateWithoutHistInvInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTipoUsuarioNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel> | $Enums.TipoUsuario | null
  }

  export type NestedEnumrolEquipoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableFilter<$PrismaModel> | $Enums.rolEquipo | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoUsuarioNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTipoUsuarioNullableWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioNullableFilter<$PrismaModel>
  }

  export type NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rolEquipo | EnumrolEquipoFieldRefInput<$PrismaModel> | null
    in?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.rolEquipo[] | ListEnumrolEquipoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumrolEquipoNullableWithAggregatesFilter<$PrismaModel> | $Enums.rolEquipo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
    _max?: NestedEnumrolEquipoNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoNotificacion[] | ListEnumTipoNotificacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumEstadoProductoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProducto | EnumEstadoProductoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProductoFilter<$PrismaModel> | $Enums.EstadoProducto
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEstadoProductoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProducto | EnumEstadoProductoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProducto[] | ListEnumEstadoProductoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProductoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoProducto
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoProductoFilter<$PrismaModel>
    _max?: NestedEnumEstadoProductoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoRecordatorioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioFilter<$PrismaModel> | $Enums.EstadoRecordatorio
  }

  export type NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoRecordatorio | EnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoRecordatorio[] | ListEnumEstadoRecordatorioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoRecordatorioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoRecordatorio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
    _max?: NestedEnumEstadoRecordatorioFilter<$PrismaModel>
  }

  export type NestedEnumEstadoComentarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioFilter<$PrismaModel> | $Enums.EstadoComentario
  }

  export type NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoComentario | EnumEstadoComentarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoComentario[] | ListEnumEstadoComentarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoComentarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoComentario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoComentarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoComentarioFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAccionHistorialFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialFilter<$PrismaModel> | $Enums.AccionHistorial
  }

  export type NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionHistorial | EnumAccionHistorialFieldRefInput<$PrismaModel>
    in?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionHistorial[] | ListEnumAccionHistorialFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionHistorialWithAggregatesFilter<$PrismaModel> | $Enums.AccionHistorial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionHistorialFilter<$PrismaModel>
    _max?: NestedEnumAccionHistorialFilter<$PrismaModel>
  }

  export type usersCreateWithoutMiembrosInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutMiembrosInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutMiembrosInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMiembrosInput, usersUncheckedCreateWithoutMiembrosInput>
  }

  export type usersCreateWithoutJefeInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutJefeInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutJefeInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput>
  }

  export type usersCreateManyJefeInputEnvelope = {
    data: usersCreateManyJefeInput | usersCreateManyJefeInput[]
    skipDuplicates?: boolean
  }

  export type passwordResetCreateWithoutUserInput = {
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
  }

  export type passwordResetUncheckedCreateWithoutUserInput = {
    idSeguridad?: number
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
  }

  export type passwordResetCreateOrConnectWithoutUserInput = {
    where: passwordResetWhereUniqueInput
    create: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput>
  }

  export type passwordResetCreateManyUserInputEnvelope = {
    data: passwordResetCreateManyUserInput | passwordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notificacionesCreateWithoutUserInput = {
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
  }

  export type notificacionesUncheckedCreateWithoutUserInput = {
    idNotificacion?: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
  }

  export type notificacionesCreateOrConnectWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    create: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput>
  }

  export type notificacionesCreateManyUserInputEnvelope = {
    data: notificacionesCreateManyUserInput | notificacionesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type productosCreateWithoutUsuarioInput = {
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvCreateNestedManyWithoutProductoInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
    comentarios?: comentariosCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutUsuarioInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput>
  }

  export type productosCreateManyUsuarioInputEnvelope = {
    data: productosCreateManyUsuarioInput | productosCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type comentariosCreateWithoutUserInput = {
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
    producto: productosCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateWithoutUserInput = {
    idComentario?: number
    idProducto: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosCreateOrConnectWithoutUserInput = {
    where: comentariosWhereUniqueInput
    create: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput>
  }

  export type comentariosCreateManyUserInputEnvelope = {
    data: comentariosCreateManyUserInput | comentariosCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NutriScanCreateWithoutUsuarioInput = {
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
  }

  export type NutriScanUncheckedCreateWithoutUsuarioInput = {
    id?: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
  }

  export type NutriScanCreateOrConnectWithoutUsuarioInput = {
    where: NutriScanWhereUniqueInput
    create: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput>
  }

  export type NutriScanCreateManyUsuarioInputEnvelope = {
    data: NutriScanCreateManyUsuarioInput | NutriScanCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type histInvCreateWithoutUsuarioInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    producto: productosCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateWithoutUsuarioInput = {
    id?: number
    productoId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvCreateOrConnectWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    create: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput>
  }

  export type histInvCreateManyUsuarioInputEnvelope = {
    data: histInvCreateManyUsuarioInput | histInvCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type preferenciasNotificacionesCreateWithoutUserInput = {
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
  }

  export type preferenciasNotificacionesUncheckedCreateWithoutUserInput = {
    id?: number
    stockBajo?: boolean
    productoVencido?: boolean
    comentarios?: boolean
    reposicion?: boolean
    actualizacion?: boolean
  }

  export type preferenciasNotificacionesCreateOrConnectWithoutUserInput = {
    where: preferenciasNotificacionesWhereUniqueInput
    create: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
  }

  export type usersUpsertWithoutMiembrosInput = {
    update: XOR<usersUpdateWithoutMiembrosInput, usersUncheckedUpdateWithoutMiembrosInput>
    create: XOR<usersCreateWithoutMiembrosInput, usersUncheckedCreateWithoutMiembrosInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMiembrosInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMiembrosInput, usersUncheckedUpdateWithoutMiembrosInput>
  }

  export type usersUpdateWithoutMiembrosInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutMiembrosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutJefeInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutJefeInput, usersUncheckedUpdateWithoutJefeInput>
    create: XOR<usersCreateWithoutJefeInput, usersUncheckedCreateWithoutJefeInput>
  }

  export type usersUpdateWithWhereUniqueWithoutJefeInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutJefeInput, usersUncheckedUpdateWithoutJefeInput>
  }

  export type usersUpdateManyWithWhereWithoutJefeInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutJefeInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    idUsuario?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    correo?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    nombreCompleto?: StringFilter<"users"> | string
    telefono?: StringFilter<"users"> | string
    direccion?: StringFilter<"users"> | string
    fotoPerfil?: StringNullableFilter<"users"> | string | null
    nombreEmpresa?: StringNullableFilter<"users"> | string | null
    nit?: StringNullableFilter<"users"> | string | null
    estado?: StringFilter<"users"> | string
    rol?: StringFilter<"users"> | string
    tipoUsuario?: EnumTipoUsuarioNullableFilter<"users"> | $Enums.TipoUsuario | null
    rolEquipo?: EnumrolEquipoNullableFilter<"users"> | $Enums.rolEquipo | null
    perfilCompleto?: BoolFilter<"users"> | boolean
    empresaId?: IntNullableFilter<"users"> | number | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    deletedAt?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type passwordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: passwordResetWhereUniqueInput
    update: XOR<passwordResetUpdateWithoutUserInput, passwordResetUncheckedUpdateWithoutUserInput>
    create: XOR<passwordResetCreateWithoutUserInput, passwordResetUncheckedCreateWithoutUserInput>
  }

  export type passwordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: passwordResetWhereUniqueInput
    data: XOR<passwordResetUpdateWithoutUserInput, passwordResetUncheckedUpdateWithoutUserInput>
  }

  export type passwordResetUpdateManyWithWhereWithoutUserInput = {
    where: passwordResetScalarWhereInput
    data: XOR<passwordResetUpdateManyMutationInput, passwordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type passwordResetScalarWhereInput = {
    AND?: passwordResetScalarWhereInput | passwordResetScalarWhereInput[]
    OR?: passwordResetScalarWhereInput[]
    NOT?: passwordResetScalarWhereInput | passwordResetScalarWhereInput[]
    idSeguridad?: IntFilter<"passwordReset"> | number
    idUsuario?: IntFilter<"passwordReset"> | number
    token?: StringFilter<"passwordReset"> | string
    fechaSolicitud?: DateTimeFilter<"passwordReset"> | Date | string
    fechaExpiracion?: DateTimeFilter<"passwordReset"> | Date | string
    usado?: BoolFilter<"passwordReset"> | boolean
  }

  export type notificacionesUpsertWithWhereUniqueWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    update: XOR<notificacionesUpdateWithoutUserInput, notificacionesUncheckedUpdateWithoutUserInput>
    create: XOR<notificacionesCreateWithoutUserInput, notificacionesUncheckedCreateWithoutUserInput>
  }

  export type notificacionesUpdateWithWhereUniqueWithoutUserInput = {
    where: notificacionesWhereUniqueInput
    data: XOR<notificacionesUpdateWithoutUserInput, notificacionesUncheckedUpdateWithoutUserInput>
  }

  export type notificacionesUpdateManyWithWhereWithoutUserInput = {
    where: notificacionesScalarWhereInput
    data: XOR<notificacionesUpdateManyMutationInput, notificacionesUncheckedUpdateManyWithoutUserInput>
  }

  export type notificacionesScalarWhereInput = {
    AND?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
    OR?: notificacionesScalarWhereInput[]
    NOT?: notificacionesScalarWhereInput | notificacionesScalarWhereInput[]
    idNotificacion?: IntFilter<"notificaciones"> | number
    idUsuario?: IntFilter<"notificaciones"> | number
    tipo?: EnumTipoNotificacionFilter<"notificaciones"> | $Enums.TipoNotificacion
    titulo?: StringFilter<"notificaciones"> | string
    mensaje?: StringFilter<"notificaciones"> | string
    fechaEnvio?: DateTimeFilter<"notificaciones"> | Date | string
    leida?: BoolFilter<"notificaciones"> | boolean
  }

  export type productosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    update: XOR<productosUpdateWithoutUsuarioInput, productosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<productosCreateWithoutUsuarioInput, productosUncheckedCreateWithoutUsuarioInput>
  }

  export type productosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: productosWhereUniqueInput
    data: XOR<productosUpdateWithoutUsuarioInput, productosUncheckedUpdateWithoutUsuarioInput>
  }

  export type productosUpdateManyWithWhereWithoutUsuarioInput = {
    where: productosScalarWhereInput
    data: XOR<productosUpdateManyMutationInput, productosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type productosScalarWhereInput = {
    AND?: productosScalarWhereInput | productosScalarWhereInput[]
    OR?: productosScalarWhereInput[]
    NOT?: productosScalarWhereInput | productosScalarWhereInput[]
    id?: IntFilter<"productos"> | number
    codigoBarras?: StringNullableFilter<"productos"> | string | null
    codigoQR?: StringNullableFilter<"productos"> | string | null
    nombre?: StringFilter<"productos"> | string
    descripcion?: StringFilter<"productos"> | string
    precio?: DecimalFilter<"productos"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"productos"> | number
    fechaAdquisicion?: DateTimeFilter<"productos"> | Date | string
    fechaVencimiento?: DateTimeFilter<"productos"> | Date | string
    usuarioId?: IntFilter<"productos"> | number
    estado?: EnumEstadoProductoFilter<"productos"> | $Enums.EstadoProducto
    imagen?: StringFilter<"productos"> | string
    categoria?: StringNullableFilter<"productos"> | string | null
    createdAt?: DateTimeFilter<"productos"> | Date | string
    updatedAt?: DateTimeFilter<"productos"> | Date | string
    eliminadoEn?: DateTimeNullableFilter<"productos"> | Date | string | null
  }

  export type comentariosUpsertWithWhereUniqueWithoutUserInput = {
    where: comentariosWhereUniqueInput
    update: XOR<comentariosUpdateWithoutUserInput, comentariosUncheckedUpdateWithoutUserInput>
    create: XOR<comentariosCreateWithoutUserInput, comentariosUncheckedCreateWithoutUserInput>
  }

  export type comentariosUpdateWithWhereUniqueWithoutUserInput = {
    where: comentariosWhereUniqueInput
    data: XOR<comentariosUpdateWithoutUserInput, comentariosUncheckedUpdateWithoutUserInput>
  }

  export type comentariosUpdateManyWithWhereWithoutUserInput = {
    where: comentariosScalarWhereInput
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyWithoutUserInput>
  }

  export type comentariosScalarWhereInput = {
    AND?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
    OR?: comentariosScalarWhereInput[]
    NOT?: comentariosScalarWhereInput | comentariosScalarWhereInput[]
    idComentario?: IntFilter<"comentarios"> | number
    idUsuario?: IntFilter<"comentarios"> | number
    idProducto?: IntFilter<"comentarios"> | number
    comentario?: StringFilter<"comentarios"> | string
    fechaComentario?: DateTimeFilter<"comentarios"> | Date | string
    estado?: EnumEstadoComentarioFilter<"comentarios"> | $Enums.EstadoComentario
    createdAt?: DateTimeFilter<"comentarios"> | Date | string
    updatedAt?: DateTimeFilter<"comentarios"> | Date | string
  }

  export type NutriScanUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NutriScanWhereUniqueInput
    update: XOR<NutriScanUpdateWithoutUsuarioInput, NutriScanUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NutriScanCreateWithoutUsuarioInput, NutriScanUncheckedCreateWithoutUsuarioInput>
  }

  export type NutriScanUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NutriScanWhereUniqueInput
    data: XOR<NutriScanUpdateWithoutUsuarioInput, NutriScanUncheckedUpdateWithoutUsuarioInput>
  }

  export type NutriScanUpdateManyWithWhereWithoutUsuarioInput = {
    where: NutriScanScalarWhereInput
    data: XOR<NutriScanUpdateManyMutationInput, NutriScanUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type NutriScanScalarWhereInput = {
    AND?: NutriScanScalarWhereInput | NutriScanScalarWhereInput[]
    OR?: NutriScanScalarWhereInput[]
    NOT?: NutriScanScalarWhereInput | NutriScanScalarWhereInput[]
    id?: IntFilter<"NutriScan"> | number
    usuarioId?: IntFilter<"NutriScan"> | number
    esAlimento?: BoolFilter<"NutriScan"> | boolean
    consulta?: StringFilter<"NutriScan"> | string
    respuesta?: JsonFilter<"NutriScan">
    tipoAnalisis?: StringFilter<"NutriScan"> | string
    fechaAnalisis?: DateTimeFilter<"NutriScan"> | Date | string
    actualizadoEn?: DateTimeFilter<"NutriScan"> | Date | string
    isTest?: BoolFilter<"NutriScan"> | boolean
  }

  export type histInvUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    update: XOR<histInvUpdateWithoutUsuarioInput, histInvUncheckedUpdateWithoutUsuarioInput>
    create: XOR<histInvCreateWithoutUsuarioInput, histInvUncheckedCreateWithoutUsuarioInput>
  }

  export type histInvUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: histInvWhereUniqueInput
    data: XOR<histInvUpdateWithoutUsuarioInput, histInvUncheckedUpdateWithoutUsuarioInput>
  }

  export type histInvUpdateManyWithWhereWithoutUsuarioInput = {
    where: histInvScalarWhereInput
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type histInvScalarWhereInput = {
    AND?: histInvScalarWhereInput | histInvScalarWhereInput[]
    OR?: histInvScalarWhereInput[]
    NOT?: histInvScalarWhereInput | histInvScalarWhereInput[]
    id?: IntFilter<"histInv"> | number
    productoId?: IntFilter<"histInv"> | number
    usuarioId?: IntFilter<"histInv"> | number
    accion?: EnumAccionHistorialFilter<"histInv"> | $Enums.AccionHistorial
    cantidad_anterior?: IntFilter<"histInv"> | number
    cantidad_nueva?: IntFilter<"histInv"> | number
    precio_anterior?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFilter<"histInv"> | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFilter<"histInv"> | Date | string
  }

  export type preferenciasNotificacionesUpsertWithoutUserInput = {
    update: XOR<preferenciasNotificacionesUpdateWithoutUserInput, preferenciasNotificacionesUncheckedUpdateWithoutUserInput>
    create: XOR<preferenciasNotificacionesCreateWithoutUserInput, preferenciasNotificacionesUncheckedCreateWithoutUserInput>
    where?: preferenciasNotificacionesWhereInput
  }

  export type preferenciasNotificacionesUpdateToOneWithWhereWithoutUserInput = {
    where?: preferenciasNotificacionesWhereInput
    data: XOR<preferenciasNotificacionesUpdateWithoutUserInput, preferenciasNotificacionesUncheckedUpdateWithoutUserInput>
  }

  export type preferenciasNotificacionesUpdateWithoutUserInput = {
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type preferenciasNotificacionesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockBajo?: BoolFieldUpdateOperationsInput | boolean
    productoVencido?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: BoolFieldUpdateOperationsInput | boolean
    reposicion?: BoolFieldUpdateOperationsInput | boolean
    actualizacion?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersCreateWithoutPasswordResetsInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPasswordResetsInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPasswordResetsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPasswordResetsInput, usersUncheckedCreateWithoutPasswordResetsInput>
  }

  export type usersUpsertWithoutPasswordResetsInput = {
    update: XOR<usersUpdateWithoutPasswordResetsInput, usersUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<usersCreateWithoutPasswordResetsInput, usersUncheckedCreateWithoutPasswordResetsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPasswordResetsInput, usersUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type usersUpdateWithoutPasswordResetsInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPasswordResetsInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersCreateWithoutNotificacionesInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNotificacionesInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNotificacionesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
  }

  export type usersUpsertWithoutNotificacionesInput = {
    update: XOR<usersUpdateWithoutNotificacionesInput, usersUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<usersCreateWithoutNotificacionesInput, usersUncheckedCreateWithoutNotificacionesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificacionesInput, usersUncheckedUpdateWithoutNotificacionesInput>
  }

  export type usersUpdateWithoutNotificacionesInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificacionesInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersCreateWithoutPreferenciasInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
  }

  export type usersUncheckedCreateWithoutPreferenciasInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usersCreateOrConnectWithoutPreferenciasInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPreferenciasInput, usersUncheckedCreateWithoutPreferenciasInput>
  }

  export type usersUpsertWithoutPreferenciasInput = {
    update: XOR<usersUpdateWithoutPreferenciasInput, usersUncheckedUpdateWithoutPreferenciasInput>
    create: XOR<usersCreateWithoutPreferenciasInput, usersUncheckedCreateWithoutPreferenciasInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPreferenciasInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPreferenciasInput, usersUncheckedUpdateWithoutPreferenciasInput>
  }

  export type usersUpdateWithoutPreferenciasInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
  }

  export type usersUncheckedUpdateWithoutPreferenciasInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type histInvCreateWithoutProductoInput = {
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
    usuario: usersCreateNestedOneWithoutHistInvInput
  }

  export type histInvUncheckedCreateWithoutProductoInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type histInvCreateOrConnectWithoutProductoInput = {
    where: histInvWhereUniqueInput
    create: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput>
  }

  export type histInvCreateManyProductoInputEnvelope = {
    data: histInvCreateManyProductoInput | histInvCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutProductosInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutProductosInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutProductosInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
  }

  export type recorStockCreateWithoutProductoInput = {
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockUncheckedCreateWithoutProductoInput = {
    idRecordatorio?: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type recorStockCreateOrConnectWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    create: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput>
  }

  export type recorStockCreateManyProductoInputEnvelope = {
    data: recorStockCreateManyProductoInput | recorStockCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type comentariosCreateWithoutProductoInput = {
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutComentariosInput
  }

  export type comentariosUncheckedCreateWithoutProductoInput = {
    idComentario?: number
    idUsuario: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosCreateOrConnectWithoutProductoInput = {
    where: comentariosWhereUniqueInput
    create: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput>
  }

  export type comentariosCreateManyProductoInputEnvelope = {
    data: comentariosCreateManyProductoInput | comentariosCreateManyProductoInput[]
    skipDuplicates?: boolean
  }

  export type histInvUpsertWithWhereUniqueWithoutProductoInput = {
    where: histInvWhereUniqueInput
    update: XOR<histInvUpdateWithoutProductoInput, histInvUncheckedUpdateWithoutProductoInput>
    create: XOR<histInvCreateWithoutProductoInput, histInvUncheckedCreateWithoutProductoInput>
  }

  export type histInvUpdateWithWhereUniqueWithoutProductoInput = {
    where: histInvWhereUniqueInput
    data: XOR<histInvUpdateWithoutProductoInput, histInvUncheckedUpdateWithoutProductoInput>
  }

  export type histInvUpdateManyWithWhereWithoutProductoInput = {
    where: histInvScalarWhereInput
    data: XOR<histInvUpdateManyMutationInput, histInvUncheckedUpdateManyWithoutProductoInput>
  }

  export type usersUpsertWithoutProductosInput = {
    update: XOR<usersUpdateWithoutProductosInput, usersUncheckedUpdateWithoutProductosInput>
    create: XOR<usersCreateWithoutProductosInput, usersUncheckedCreateWithoutProductosInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProductosInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProductosInput, usersUncheckedUpdateWithoutProductosInput>
  }

  export type usersUpdateWithoutProductosInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutProductosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type recorStockUpsertWithWhereUniqueWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    update: XOR<recorStockUpdateWithoutProductoInput, recorStockUncheckedUpdateWithoutProductoInput>
    create: XOR<recorStockCreateWithoutProductoInput, recorStockUncheckedCreateWithoutProductoInput>
  }

  export type recorStockUpdateWithWhereUniqueWithoutProductoInput = {
    where: recorStockWhereUniqueInput
    data: XOR<recorStockUpdateWithoutProductoInput, recorStockUncheckedUpdateWithoutProductoInput>
  }

  export type recorStockUpdateManyWithWhereWithoutProductoInput = {
    where: recorStockScalarWhereInput
    data: XOR<recorStockUpdateManyMutationInput, recorStockUncheckedUpdateManyWithoutProductoInput>
  }

  export type recorStockScalarWhereInput = {
    AND?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
    OR?: recorStockScalarWhereInput[]
    NOT?: recorStockScalarWhereInput | recorStockScalarWhereInput[]
    idRecordatorio?: IntFilter<"recorStock"> | number
    productoId?: IntFilter<"recorStock"> | number
    cantidadMinima?: IntFilter<"recorStock"> | number
    fechaRecordatorio?: DateTimeFilter<"recorStock"> | Date | string
    estado?: EnumEstadoRecordatorioFilter<"recorStock"> | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFilter<"recorStock"> | Date | string
    updatedAt?: DateTimeFilter<"recorStock"> | Date | string
  }

  export type comentariosUpsertWithWhereUniqueWithoutProductoInput = {
    where: comentariosWhereUniqueInput
    update: XOR<comentariosUpdateWithoutProductoInput, comentariosUncheckedUpdateWithoutProductoInput>
    create: XOR<comentariosCreateWithoutProductoInput, comentariosUncheckedCreateWithoutProductoInput>
  }

  export type comentariosUpdateWithWhereUniqueWithoutProductoInput = {
    where: comentariosWhereUniqueInput
    data: XOR<comentariosUpdateWithoutProductoInput, comentariosUncheckedUpdateWithoutProductoInput>
  }

  export type comentariosUpdateManyWithWhereWithoutProductoInput = {
    where: comentariosScalarWhereInput
    data: XOR<comentariosUpdateManyMutationInput, comentariosUncheckedUpdateManyWithoutProductoInput>
  }

  export type productosCreateWithoutRecorStockInput = {
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    comentarios?: comentariosCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutRecorStockInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutRecorStockInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
  }

  export type productosUpsertWithoutRecorStockInput = {
    update: XOR<productosUpdateWithoutRecorStockInput, productosUncheckedUpdateWithoutRecorStockInput>
    create: XOR<productosCreateWithoutRecorStockInput, productosUncheckedCreateWithoutRecorStockInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutRecorStockInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutRecorStockInput, productosUncheckedUpdateWithoutRecorStockInput>
  }

  export type productosUpdateWithoutRecorStockInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    comentarios?: comentariosUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutRecorStockInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersCreateWithoutComentariosInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutComentariosInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutComentariosInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
  }

  export type productosCreateWithoutComentariosInput = {
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvCreateNestedManyWithoutProductoInput
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutComentariosInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    histInv?: histInvUncheckedCreateNestedManyWithoutProductoInput
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutComentariosInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutComentariosInput, productosUncheckedCreateWithoutComentariosInput>
  }

  export type usersUpsertWithoutComentariosInput = {
    update: XOR<usersUpdateWithoutComentariosInput, usersUncheckedUpdateWithoutComentariosInput>
    create: XOR<usersCreateWithoutComentariosInput, usersUncheckedCreateWithoutComentariosInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutComentariosInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutComentariosInput, usersUncheckedUpdateWithoutComentariosInput>
  }

  export type usersUpdateWithoutComentariosInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutComentariosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type productosUpsertWithoutComentariosInput = {
    update: XOR<productosUpdateWithoutComentariosInput, productosUncheckedUpdateWithoutComentariosInput>
    create: XOR<productosCreateWithoutComentariosInput, productosUncheckedCreateWithoutComentariosInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutComentariosInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutComentariosInput, productosUncheckedUpdateWithoutComentariosInput>
  }

  export type productosUpdateWithoutComentariosInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersCreateWithoutNutriScansInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    histInv?: histInvCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNutriScansInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    histInv?: histInvUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNutriScansInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNutriScansInput, usersUncheckedCreateWithoutNutriScansInput>
  }

  export type usersUpsertWithoutNutriScansInput = {
    update: XOR<usersUpdateWithoutNutriScansInput, usersUncheckedUpdateWithoutNutriScansInput>
    create: XOR<usersCreateWithoutNutriScansInput, usersUncheckedCreateWithoutNutriScansInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNutriScansInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNutriScansInput, usersUncheckedUpdateWithoutNutriScansInput>
  }

  export type usersUpdateWithoutNutriScansInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNutriScansInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type productosCreateWithoutHistInvInput = {
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    usuario: usersCreateNestedOneWithoutProductosInput
    recorStock?: recorStockCreateNestedManyWithoutProductoInput
    comentarios?: comentariosCreateNestedManyWithoutProductoInput
  }

  export type productosUncheckedCreateWithoutHistInvInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    usuarioId: number
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
    recorStock?: recorStockUncheckedCreateNestedManyWithoutProductoInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutProductoInput
  }

  export type productosCreateOrConnectWithoutHistInvInput = {
    where: productosWhereUniqueInput
    create: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
  }

  export type usersCreateWithoutHistInvInput = {
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jefe?: usersCreateNestedOneWithoutMiembrosInput
    miembros?: usersCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesCreateNestedManyWithoutUserInput
    productos?: productosCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutHistInvInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    empresaId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    miembros?: usersUncheckedCreateNestedManyWithoutJefeInput
    passwordResets?: passwordResetUncheckedCreateNestedManyWithoutUserInput
    notificaciones?: notificacionesUncheckedCreateNestedManyWithoutUserInput
    productos?: productosUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentariosUncheckedCreateNestedManyWithoutUserInput
    nutriScans?: NutriScanUncheckedCreateNestedManyWithoutUsuarioInput
    preferencias?: preferenciasNotificacionesUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutHistInvInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
  }

  export type productosUpsertWithoutHistInvInput = {
    update: XOR<productosUpdateWithoutHistInvInput, productosUncheckedUpdateWithoutHistInvInput>
    create: XOR<productosCreateWithoutHistInvInput, productosUncheckedCreateWithoutHistInvInput>
    where?: productosWhereInput
  }

  export type productosUpdateToOneWithWhereWithoutHistInvInput = {
    where?: productosWhereInput
    data: XOR<productosUpdateWithoutHistInvInput, productosUncheckedUpdateWithoutHistInvInput>
  }

  export type productosUpdateWithoutHistInvInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuario?: usersUpdateOneRequiredWithoutProductosNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutHistInvInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type usersUpsertWithoutHistInvInput = {
    update: XOR<usersUpdateWithoutHistInvInput, usersUncheckedUpdateWithoutHistInvInput>
    create: XOR<usersCreateWithoutHistInvInput, usersUncheckedCreateWithoutHistInvInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutHistInvInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutHistInvInput, usersUncheckedUpdateWithoutHistInvInput>
  }

  export type usersUpdateWithoutHistInvInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jefe?: usersUpdateOneWithoutMiembrosNestedInput
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutHistInvInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    empresaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersCreateManyJefeInput = {
    idUsuario?: number
    username: string
    correo: string
    password: string
    nombreCompleto: string
    telefono: string
    direccion: string
    fotoPerfil?: string | null
    nombreEmpresa?: string | null
    nit?: string | null
    estado: string
    rol: string
    tipoUsuario?: $Enums.TipoUsuario | null
    rolEquipo?: $Enums.rolEquipo | null
    perfilCompleto?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type passwordResetCreateManyUserInput = {
    idSeguridad?: number
    token: string
    fechaSolicitud: Date | string
    fechaExpiracion: Date | string
    usado?: boolean
  }

  export type notificacionesCreateManyUserInput = {
    idNotificacion?: number
    tipo: $Enums.TipoNotificacion
    titulo: string
    mensaje: string
    fechaEnvio?: Date | string
    leida?: boolean
  }

  export type productosCreateManyUsuarioInput = {
    id?: number
    codigoBarras?: string | null
    codigoQR?: string | null
    nombre: string
    descripcion: string
    precio: Decimal | DecimalJsLike | number | string
    cantidad: number
    fechaAdquisicion: Date | string
    fechaVencimiento: Date | string
    estado: $Enums.EstadoProducto
    imagen: string
    categoria?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eliminadoEn?: Date | string | null
  }

  export type comentariosCreateManyUserInput = {
    idComentario?: number
    idProducto: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutriScanCreateManyUsuarioInput = {
    id?: number
    esAlimento: boolean
    consulta: string
    respuesta: JsonNullValueInput | InputJsonValue
    tipoAnalisis: string
    fechaAnalisis?: Date | string
    actualizadoEn?: Date | string
    isTest?: boolean
  }

  export type histInvCreateManyUsuarioInput = {
    id?: number
    productoId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type usersUpdateWithoutJefeInput = {
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUpdateManyWithoutUserNestedInput
    productos?: productosUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutJefeInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    miembros?: usersUncheckedUpdateManyWithoutJefeNestedInput
    passwordResets?: passwordResetUncheckedUpdateManyWithoutUserNestedInput
    notificaciones?: notificacionesUncheckedUpdateManyWithoutUserNestedInput
    productos?: productosUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutUserNestedInput
    nutriScans?: NutriScanUncheckedUpdateManyWithoutUsuarioNestedInput
    histInv?: histInvUncheckedUpdateManyWithoutUsuarioNestedInput
    preferencias?: preferenciasNotificacionesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutJefeInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    fotoPerfil?: NullableStringFieldUpdateOperationsInput | string | null
    nombreEmpresa?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    rol?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: NullableEnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario | null
    rolEquipo?: NullableEnumrolEquipoFieldUpdateOperationsInput | $Enums.rolEquipo | null
    perfilCompleto?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passwordResetUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type passwordResetUncheckedUpdateWithoutUserInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type passwordResetUncheckedUpdateManyWithoutUserInput = {
    idSeguridad?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    fechaSolicitud?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaExpiracion?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUpdateWithoutUserInput = {
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateWithoutUserInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notificacionesUncheckedUpdateManyWithoutUserInput = {
    idNotificacion?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    leida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productosUpdateWithoutUsuarioInput = {
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    histInv?: histInvUncheckedUpdateManyWithoutProductoNestedInput
    recorStock?: recorStockUncheckedUpdateManyWithoutProductoNestedInput
    comentarios?: comentariosUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type productosUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoBarras?: NullableStringFieldUpdateOperationsInput | string | null
    codigoQR?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    fechaAdquisicion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoProductoFieldUpdateOperationsInput | $Enums.EstadoProducto
    imagen?: StringFieldUpdateOperationsInput | string
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eliminadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comentariosUpdateWithoutUserInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateWithoutUserInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyWithoutUserInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idProducto?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutriScanUpdateWithoutUsuarioInput = {
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NutriScanUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NutriScanUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    esAlimento?: BoolFieldUpdateOperationsInput | boolean
    consulta?: StringFieldUpdateOperationsInput | string
    respuesta?: JsonNullValueInput | InputJsonValue
    tipoAnalisis?: StringFieldUpdateOperationsInput | string
    fechaAnalisis?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    isTest?: BoolFieldUpdateOperationsInput | boolean
  }

  export type histInvUpdateWithoutUsuarioInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    producto?: productosUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvCreateManyProductoInput = {
    id?: number
    usuarioId: number
    accion: $Enums.AccionHistorial
    cantidad_anterior: number
    cantidad_nueva: number
    precio_anterior: Decimal | DecimalJsLike | number | string
    precio_nuevo: Decimal | DecimalJsLike | number | string
    fechaCambio: Date | string
  }

  export type recorStockCreateManyProductoInput = {
    idRecordatorio?: number
    cantidadMinima: number
    fechaRecordatorio: Date | string
    estado: $Enums.EstadoRecordatorio
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type comentariosCreateManyProductoInput = {
    idComentario?: number
    idUsuario: number
    comentario: string
    fechaComentario: Date | string
    estado: $Enums.EstadoComentario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type histInvUpdateWithoutProductoInput = {
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usersUpdateOneRequiredWithoutHistInvNestedInput
  }

  export type histInvUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type histInvUncheckedUpdateManyWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    accion?: EnumAccionHistorialFieldUpdateOperationsInput | $Enums.AccionHistorial
    cantidad_anterior?: IntFieldUpdateOperationsInput | number
    cantidad_nueva?: IntFieldUpdateOperationsInput | number
    precio_anterior?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    precio_nuevo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fechaCambio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUpdateWithoutProductoInput = {
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateWithoutProductoInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recorStockUncheckedUpdateManyWithoutProductoInput = {
    idRecordatorio?: IntFieldUpdateOperationsInput | number
    cantidadMinima?: IntFieldUpdateOperationsInput | number
    fechaRecordatorio?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoRecordatorioFieldUpdateOperationsInput | $Enums.EstadoRecordatorio
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUpdateWithoutProductoInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentariosUncheckedUpdateWithoutProductoInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentariosUncheckedUpdateManyWithoutProductoInput = {
    idComentario?: IntFieldUpdateOperationsInput | number
    idUsuario?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    fechaComentario?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoComentarioFieldUpdateOperationsInput | $Enums.EstadoComentario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}